<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++岗位方向穷举</title>
    <url>/2023/08/22/C++%E5%B2%97%E4%BD%8D%E6%96%B9%E5%90%91%E7%A9%B7%E4%B8%BE/</url>
    <content><![CDATA[<p>转载自<a class="link" href="https://www.zhihu.com/question/304959838">知乎 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="我按照不同的方式分类讨论，并且按照各个分类中耳熟能详的程度进行了排名"><a href="#我按照不同的方式分类讨论，并且按照各个分类中耳熟能详的程度进行了排名" class="headerlink" title="我按照不同的方式分类讨论，并且按照各个分类中耳熟能详的程度进行了排名"></a>我按照不同的方式分类讨论，并且按照各个分类中耳熟能详的程度进行了排名</h2><h2 id="按照公司列举"><a href="#按照公司列举" class="headerlink" title="按照公司列举"></a>按照公司列举</h2><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><ul>
<li>几乎所有部门的产品，后端都使用C++，尽管有许多新业务使用Go，以及部分旧业务在做Go的迁移，但C++仍然占有很大的技术栈</li>
<li>游戏使用虚幻引擎开发的，都是C++为技术栈</li>
</ul>
<h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ul>
<li>核心产品部门的后端，如百度大搜搜索引擎、贴吧等等</li>
</ul>
<h3 id="微软中国"><a href="#微软中国" class="headerlink" title="微软中国"></a>微软中国</h3><ul>
<li>主要是C#，但是接受转语言，C++很适合转</li>
</ul>
<h3 id="各个使用虚幻引擎开发的游戏公司，只要有游戏是使用虚幻引擎进行开发的，那么它就一定有C-，有很多你们喜欢的游戏公司～"><a href="#各个使用虚幻引擎开发的游戏公司，只要有游戏是使用虚幻引擎进行开发的，那么它就一定有C-，有很多你们喜欢的游戏公司～" class="headerlink" title="各个使用虚幻引擎开发的游戏公司，只要有游戏是使用虚幻引擎进行开发的，那么它就一定有C++，有很多你们喜欢的游戏公司～"></a>各个使用虚幻引擎开发的游戏公司，只要有游戏是使用虚幻引擎进行开发的，那么它就一定有C++，有很多你们喜欢的游戏公司～</h3><h3 id="华为、中兴等通信公司"><a href="#华为、中兴等通信公司" class="headerlink" title="华为、中兴等通信公司"></a>华为、中兴等通信公司</h3><ul>
<li>终端设备、路由器、交换机、云存储等，部分使用的是C语言，姑且也算进C++的范畴</li>
</ul>
<h3 id="思科、爱立信中国研发中心"><a href="#思科、爱立信中国研发中心" class="headerlink" title="思科、爱立信中国研发中心"></a>思科、爱立信中国研发中心</h3><h3 id="外企：联想、IBM、浪潮、戴尔、红帽、vmware、intel"><a href="#外企：联想、IBM、浪潮、戴尔、红帽、vmware、intel" class="headerlink" title="外企：联想、IBM、浪潮、戴尔、红帽、vmware、intel"></a>外企：联想、IBM、浪潮、戴尔、红帽、vmware、intel</h3><h2 id="按照部门列举"><a href="#按照部门列举" class="headerlink" title="按照部门列举"></a>按照部门列举</h2><h3 id="各个互联网公司的基础架构部门"><a href="#各个互联网公司的基础架构部门" class="headerlink" title="各个互联网公司的基础架构部门"></a>各个互联网公司的基础架构部门</h3><ul>
<li>通用组件、统一服务基础平台（缓存、计费、消息队列等）</li>
</ul>
<h3 id="各大互联网公司算法部门"><a href="#各大互联网公司算法部门" class="headerlink" title="各大互联网公司算法部门"></a>各大互联网公司算法部门</h3><ul>
<li>主要是算法的工程实现，并非算法设计本身，弄清楚算法设计和实现的概念不同（广告、推荐、搜索）</li>
</ul>
<h3 id="各大互联网公司的云服务核心系统"><a href="#各大互联网公司的云服务核心系统" class="headerlink" title="各大互联网公司的云服务核心系统"></a>各大互联网公司的云服务核心系统</h3><h3 id="各大互联网公司的游戏部门"><a href="#各大互联网公司的游戏部门" class="headerlink" title="各大互联网公司的游戏部门"></a>各大互联网公司的游戏部门</h3><ul>
<li>使用虚幻引擎进行的开发：客户端开发、引擎开发、技术相关均是</li>
</ul>
<h2 id="按照业务列举"><a href="#按照业务列举" class="headerlink" title="按照业务列举"></a>按照业务列举</h2><ul>
<li>部分大型互联网公司业务后端</li>
<li>存储相关、数据库相关、数据库内核、核心系统</li>
<li>金融：量化、交易、高频交易（为了性能，别无他选）、证券交易软件后台</li>
<li>银行核心交易系统、网银客户端、协议（大部分知名银行软开用Java为技术栈）</li>
<li>音视频开发（协议）：ffmpeg，编解码均C++、流媒体、协议、SDK</li>
<li>图像处理（计算机图形学相关）、计算机视觉相关</li>
<li>航天、军工、卫星通信、铁路通信（根正苗红的国企）</li>
<li>杀毒引擎（安全相关）</li>
<li>网络安全&#x2F;逆向</li>
<li>无人机、物联网偏硬件部分的研发</li>
<li>智能家居：安卓底层开发</li>
<li>嵌入式开发、物联网相关（首选C，C++辅助）</li>
<li>地图产品</li>
<li>桌面输入法、云联想</li>
<li>Windows桌面程序开发：Qt</li>
<li>浏览器（你能想到的国产浏览器）</li>
<li>各个硬件公司的Windows驱动开发</li>
</ul>
]]></content>
      <categories>
        <category>Sharing</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>就业</tag>
      </tags>
  </entry>
  <entry>
    <title>C++科班学习路线</title>
    <url>/2023/08/22/C++%E7%A7%91%E7%8F%AD%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>参考<a class="link" href="https://github.com/tomstillcoding/cs-roadmap/blob/main/c%2B%2B/2022_%E6%9C%80%E6%96%B0C%2B%2B%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF_%E7%A7%91%E7%8F%AD%E7%89%88.md">github <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="找资料"><a href="#找资料" class="headerlink" title="找资料"></a>找资料</h2><p>推荐几个网站</p>
<ul>
<li><a class="link" href="https://xmsoushu.com/#/">https://xmsoushu.com/#/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link" href="https://zbook.eu.org/">https://zbook.eu.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link" href="https://www.jiumodiary.com/">https://www.jiumodiary.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h3 id="顺序，从上到下依次学习，尽量不要跳跃"><a href="#顺序，从上到下依次学习，尽量不要跳跃" class="headerlink" title="顺序，从上到下依次学习，尽量不要跳跃"></a>顺序，从上到下依次学习，尽量不要跳跃</h3><h3 id="计算机导论"><a href="#计算机导论" class="headerlink" title="计算机导论"></a>计算机导论</h3><ul>
<li><p>计算机科学导论</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《计算机科学概论》</p>
<ul>
<li>导论，就是一个目录的作用。我建议学计算机之前先看看，看不懂不要紧，有个大致的印象就差不多了，本来也是起一个计算机系目录的作用，不用对目录的每个名词都刨根问底，以后有的是机会。一共只有三百多页，已经算很少了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>软件工程导论</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《软件工程：实践者的研究方法》</p>
<ul>
<li>不建议初学者读，不建议大部分人读，六百多页，很花时间，内容和知识太多太繁杂，确实也算是软件工程SE的目录，但更适合等你其他必修课学完之后，再确定好以后做软件工程的方向，并且开始工作之后，再读这本书，书里的知识绝大部分更偏向于工业实践，在学校里面，读了意义也不大，大概率无法理解。可以直接跳过，但是确实软件工程导论已经没有其他书可以推荐了，软件工程本来就是从计算机科学与技术里面细分出来的分支，不要对这门课要求太高。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基础类（必看）"><a href="#基础类（必看）" class="headerlink" title="基础类（必看）"></a>基础类（必看）</h3><ul>
<li><p>C语言</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《C程序设计语言》</p>
<ul>
<li>C语言这种书，要学深入了，可以推荐很多书，但是这里我是把它当作本科第一门编程语言来学习的，所以没必要学什么特别厚的书，这本就够了，学学语法，熟悉一下学一门语言大概有哪些的东西，写一点迷你程序就够了，最重要的是：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>1、学习指针，了解到了内存管理最基本的东西，给你以后学操作系统课程有一个印象。<br>2、学习从代码到可执行程序，了解整个代码到生成产物的过程，给你以后学编译原理埋下伏笔。</p>
<p>所以要我说初学者学C语言的目的是什么，我觉得是学语法感受编程、学指针感受内存管理、学编译感受从代码到执行。</p>
<ul>
<li><p>简单面向对象语言（C++为例）</p>
<ul>
<li><p>网站</p>
<ul>
<li>W3Cschool教程：<a class="link" href="https://www.w3cschool.cn/cpp/">https://www.w3cschool.cn/cpp/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>菜鸟教程：<a class="link" href="https://www.runoob.com/cplusplus/cpp-tutorial.html">https://www.runoob.com/cplusplus/cpp-tutorial.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
</li>
<li><p>数据结构</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《数据结构（C++语言版）》</p>
<ul>
<li>学习数据结构，语言不是什么问题，用什么语言都可以学习数据结构，用C、C++、Python、Java都可以实现各种各样的数据结构，为什么这里用的教材语言是C++的，纯粹是因为我暂时没有找到其他语言更好的国内教材。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>C++系统性学习</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《C++ Primer》</p>
<ul>
<li>听我先说啊，这本书800多页，非常厚，而且是工具书、字典那样的，其实根本不适合新手入门去学习面向对象技术与方法。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为什么这里就推荐这个书，最大的原因是数据结构教材，用到的语言是C++，当然也有用C语言的，但是我没找到特别好的书，所以没有办法，只能让大家先看看C++，大部分初级工程师在使用C++的时候，也只用到了面向对象的特性，很多高级特性都用不上，模板都用得很少，真的就是写ifelse而已。</p>
<p>这本书非常厚，不管是第一次学C++还是第N次学C++都要看，所以我推荐你们，先去什么类似菜鸟教程那样地方，先把C++大概的内容过一遍，那个应该很快就能过完，然后你过完之后就去看我接下来介绍的以C++为语言的数据结构教材，如果你看不明白，发现有不懂的C++的地方，你再去看这个C++ Primer，不要把C++ Primer当作是那种，看完了书，就再也不翻了，不会的，你会经常、一直去翻它。</p>
<ul>
<li><p>计算理论与算法分析</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《算法设计与分析基础》</p>
<ul>
<li>我们计算机系上的课，是计算理论和算法分析，这里只推荐了算法分析的教材。因为计算理论那里面的什么图灵机的构造，图灵完备性证明之类的，更偏于理论，你们肯定学起来也枯燥，觉得没意思，那是属于计算机系开天辟地级别的知识，如果有兴趣，可以自己去找相关的书来看，我就不推荐了。</li>
<li>主要是本科教材要么找不到，要么就是写得比较一般，网上又推荐什么算法导论纯粹来搞笑的，这本算法书挺好的，但内容确实也挺多的，确实是我之前视频说的课程算法。我看了目录，就勾起了我大二的回忆，希望大家不要怕这本书太厚太多，还是可以看看的，实在不能理解的内容，跳过就好了，以后再来理解。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库原理与设计</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《数据库系统概论》</p>
</li>
<li><p>《数据库系统概念》</p>
<ul>
<li>数据库是真的不好推荐，国内的教材和国外的教材其实是两种思路，国内是把你当天才，很多东西默认你懂，或者是一句很简单的话直接带过，觉得你理解了；而国外的教材就是把你当傻子，讲得非常细，非常多，就像是把上课的时候学生提问都记录下来了。从页数也可以看得出来，一个400页，一个800页，当然这是概论课，不会花大心思给你讲MySQL怎么用，MySQL只是理论的一种实现框架罢了，大学教这个不是为了让你去打工当后端，而是看你是不是对数据库研发感兴趣，以后没准你就选了这个方向。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这两本书就是国内外大学教材的一个经典对比</p>
<p>所以到底你们更喜欢哪种教学方式呢，这个取决于你，当然了，我大二学的是国内的教材。</p>
<h3 id="进阶类（必看）"><a href="#进阶类（必看）" class="headerlink" title="进阶类（必看）"></a>进阶类（必看）</h3><ul>
<li><p>操作系统</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《操作系统导论》</p>
</li>
<li><p>《操作系统原理、实现与实践》</p>
<ul>
<li>进阶类的操作系统，可以看的书特别多，你去豆瓣上搜索操作系统四个字，有特别多经典的黑皮书，我这里全都推荐的话，入初学者肯定是看不完的，所以更多还是推荐一些导论类的课程，等你们看完了，学完了，再去看那些黑皮书，其实就挺好的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这里的国内那本，最大的优点是章节分得很清晰，界限分明，非常像我大三学的那门课的样子，可能也是因为国内的教材设计是一脉相承的，我觉得挺适合一开始看这本的。</p>
<p>国外的那本，章节可能分得不是很清晰，但是循序渐进，短小精悍，讲的细致的地方也更多，典型国外教材风格。</p>
<p>不知道你们到底适合哪种，所以都给你看介绍一下看看。</p>
<ul>
<li><p>计算机组成原理</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《计算机组成原理唐朔飞》</p>
</li>
<li><p>《计算机组成与设计硬件&#x2F;软件接口》</p>
<ul>
<li>计组本身就是软硬件都有的课程，一开始找这种讲整个体系的书的时候，就特别累，因为确实很难兼顾自学，同时又要书还不错，保证一定的深度，比较难搞。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大学的时候学的书，基本都是学校老师写的教材，或者是上面那种样子的书，高等教育出版社，几乎都是一模一样的，看你感觉自己喜欢哪种书吧。这个书，其实想做软件工程，尽快找个工作，转码，确实也不是必须看的，和计算机体系结构、汇编、编译原理一样，面试根本不问。但毕竟大学是通识教育，是让你找到未来方向的，所以感兴趣，看看其实也行。</p>
<ul>
<li><p>计算机体系结构</p>
<ul>
<li>这个课很硬件，我感觉我推荐了，大家也不会看，关注我的更多的还是想在互联网、游戏行业的，就索性算了吧。</li>
</ul>
</li>
<li><p>计算机网络</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《计算机网络》（谢希仁版）</p>
</li>
<li><p>《计算机网络：自顶向下方法》</p>
<ul>
<li>这两本书，我本科的时候都看了，我特别特别特别特别喜欢这门课。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>上课用的谢希仁那本，结课后自己看的自顶向下。谢希仁的那本是自底向上的，当时大三从物理层开始往上学，最后学到应用层之后，开始介绍我们互联网的各种各样的应用，给我的感觉就是一切的辛苦终于换来了成果，好像打开了一座又一座的金矿一样。</p>
<p>但是呢看完谢希仁那本，还是有一些疑问，所以又去看了自顶向下，看完之后之前的挺多问题就解决了，谈不上哪本书更好，因为我看自顶向下的时候已经对计网有很多理解了。</p>
<ul>
<li><p>汇编与接口技术</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《汇编语言》王爽</p>
<ul>
<li>还是一样的，汇编面试不问，属于基础课，但工作之后有概率会遇到汇编语言，但需要你解决的问题，大概率比书里面的问题浅非常多，学有余力去看看吧。当然如果你想做相关工作的话，那就不一样了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>编译原理与设计</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《编译原理》（龙书）</p>
</li>
<li><p>《编译原理》（清华大学出版社）</p>
<ul>
<li>到了编译原理、汇编、计网这种课程，推荐入门书已经没有任何意义了，基本都开始推荐经典教材了，因为看这个的时候早就不是入门阶段了，深度早就该提上来了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>龙书很经典，但编译原理这门课和计网、操作系统类似，需要你写代码，非常重要，你也可以去看网上的各种lab，都可以，你觉得适合自己的学习方式就好，觉得学到了知识就好，没任何问题，也完全不用跟我一样，喜欢看书啃书，这个完全是因人而异。</p>
<p>这里为什么还把清华大学出版社的编译原理拿出来，就是告诉大家，我本科学的就是这个书，我的编译原理老师很厉害，很不错，但是我不太喜欢这本教材，当时上这个课我看这本书非常难受，总有一种哪里好像没讲的感觉，但我翻来翻去，就是找不到知识点，但就是感觉脑海里的知识缺了一块，不知道是为什么。强烈不推荐大家看这个紫皮书。</p>
<h3 id="选修类（后端开发方向选看）"><a href="#选修类（后端开发方向选看）" class="headerlink" title="选修类（后端开发方向选看）"></a>选修类（后端开发方向选看）</h3><ul>
<li><p>Java语言程序设计</p>
</li>
<li><p>Linux程序设计</p>
<ul>
<li><p>书籍</p>
<ul>
<li><p>《鸟哥的Linux私房菜基础学习篇》</p>
<ul>
<li>大部头，仅入门，不要去记忆，而是理解、应用一次书中提到的各种概念即可，一定要配套一个Linux操作系统来进行学习，边学边写</li>
</ul>
</li>
<li><p>《Linux高性能服务器编程》</p>
<ul>
<li>仅仅是一本Linux服务器编程的入门书，在学过C语言、计算机网络、操作系统之后学习</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式系统设计</p>
<ul>
<li>《大规模分布式存储系统：原理解析与架构实战》</li>
<li>《Paxos到Zookeeper：分布式一致性原理与实践》</li>
<li>《分布式系统：概念与设计》</li>
</ul>
</li>
</ul>
<h2 id="实力提升"><a href="#实力提升" class="headerlink" title="实力提升"></a>实力提升</h2><p>进入这一步，一定是要基础部分提到的内容已经掌握很熟练之后，再来进阶学习，否则学习效率会很低，因为你看不懂。并且该部分需要自己选择内容去学习，并非全部都要完全掌握</p>
<h3 id="C-x2F-C"><a href="#C-x2F-C" class="headerlink" title="C &#x2F; C++"></a>C &#x2F; C++</h3><ul>
<li>《C++ Primer》</li>
<li>《Effective C++》</li>
<li>《STL源码剖析》</li>
</ul>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul>
<li>《现代操作系统》</li>
</ul>
<h3 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h3><ul>
<li>《深入理解计算机系统》</li>
</ul>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul>
<li>《计算机网络：自顶向下方法》</li>
<li>《TCP&#x2F;IP 详解》</li>
<li>《图解HTTP》</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>《MySQL必知必会》</li>
<li>《高性能MySQL》</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>《Redis设计与实现》</li>
</ul>
<h2 id="离谱之路"><a href="#离谱之路" class="headerlink" title="离谱之路"></a>离谱之路</h2><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>这部分是根据网络整理出来，适合C++后端开发写入简历的项目，有的没有文档，因此需要你直接看它的源码实现，只要你理解了它的代码，并且自己手动实现一次，就能保证面试的时候对答如流，那么写进简历是没问题的。</p>
<ul>
<li><p>前言</p>
<ul>
<li><p>项目，就是你看完、学完、自己默默实现完之后，可以写进你简历的项目。强烈建议，不要做重复相似的项目、不要做不适合校招生做的项目、尽量做能体现计算机系水平的项目、你的项目不要只局限于一门语言，并非做C++路线，就一定要做C++项目，你做Go、Java项目一样很不错嘛，前提是项目要好</p>
</li>
<li><p>这里给出的项目，只是例子，更多好项目，别人没做过的项目，你要自己创造、或者自己去查找，如果这里列出来，可能就有很多人一样做了，所以先学会模仿项目，再学会创造项目、做更深入的项目</p>
</li>
<li><p>重点多说一句：并非就一定要做C++项目，你做Go、Java项目一样很不错嘛，前提是项目要好，之前流行过一阵Go的RPC框架，也很好！</p>
<ul>
<li>下面列出的，只是一部分例子，更多项目，请关注我的视频～</li>
</ul>
</li>
<li><p>重复相似的项目</p>
<ul>
<li>商城系统、博客系统、图书管理系统、各种XX应用层系统</li>
<li>WebServer、简单的课程设计</li>
</ul>
</li>
</ul>
</li>
<li><p>实现STL</p>
<ul>
<li><p>基于C++实现一个迷你STL</p>
<ul>
<li><a class="link" href="https://github.com/Alinshans/MyTinySTL">https://github.com/Alinshans/MyTinySTL <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>实现标准库部分容器和算法，对标准库进行扩充</p>
<ul>
<li><a class="link" href="https://github.com/senlinzhan/mystl">https://github.com/senlinzhan/mystl <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
</li>
<li><p>实现WebServer</p>
<ul>
<li><p>Linux C++ WebServer</p>
<ul>
<li><a class="link" href="https://github.com/qinguoyi/TinyWebServer">https://github.com/qinguoyi/TinyWebServer <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>（不适合写进项目）非常简单的http服务器</p>
<ul>
<li><a class="link" href="https://github.com/dxscjx123/tinyserver">https://github.com/dxscjx123/tinyserver <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
</li>
<li><p>实现网络框架</p>
<ul>
<li><p>基于IO多路复用和线程池的C++网络库</p>
<ul>
<li><a class="link" href="https://github.com/GeniusDai/kingpin">https://github.com/GeniusDai/kingpin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>轻量级网络框架，线程池技术，C++11</p>
<ul>
<li><a class="link" href="https://github.com/ZLMediaKit/ZLToolKit">https://github.com/ZLMediaKit/ZLToolKit <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>Linux C++高性能TCP服务框架，基于Reactor模式，支持单线程、多线程Reactor，也支持UDP服务</p>
<ul>
<li><a class="link" href="https://github.com/LeechanX/Easy-Reactor">https://github.com/LeechanX/Easy-Reactor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li><p>libco（建议直接阅读源码，不用写进项目）</p>
<ul>
<li><p><a class="link" href="https://github.com/Tencent/libco">https://github.com/Tencent/libco <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>文章</p>
<ul>
<li><p>漫谈微信libco协程设计及实现（万字长文）</p>
<ul>
<li><a class="link" href="https://runzhiwang.github.io/2019/06/21/libco/">https://runzhiwang.github.io/2019/06/21/libco/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>腾讯开源的 libco 号称千万级协程支持，那个共享栈模式原理是什么?</p>
<ul>
<li><a class="link" href="https://www.zhihu.com/question/52193579">https://www.zhihu.com/question/52193579 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库</p>
<ul>
<li><p>利用c&#x2F;c++ 开发基于B+树的小型关系型数据库</p>
<ul>
<li><a class="link" href="https://github.com/enpeizhao/duck_db">https://github.com/enpeizhao/duck_db <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="C-x2F-C-丝绸之路（完全可以跳过，有时间再看，面试的时候大概率不会对校招生问到这么细的）"><a href="#C-x2F-C-丝绸之路（完全可以跳过，有时间再看，面试的时候大概率不会对校招生问到这么细的）" class="headerlink" title="C &#x2F; C++ 丝绸之路（完全可以跳过，有时间再看，面试的时候大概率不会对校招生问到这么细的）"></a>C &#x2F; C++ 丝绸之路（完全可以跳过，有时间再看，面试的时候大概率不会对校招生问到这么细的）</h3><ul>
<li>《C和指针》</li>
<li>《C专家编程》</li>
<li>《C陷阱与缺陷》</li>
<li>《C++ 沉思录》</li>
</ul>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><ul>
<li><p>《数据密集型应用系统设计》</p>
<ul>
<li><a class="link" href="https://github.com/Vonng/ddia">https://github.com/Vonng/ddia <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>《大话设计模式》</p>
</li>
<li><p>《代码整洁之道》</p>
</li>
<li><p>《重构》</p>
</li>
<li><p>《深入理解Nginx》</p>
</li>
</ul>
<h3 id="Unix高级（难度比较大）"><a href="#Unix高级（难度比较大）" class="headerlink" title="Unix高级（难度比较大）"></a>Unix高级（难度比较大）</h3><ul>
<li>《Unix网络编程》</li>
<li>《Unix环境高级编程》</li>
<li>《Linux多线程服务端编程 使用muduo C++网络库》</li>
</ul>
<h3 id="国外优秀网课（有一定难度）"><a href="#国外优秀网课（有一定难度）" class="headerlink" title="国外优秀网课（有一定难度）"></a>国外优秀网课（有一定难度）</h3><ul>
<li><p>《MIT 6.S081: Operating System Engineering》</p>
<ul>
<li><a class="link" href="https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/">https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>《CS162: Operating System》</p>
<ul>
<li><a class="link" href="https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CS162/">https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CS162/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>《CMU 15-418&#x2F;Stanford CS149: Parallel Computing》</p>
<ul>
<li><a class="link" href="https://csdiy.wiki/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/CS149/">https://csdiy.wiki/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/CS149/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>《MIT6.824: Distributed System》</p>
<ul>
<li><a class="link" href="https://csdiy.wiki/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MIT6.824/">https://csdiy.wiki/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MIT6.824/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Sharing</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>就业</tag>
      </tags>
  </entry>
  <entry>
    <title>C++类static成员</title>
    <url>/2023/09/07/C++%E7%B1%BBstatic%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<p>static成员的使用还是比较频繁的, 网上对相关语法的介绍也比较详细, 本文主要讲一下自己写代码的时候遇到的小坑.</p>
<h2 id="static成员概述"><a href="#static成员概述" class="headerlink" title="static成员概述"></a>static成员概述</h2><p>在我看来, static成员属于某个类, 但不属于该类具体的对象. 由此引申出static成员的其他几个特点:</p>
<ul>
<li>不管创建多少个对象, static成员都仅有一份; static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问.</li>
<li>static成员函数只能调用static成员, 不能调用非static成员. (因为非static成员是属于具体对象的, 而static成员函数不具有<code>this</code>指针)</li>
<li>不能把static成员的初始化放在定义中, 或者说是<strong>必须要在定义外重新初始化</strong>. static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配. 反过来说，没有在类外初始化的 static 成员变量不能使用.</li>
</ul>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>我遇到的坑就是上面的最后一个点, 在使用单例模式时, 我在目标类中声明了一些静态成员, 并在单例模式构造实例时(调用static函数)对这些static成员进行初始化, 这也是不行的!! static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。因此, 对最后static成员最后一点进行补充: <strong>静态成员变量必须初始化，而且只能在类体外进行。</strong></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编程规范（参考Google、华为）</title>
    <url>/2023/05/28/C++%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%EF%BC%88%E5%8F%82%E8%80%83Google%E3%80%81%E5%8D%8E%E4%B8%BA%EF%BC%89/</url>
    <content><![CDATA[<h2 id="文件名及版权信息"><a href="#文件名及版权信息" class="headerlink" title="文件名及版权信息"></a>文件名及版权信息</h2><h3 id="1、文件名"><a href="#1、文件名" class="headerlink" title="1、文件名"></a>1、文件名</h3><p>C++文件名全部都是小写，且单词之间用<code>_</code>分割，如：<code>verilog_parse.cpp</code></p>
<h3 id="2、版权信息"><a href="#2、版权信息" class="headerlink" title="2、版权信息"></a>2、版权信息</h3><h2 id="所有文件均需要统一格式的版权信息"><a href="#所有文件均需要统一格式的版权信息" class="headerlink" title="所有文件均需要统一格式的版权信息"></a>所有文件均需要统一格式的版权信息</h2><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a><a class="link" href="https://so.csdn.net/so/search?q=%E5%A4%B4%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">头文件 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h2><h3 id="1、在-h中使用-define来防止头文件被多重包含，并在最后注释出宏的名字"><a href="#1、在-h中使用-define来防止头文件被多重包含，并在最后注释出宏的名字" class="headerlink" title="1、在.h中使用#define来防止头文件被多重包含，并在最后注释出宏的名字"></a>1、在<code>.h</code>中使用<code>#define</code>来防止头文件被多重包含，并在最后注释出宏的名字</h3><p>命名格式：<code>&lt;PROJECT&gt;_&lt;FILE&gt;_H_</code></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TIMER_FLOW_H_#<span class="keyword">define</span> TIMER_FLOW_H_...#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="2、尽量避免使用前置声明，优先使用-include来包含相关头文件"><a href="#2、尽量避免使用前置声明，优先使用-include来包含相关头文件" class="headerlink" title="2、尽量避免使用前置声明，优先使用#include来包含相关头文件"></a>2、尽量避免使用前置声明，优先使用<code>#include</code>来包含相关头文件</h3><p>包含头文件：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br></pre></td></tr></table></figure></div>

<p>前置声明：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="3、-include的包含顺序"><a href="#3、-include的包含顺序" class="headerlink" title="3、#include的包含顺序"></a>3、<code>#include</code>的包含顺序</h3><p>头文件的包含顺序为：当前<code>.cpp</code>文件直接关联的头文件、C库文件、C++库文件、其他项目的头文件、本项目中的其他头文件。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span>#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>#<span class="keyword">include</span> <span class="string">&quot;verilog.h&quot;</span>#<span class="keyword">include</span> <span class="string">&quot;node.h&quot;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="4、头文件应向稳定的方向包含"><a href="#4、头文件应向稳定的方向包含" class="headerlink" title="4、头文件应向稳定的方向包含"></a>4、头文件应向稳定的方向包含</h3><p>头文件的包含关系是一种依赖，一般来说，有以下几种包含原则。</p>
<h2 id="应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块禁止头文件循环依赖，指a-h包含b-h，b-h包含c-h，c-h包含a-h。禁止包含用不到的头文件。头文件应当自包含，指任意一个头文件均可独立编译。"><a href="#应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块禁止头文件循环依赖，指a-h包含b-h，b-h包含c-h，c-h包含a-h。禁止包含用不到的头文件。头文件应当自包含，指任意一个头文件均可独立编译。" class="headerlink" title="应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块禁止头文件循环依赖，指a.h包含b.h，b.h包含c.h，c.h包含a.h。禁止包含用不到的头文件。头文件应当自包含，指任意一个头文件均可独立编译。"></a>应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块<br>禁止头文件循环依赖，指a.h包含b.h，b.h包含c.h，c.h包含a.h。<br>禁止包含用不到的头文件。<br>头文件应当自包含，指任意一个头文件均可独立编译。</h2><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="1、在命名空间的最后注释出命名空间的名字"><a href="#1、在命名空间的最后注释出命名空间的名字" class="headerlink" title="1、在命名空间的最后注释出命名空间的名字"></a>1、在命名空间的最后注释出命名空间的名字</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mynamespace&#123;...&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2、避免使用using引入整个命名空间的标识符号"><a href="#2、避免使用using引入整个命名空间的标识符号" class="headerlink" title="2、避免使用using引入整个命名空间的标识符号"></a>2、避免使用<code>using</code>引入整个命名空间的标识符号</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> mynamespace;</span><br></pre></td></tr></table></figure></div>

<h3 id="3、避免进行大量构造及析构操作"><a href="#3、避免进行大量构造及析构操作" class="headerlink" title="3、避免进行大量构造及析构操作"></a>3、避免进行大量构造及析构操作</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  Timer t;  t.<span class="built_in">DoSomething</span>(i);&#125;</span><br></pre></td></tr></table></figure></div>

<p>建议使用以下代码：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Timer t;<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;  t.<span class="built_in">DoSomething</span>(i);&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4、尽量在变量声明时进行初始化，且避免进行无效的初始化"><a href="#4、尽量在变量声明时进行初始化，且避免进行无效的初始化" class="headerlink" title="4、尽量在变量声明时进行初始化，且避免进行无效的初始化"></a>4、尽量在变量声明时进行初始化，且避免进行无效的初始化</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i;i = <span class="built_in">f</span>();<span class="type">int</span> j = <span class="built_in">g</span>();<span class="type">int</span> k = <span class="number">0</span>;k = <span class="number">0xff</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="5、尽量避免全局函数和全局变量，使用命名空间或static关键字等进行作用域限制"><a href="#5、尽量避免全局函数和全局变量，使用命名空间或static关键字等进行作用域限制" class="headerlink" title="5、尽量避免全局函数和全局变量，使用命名空间或static关键字等进行作用域限制"></a>5、尽量避免全局函数和全局变量，使用命名空间或<code>static</code>关键字等进行作用域限制</h3><h3 id="6、禁止定义静态储存周期非POD变量"><a href="#6、禁止定义静态储存周期非POD变量" class="headerlink" title="6、禁止定义静态储存周期非POD变量"></a>6、禁止定义静态储存周期非POD变量</h3><p>静态存储周期变量，即包括了全局变量、静态变量、静态类成员变量和函数静态变量，都必须是原生数据类型（POD：Plain Old Data）：即<code>int</code>、<code>char</code>和<code>float</code>，以及POD类型的指针、数组和结构体。</p>
<h2 id="禁止使用类的静态存储周期变量，即禁用vector和string等：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的bug。不过constexpr变量除外，因为它不涉及动态初始化和析构"><a href="#禁止使用类的静态存储周期变量，即禁用vector和string等：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的bug。不过constexpr变量除外，因为它不涉及动态初始化和析构" class="headerlink" title="禁止使用类的静态存储周期变量，即禁用vector和string等：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的bug。不过constexpr变量除外，因为它不涉及动态初始化和析构"></a>禁止使用类的静态存储周期变量，即禁用<code>vector</code>和<code>string</code>等：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的bug。不过<code>constexpr</code>变量除外，因为它不涉及动态初始化和析构</h2><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="1、不要在构造函数和析构函数中调用虚函数"><a href="#1、不要在构造函数和析构函数中调用虚函数" class="headerlink" title="1、不要在构造函数和析构函数中调用虚函数"></a>1、不要在构造函数和析构函数中调用虚函数</h3><p>如果在派生类的构造函数和析构函数中调用了虚函数，这类调用不会重定向到派生类的虚函数实现。</p>
<h3 id="2、不要在无法报出错误时进行可能失败的初始化"><a href="#2、不要在无法报出错误时进行可能失败的初始化" class="headerlink" title="2、不要在无法报出错误时进行可能失败的初始化"></a>2、不要在无法报出错误时进行可能失败的初始化</h3><p>如果代码允许，直接终止程序是一个合适的处理错误方式。否则，可以考虑用<code>Init()</code>方法或工厂函数。</p>
<h3 id="3、建议使用初始化列表构造对象，且和构造函数、析构函数一样放在类外实现"><a href="#3、建议使用初始化列表构造对象，且和构造函数、析构函数一样放在类外实现" class="headerlink" title="3、建议使用初始化列表构造对象，且和构造函数、析构函数一样放在类外实现"></a>3、建议使用初始化列表构造对象，且和构造函数、析构函数一样放在类外实现</h3><p>使用初始化列表构造对象，比起构造函数的代码块初始化效率更高、性能更好。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="keyword">public</span>:  <span class="built_in">A</span>() : &#123;&#125;;<span class="keyword">private</span>:  <span class="type">int</span> m_a;  B* m_b;&#125;;A::<span class="built_in">A</span>() ： <span class="built_in">m_a</span>(<span class="number">0</span>), <span class="built_in">m_b</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4、不要定义隐式转换类型"><a href="#4、不要定义隐式转换类型" class="headerlink" title="4、不要定义隐式转换类型"></a>4、不要定义隐式转换类型</h3><p>对于转换运算符和单参数构造函数，建议使用<code>explicit</code>关键字。<br>举例如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Things</span>&#123;<span class="keyword">public</span>:  <span class="function"><span class="keyword">explicit</span> <span class="title">Things</span><span class="params">(<span class="type">const</span> std::string &amp;name = <span class="string">&quot;&quot;</span>)</span> :    m_name(name), m_height(<span class="number">0</span>), m_weight(<span class="number">0</span>) &#123;</span> &#125;  <span class="function"><span class="type">int</span> <span class="title">CompareTo</span><span class="params">(<span class="type">const</span> Things &amp;other)</span></span>;<span class="keyword">private</span>:  std::string m_name;  <span class="type">int</span> m_height;  <span class="type">int</span> m_weight;&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这里的构造函数用<code>explicit</code>关键字来防止隐式类型转换。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">Things a;std::string s = <span class="string">&quot;book&quot;</span>;<span class="type">int</span> ret = a.<span class="built_in">CompareTo</span>(s);<span class="type">int</span> ret = a.<span class="built_in">CompareTo</span>(<span class="built_in">Things</span>(s));</span><br></pre></td></tr></table></figure></div>

<h3 id="5、拷贝构造函数和拷贝赋值运算符，移动构造函数和移动赋值运算符成套使用，如果不需要，则将它们显式地禁用"><a href="#5、拷贝构造函数和拷贝赋值运算符，移动构造函数和移动赋值运算符成套使用，如果不需要，则将它们显式地禁用" class="headerlink" title="5、拷贝构造函数和拷贝赋值运算符，移动构造函数和移动赋值运算符成套使用，如果不需要，则将它们显式地禁用"></a>5、拷贝构造函数和拷贝赋值运算符，移动构造函数和移动赋值运算符成套使用，如果不需要，则将它们显式地禁用</h3><p>如果类型可拷贝，则需要同时给出拷贝构造函数和拷贝赋值运算符的定义。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>(<span class="type">const</span> MyClass &amp;t)&#123;  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;t) <span class="keyword">return</span>;  <span class="keyword">if</span> (t.text == <span class="literal">nullptr</span>) <span class="keyword">return</span>;  <span class="type">int</span> len = <span class="built_in">strlen</span>(t.text);  text = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];  <span class="built_in">strcpy</span>(text, t.text);&#125;MyClass &amp;<span class="keyword">operator</span> = (<span class="type">const</span> MyClass &amp;t)&#123;  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;t) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="keyword">if</span> (text != <span class="literal">nullptr</span>) &#123;    <span class="built_in">free</span>(text);    text = <span class="literal">nullptr</span>;  &#125;  <span class="keyword">if</span> (t.text == <span class="literal">nullptr</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="type">int</span> len = <span class="built_in">strlen</span>(t.text);  <span class="built_in">free</span>(text);  text = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];  <span class="built_in">strcpy</span>(text, t.text);  <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br></pre></td></tr></table></figure></div>

<p>同理，如果类型可移动，则需要同时给出移动构造函数和移动赋值运算符的定义。</p>
<p>由于存在对象切割的风险，不要为任何有可能有派生类的对象提供赋值操作或者拷贝 &#x2F; 移动构造函数（当然也不要继承有这样的成员函数的类）。如果你的基类需要可复制属性，请提供一个<code>public virtual Clone()</code>和一个<code>protected</code>的拷贝构造函数以供派生类实现。</p>
<p>如果你的类不需要拷贝 &#x2F; 移动操作，请显式地通过在<code>public</code>域中使用<code>= delete</code>或<code>DISALLOW_COPY_AND_ASSIGN</code>禁用之。<br>方法一：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;<span class="keyword">public</span>:  <span class="built_in">MyClass</span>(<span class="type">char</span> *text);  ~<span class="built_in">MyClass</span>();  <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass &amp;) = <span class="keyword">delete</span>;  MyClass &amp;<span class="keyword">operator</span> = (<span class="type">const</span> MyClass &amp;) = <span class="keyword">delete</span>;<span class="keyword">private</span>:  <span class="type">char</span> *m_text;&#125;</span><br></pre></td></tr></table></figure></div>

<p>方法二：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISALLOW_COPY_AND_ASSIGN(MyClass) \  MyClass(const MyClass &amp;); \  MyClass &amp;operator = (const MyClass &amp;)class MyClass&#123;public:  MyClass(char *text);  ~MyClass();private:  DISALLOW_COPY_AND_ASSIGN(MyClass);  char *m_text;&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="6、仅当只有数据成员时使用struct，其它一概使用class"><a href="#6、仅当只有数据成员时使用struct，其它一概使用class" class="headerlink" title="6、仅当只有数据成员时使用struct，其它一概使用class"></a>6、仅当只有数据成员时使用<code>struct</code>，其它一概使用<code>class</code></h3><h3 id="7、优先考虑使用组合，其次是继承"><a href="#7、优先考虑使用组合，其次是继承" class="headerlink" title="7、优先考虑使用组合，其次是继承"></a>7、优先考虑使用组合，其次是继承</h3><p>不要过度使用继承，组合常常更合适一些。尽量做到只在“是一个”，而非“有一个”的情况下使用继承。</p>
<h3 id="8、仅使用public继承"><a href="#8、仅使用public继承" class="headerlink" title="8、仅使用public继承"></a>8、仅使用<code>public</code>继承</h3><p>所有继承必须是<code>public</code>的，如果想使用私有继承，则应该替换成把基类的实例作为成员对象的方式。</p>
<h3 id="9、如果类有虚函数，则析构函数也应该为虚函数"><a href="#9、如果类有虚函数，则析构函数也应该为虚函数" class="headerlink" title="9、如果类有虚函数，则析构函数也应该为虚函数"></a>9、如果类有虚函数，则析构函数也应该为虚函数</h3><p>在声明重载时，请使用<code>override</code>、<code>final</code>或<code>virtual</code>的其中之一进行标记。</p>
<h3 id="10、尽量不要重载运算符，也不要创建用户定义字面量"><a href="#10、尽量不要重载运算符，也不要创建用户定义字面量" class="headerlink" title="10、尽量不要重载运算符，也不要创建用户定义字面量"></a>10、尽量不要重载运算符，也不要创建用户定义字面量</h3><p>但不要为了避免重载操作符而走极端。比如，应当定义<code>==</code>、<code>=</code>和<code>&lt;&lt;</code>，而不是<code>Equals()</code>、<code>CopyFrom()</code>和<code>PrintTo()</code>。</p>
<h3 id="11、将所有数据成员声明为private，除非是static-const类型成员"><a href="#11、将所有数据成员声明为private，除非是static-const类型成员" class="headerlink" title="11、将所有数据成员声明为private，除非是static const类型成员"></a>11、将所有数据成员声明为<code>private</code>，除非是<code>static const</code>类型成员</h3><p>这么做的原因是要求对数据成员进行存取控制。</p>
<h3 id="12、将相似的声明放在一起，将public部分放在最前"><a href="#12、将相似的声明放在一起，将public部分放在最前" class="headerlink" title="12、将相似的声明放在一起，将public部分放在最前"></a>12、将相似的声明放在一起，将<code>public</code>部分放在最前</h3><h2 id="类定义一般应以public-开始，后跟protected-，最后是private-在各个部分中，建议将类似的声明放在一起，并且建议以如下的顺序：类型（包括typedef、using和嵌套的结构体与类）、变量、工厂函数、构造函数、赋值运算符、析构函数、其他函数、数据成员。"><a href="#类定义一般应以public-开始，后跟protected-，最后是private-在各个部分中，建议将类似的声明放在一起，并且建议以如下的顺序：类型（包括typedef、using和嵌套的结构体与类）、变量、工厂函数、构造函数、赋值运算符、析构函数、其他函数、数据成员。" class="headerlink" title="类定义一般应以public:开始，后跟protected:，最后是private:在各个部分中，建议将类似的声明放在一起，并且建议以如下的顺序：类型（包括typedef、using和嵌套的结构体与类）、变量、工厂函数、构造函数、赋值运算符、析构函数、其他函数、数据成员。"></a>类定义一般应以<code>public:</code>开始，后跟<code>protected:</code>，最后是<code>private:</code><br>在各个部分中，建议将类似的声明放在一起，并且建议以如下的顺序：类型（包括<code>typedef</code>、<code>using</code>和嵌套的结构体与类）、变量、工厂函数、构造函数、赋值运算符、析构函数、其他函数、数据成员。</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="1、编写简短、凝练、功能单一的函数，尽量不要写超过-100-行的函数"><a href="#1、编写简短、凝练、功能单一的函数，尽量不要写超过-100-行的函数" class="headerlink" title="1、编写简短、凝练、功能单一的函数，尽量不要写超过 100 行的函数"></a>1、编写简短、凝练、功能单一的函数，尽量不要写超过 100 行的函数</h3><p>如果函数超过 100 行，可以考虑在不影响程序结构的前提下对其进行分割。</p>
<h3 id="2、不同函数中的重复代码应该尽可能提炼成单一的函数"><a href="#2、不同函数中的重复代码应该尽可能提炼成单一的函数" class="headerlink" title="2、不同函数中的重复代码应该尽可能提炼成单一的函数"></a>2、不同函数中的重复代码应该尽可能提炼成单一的函数</h3><h3 id="3、避免函数的代码嵌套过深，尽量低于-5-层"><a href="#3、避免函数的代码嵌套过深，尽量低于-5-层" class="headerlink" title="3、避免函数的代码嵌套过深，尽量低于 5 层"></a>3、避免函数的代码嵌套过深，尽量低于 5 层</h3><p>嵌套深度，指函数中的代码控制块（如<code>if</code>、<code>for</code>、<code>while</code>、<code>switch</code>等）之间互相包含的深度。嵌套过深将导致代码的阅读成本增加。</p>
<h3 id="4、函数的参数应该尽量不超过-5-个"><a href="#4、函数的参数应该尽量不超过-5-个" class="headerlink" title="4、函数的参数应该尽量不超过 5 个"></a>4、函数的参数应该尽量不超过 5 个</h3><h3 id="5、废弃代码应及时清理"><a href="#5、废弃代码应及时清理" class="headerlink" title="5、废弃代码应及时清理"></a>5、废弃代码应及时清理</h3><p>可以使用注释括起现在暂未使用而将来可能使用的代码，但废弃代码更应当被清除。</p>
<h3 id="6、将所有输入参数放在所有输出参数之前"><a href="#6、将所有输入参数放在所有输出参数之前" class="headerlink" title="6、将所有输入参数放在所有输出参数之前"></a>6、将所有输入参数放在所有输出参数之前</h3><p>需要注意的是，在加入新参数时不要因为它们是新参数就置于参数列表最后，而是仍然要按照该规则，即将新的输入参数也置于输出参数之前。</p>
<h3 id="7、所有按引用传递的参数必须加上const"><a href="#7、所有按引用传递的参数必须加上const" class="headerlink" title="7、所有按引用传递的参数必须加上const"></a>7、所有按引用传递的参数必须加上const</h3><p>函数参数列表中，所有引用参数都必须是<code>const</code>。如果一个参数有被改变的可能，则建议使用指针。</p>
<h3 id="8、尽量使用const对声明的变量或参数进行限制"><a href="#8、尽量使用const对声明的变量或参数进行限制" class="headerlink" title="8、尽量使用const对声明的变量或参数进行限制"></a>8、尽量使用<code>const</code>对声明的变量或参数进行限制</h3><p>尽量使用<code>const</code>，将会提升代码的健壮性。</p>
<p>在类的<code>set</code>方法中，当输入参数为简单类型，则不需要添加const；当输入参数为容器时，使用<code>const &amp;</code>可提高性能。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_float</span><span class="params">(<span class="type">float</span> var)</span></span>;<span class="function"><span class="type">void</span> <span class="title">set_string</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;<span class="function"><span class="type">void</span> <span class="title">set_things</span><span class="params">(<span class="type">const</span> std::vector&lt;std::string&gt; &amp;vec)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>在类的<code>get</code>方法中，其后加<code>const</code>表明该函数为只读函数；当输出参数为容器时，使用<code>const &amp;</code>可提高性能，且此时返回值不可被修改。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">get_float</span><span class="params">()</span> <span class="type">const</span></span>;<span class="function"><span class="type">const</span> std::vector&lt;std::string&gt; &amp;<span class="title">get_things</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="9、只允许在非虚函数中使用缺省参数，且必须保证缺省参数的值始终一致"><a href="#9、只允许在非虚函数中使用缺省参数，且必须保证缺省参数的值始终一致" class="headerlink" title="9、只允许在非虚函数中使用缺省参数，且必须保证缺省参数的值始终一致"></a>9、只允许在非虚函数中使用缺省参数，且必须保证缺省参数的值始终一致</h3><p>对于虚函数，不允许使用缺省参数，因为在虚函数中缺省参数不一定能正常工作。如果在每个调用点缺省参数的值都有可能不同，在这种情况下缺省参数也不允许使用。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">int</span> n = counter++)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="10、避免野指针的产生"><a href="#10、避免野指针的产生" class="headerlink" title="10、避免野指针的产生"></a>10、避免野指针的产生</h3><p>指针变量在声明时，就应该进行初始化赋值（<code>nullptr</code>或准确的地址，不建议使用<code>NULL</code>）。<br>指针在释放后，且生命周期暂未终结时，需要置空（<code>nullptr</code>，不建议使用<code>NULL</code>）。</p>
<h3 id="11、建议使用auto绕过繁琐的类型名，且仅在局部变量使用"><a href="#11、建议使用auto绕过繁琐的类型名，且仅在局部变量使用" class="headerlink" title="11、建议使用auto绕过繁琐的类型名，且仅在局部变量使用"></a>11、建议使用<code>auto</code>绕过繁琐的类型名，且仅在局部变量使用</h3><h3 id="12、内联函数应该尽量短"><a href="#12、内联函数应该尽量短" class="headerlink" title="12、内联函数应该尽量短"></a>12、内联函数应该尽量短</h3><h2 id="关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用内联函数应该尽可能短，原则上不允许超过-10-行的内联函数。"><a href="#关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用内联函数应该尽可能短，原则上不允许超过-10-行的内联函数。" class="headerlink" title="关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用内联函数应该尽可能短，原则上不允许超过 10 行的内联函数。"></a>关键字<code>inline</code>必须与函数定义放在一起才能使函数成为内联函数，仅仅将<code>inline</code>放在函数声明前面不起任何作用<br>内联函数应该尽可能短，原则上不允许超过 10 行的内联函数。</h2><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>在了解命名规则前，首先需要了解几种命名法。</p>
<p><strong>小驼峰命名法</strong><br>命名的第一个单词以小写字母开始，第二个单词开始以后的每个单词的首字母都采用大写字母。且单词之间无下划线连接，如<code>firstName</code>、<code>lastName</code>。这样的命名看上去就像骆驼峰一样此起彼伏，故得名。</p>
<p><strong>大驼峰命名法</strong><br>又名“帕斯卡命名法”，与小驼峰命名法类似，但每个单词的首字母均大写。如<code>FirstName</code>、<code>LastName</code>。</p>
<p><strong>匈牙利命名法</strong><br>基本结构是：属性 + 类型 + 具体描述。如<code>uiNum</code>、<code>pTimer</code>、<code>strName</code>、<code>g_pSource</code>。<br>属性部分：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">g_ 全局变量</span><br><span class="line">c_ 常量</span><br><span class="line">m_ 类成员变量</span><br><span class="line">s_ 静态变量</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>类型部分：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">c char</span><br><span class="line">b bool</span><br><span class="line">i/n int</span><br><span class="line">u unsigned</span><br><span class="line">f float/file</span><br><span class="line">d double</span><br><span class="line">l long</span><br><span class="line">h handle</span><br><span class="line">fn 函数</span><br><span class="line">p 指针</span><br><span class="line">str string</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>下划线命名法</strong><br>命名的每个单词用下划线隔开，且每个单词均小写。如<code>first_name</code>、<code>last_name</code>。</p>
<h3 id="1、尽可能使用描述性的命名，不要使用含糊不清的缩写"><a href="#1、尽可能使用描述性的命名，不要使用含糊不清的缩写" class="headerlink" title="1、尽可能使用描述性的命名，不要使用含糊不清的缩写"></a>1、尽可能使用描述性的命名，不要使用含糊不清的缩写</h3><h3 id="2、所有类型名称使用大驼峰命名法"><a href="#2、所有类型名称使用大驼峰命名法" class="headerlink" title="2、所有类型名称使用大驼峰命名法"></a>2、所有类型名称使用大驼峰命名法</h3><p>所有类型包括：类、结构体、类型定义（typedef）、枚举、类型模板参数。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UrlTable</span>&#123; ...<span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span>&#123; ...<span class="keyword">typedef</span> hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;<span class="keyword">using</span> PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;<span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span>&#123; ...</span><br></pre></td></tr></table></figure></div>

<h3 id="3、变量使用下划线命名法，且类的成员变量以m-开头"><a href="#3、变量使用下划线命名法，且类的成员变量以m-开头" class="headerlink" title="3、变量使用下划线命名法，且类的成员变量以m_开头"></a>3、变量使用下划线命名法，且类的成员变量以<code>m_</code>开头</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">string table_name;<span class="keyword">class</span> <span class="title class_">TableInfo</span>&#123;  ...<span class="keyword">private</span>:  string m_table_name;&#125;;<span class="keyword">struct</span> <span class="title class_">UrlTableProperties</span>&#123;  string table_name;&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="4、常量使用小驼峰命名法，且以k开头"><a href="#4、常量使用小驼峰命名法，且以k开头" class="headerlink" title="4、常量使用小驼峰命名法，且以k开头"></a>4、常量使用小驼峰命名法，且以<code>k</code>开头</h3><p>常量，即声明为<code>constexpr</code>或<code>const</code>的变量。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="5、函数使用大驼峰命名法或下划线命名法"><a href="#5、函数使用大驼峰命名法或下划线命名法" class="headerlink" title="5、函数使用大驼峰命名法或下划线命名法"></a>5、函数使用大驼峰命名法或下划线命名法</h3><p>一般来说，相对于一个功能模块而言，模块外有可能会调用到的函数（即对外API），命名应该使用大驼峰命名法。而模块内部调用的函数，命名应该使用下划线命名法。</p>
<h3 id="6、命名空间使用下划线命名法"><a href="#6、命名空间使用下划线命名法" class="headerlink" title="6、命名空间使用下划线命名法"></a>6、命名空间使用下划线命名法</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> gbtimer_verilog&#123; ...</span><br></pre></td></tr></table></figure></div>

<h3 id="7、宏的命名使用全大写，并且可以使用下划线"><a href="#7、宏的命名使用全大写，并且可以使用下划线" class="headerlink" title="7、宏的命名使用全大写，并且可以使用下划线"></a>7、宏的命名使用全大写，并且可以使用下划线</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI_ROUNDED 3.0</span></span><br></pre></td></tr></table></figure></div>

<h3 id="8、枚举的命名应当和常量或宏一致，且枚举的第一个值应当为默认值或无效值"><a href="#8、枚举的命名应当和常量或宏一致，且枚举的第一个值应当为默认值或无效值" class="headerlink" title="8、枚举的命名应当和常量或宏一致，且枚举的第一个值应当为默认值或无效值"></a>8、枚举的命名应当和常量或宏一致，且枚举的第一个值应当为默认值或无效值</h3><p>具体使用哪种，视项目内已有代码而定。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">UrlTableErrors</span>&#123;    kOK = <span class="number">0</span>,    kErrorOutOfMemory,    kErrorMalformedInput,&#125;;<span class="keyword">enum</span> <span class="title class_">AlternateUrlTableErrors</span>&#123;    OK = <span class="number">0</span>,    OUT_OF_MEMORY = <span class="number">1</span>,    MALFORMED_INPUT = <span class="number">2</span>,&#125;;</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="1、函数声明处的注释描述函数功能，定义处的注释描述函数实现"><a href="#1、函数声明处的注释描述函数功能，定义处的注释描述函数实现" class="headerlink" title="1、函数声明处的注释描述函数功能，定义处的注释描述函数实现"></a>1、函数声明处的注释描述函数功能，定义处的注释描述函数实现</h3><p>但同时也要避免对显而易见的内容进行注释</p>
<h3 id="2、对那些临时的、短期的解决方案，或需要补充的代码使用TODO注释"><a href="#2、对那些临时的、短期的解决方案，或需要补充的代码使用TODO注释" class="headerlink" title="2、对那些临时的、短期的解决方案，或需要补充的代码使用TODO注释"></a>2、对那些临时的、短期的解决方案，或需要补充的代码使用<code>TODO</code>注释</h3><hr>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>每个人都可能有自己的代码风格和格式，但如果一个项目中的所有人都遵循同一风格的话，这个项目就能更顺利地进行。每个人未必能同意下述的每一处格式规则，而且其中的不少规则需要一定时间的适应，但整个项目服从统一的编程风格是很重要的，只有这样才能让所有人轻松地阅读和理解代码。</p>
<h3 id="1、每一行代码字符数尽量不要超过-80"><a href="#1、每一行代码字符数尽量不要超过-80" class="headerlink" title="1、每一行代码字符数尽量不要超过 80"></a>1、每一行代码字符数尽量不要超过 80</h3><h3 id="2、避免产生超过-3000-行的超大文件"><a href="#2、避免产生超过-3000-行的超大文件" class="headerlink" title="2、避免产生超过 3000 行的超大文件"></a>2、避免产生超过 3000 行的超大文件</h3><h3 id="3、使用空格缩进，不要使用制表符，且每级缩进为-2-个空格"><a href="#3、使用空格缩进，不要使用制表符，且每级缩进为-2-个空格" class="headerlink" title="3、使用空格缩进，不要使用制表符，且每级缩进为 2 个空格"></a>3、使用空格缩进，不要使用制表符，且每级缩进为 2 个空格</h3><h3 id="4、相对独立的程序块之间建议添加空行"><a href="#4、相对独立的程序块之间建议添加空行" class="headerlink" title="4、相对独立的程序块之间建议添加空行"></a>4、相对独立的程序块之间建议添加空行</h3><h3 id="5、返回类型和函数名在同一行，参数也尽量放在同一行，如果放不下就对形参分行"><a href="#5、返回类型和函数名在同一行，参数也尽量放在同一行，如果放不下就对形参分行" class="headerlink" title="5、返回类型和函数名在同一行，参数也尽量放在同一行，如果放不下就对形参分行"></a>5、返回类型和函数名在同一行，参数也尽量放在同一行，如果放不下就对形参分行</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::ReallyLongFunctionName</span><span class="params">(Type par_name1,  Type par_name2, Type par_name3)</span></span>&#123;  <span class="built_in">DoSomething</span>();  ...&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ReturnType <span class="title">ClassName::ReallyLongFunctionName</span><span class="params">(Type par_name1,                                             Type par_name2,                                             Type par_name3)</span></span>&#123;  <span class="built_in">DoSomething</span>();  ...&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="6、if、for、do、while、switch、case、default等语句与-在同一行，而-独占一行"><a href="#6、if、for、do、while、switch、case、default等语句与-在同一行，而-独占一行" class="headerlink" title="6、if、for、do、while、switch、case、default等语句与{在同一行，而}独占一行"></a>6、<code>if</code>、<code>for</code>、<code>do</code>、<code>while</code>、<code>switch</code>、<code>case</code>、<code>default</code>等语句与<code>&#123;</code>在同一行，而<code>&#125;</code>独占一行</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  ...&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;  ...&#125; <span class="keyword">else</span> &#123;  ...&#125;<span class="keyword">if</span> (x == kFoo) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123;  <span class="keyword">case</span> <span class="number">0</span>: &#123;    ...    <span class="keyword">break</span>;  &#125;  <span class="keyword">case</span> <span class="number">1</span>: &#123;    ...    <span class="keyword">break</span>;  &#125;  <span class="keyword">default</span>: &#123;    ...  &#125;&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;&#125;<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;  ...&#125;<span class="type">int</span> i = <span class="number">0</span>;<span class="keyword">for</span> ( ; i &lt; kSomeNumber; ) &#123;  ...  ++i;&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="7、-gt-、-、指针-x2F-地址操作符-96-96-与-amp-前后不加空格"><a href="#7、-gt-、-、指针-x2F-地址操作符-96-96-与-amp-前后不加空格" class="headerlink" title="7、&gt;、.、指针&#x2F;地址操作符&#96;&#96;与&amp;前后不加空格"></a>7、<code>&gt;</code>、<code>.</code>、指针&#x2F;地址操作符&#96;&#96;与<code>&amp;</code>前后不加空格</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">x = *p;p = &amp;x;x = r.y;x = r-&gt;y;</span><br></pre></td></tr></table></figure></div>

<h3 id="8、在声明指针变量或参数时，建议-96-96-与-amp-紧挨变量名"><a href="#8、在声明指针变量或参数时，建议-96-96-与-amp-紧挨变量名" class="headerlink" title="8、在声明指针变量或参数时，建议&#96;&#96;与&amp;紧挨变量名"></a>8、在声明指针变量或参数时，建议&#96;&#96;与<code>&amp;</code>紧挨变量名</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *c;<span class="type">const</span> string &amp;str;<span class="type">char</span>* c;<span class="type">const</span> string&amp; str;</span><br></pre></td></tr></table></figure></div>

<h3 id="9、一个表达式换行时，操作符总位于行尾"><a href="#9、一个表达式换行时，操作符总位于行尾" class="headerlink" title="9、一个表达式换行时，操作符总位于行尾"></a>9、一个表达式换行时，操作符总位于行尾</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (this_one_thing &gt; this_other_thing &amp;&amp;    a_third_thing == a_fourth_thing &amp;&amp;    yet_another &amp;&amp; last_one) &#123;  ...&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="10、不要在return表达式里加上非必须的括号"><a href="#10、不要在return表达式里加上非必须的括号" class="headerlink" title="10、不要在return表达式里加上非必须的括号"></a>10、不要在<code>return</code>表达式里加上非必须的括号</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> result;<span class="keyword">return</span> (result);<span class="keyword">return</span> (some_long_condition &amp;&amp; another_condition);</span><br></pre></td></tr></table></figure></div>

<h3 id="11、预处理指令不要缩进，从行首开始"><a href="#11、预处理指令不要缩进，从行首开始" class="headerlink" title="11、预处理指令不要缩进，从行首开始"></a>11、预处理指令不要缩进，从行首开始</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lopsided_score) &#123;<span class="meta">#<span class="keyword">if</span> DISASTER_PENDING    DropEverything();#<span class="keyword">endif</span>    BackToNormal();  &#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="12、访问控制快的声明依次序是public-、protected-、private，且不进行缩进"><a href="#12、访问控制快的声明依次序是public-、protected-、private，且不进行缩进" class="headerlink" title="12、访问控制快的声明依次序是public:、protected:、private，且不进行缩进"></a>12、访问控制快的声明依次序是<code>public:</code>、<code>protected:</code>、<code>private</code>，且不进行缩进</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> OtherClass&#123;<span class="keyword">public</span>:  <span class="built_in">MyClass</span>();  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> var)</span></span>;  ~<span class="built_in">MyClass</span>() &#123;&#125;  <span class="function"><span class="type">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;  <span class="function"><span class="type">int</span> <span class="title">get_var</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_var; &#125;<span class="keyword">private</span>:  <span class="type">int</span> m_var;&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="13、命名空间、函数、类、结构体、联合体的-与-均另起一行，枚举视长短而定"><a href="#13、命名空间、函数、类、结构体、联合体的-与-均另起一行，枚举视长短而定" class="headerlink" title="13、命名空间、函数、类、结构体、联合体的{与}均另起一行，枚举视长短而定"></a>13、命名空间、函数、类、结构体、联合体的<code>&#123;</code>与<code>&#125;</code>均另起一行，枚举视长短而定</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">config_rule</span>&#123;  <span class="type">char</span> *name;  <span class="keyword">union</span>  &#123;    <span class="type">int</span> i;    <span class="type">double</span> d;  &#125;;&#125;;<span class="keyword">enum</span> <span class="title class_">config_type</span>&#123;  CONFIG_TYPE1,  CONFIG_TYPE2，  ...&#125;;<span class="keyword">enum</span> <span class="title class_">num_type</span> &#123; NUM_TYPE1, NUM_TYPE2 &#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="14、水平留白"><a href="#14、水平留白" class="headerlink" title="14、水平留白"></a>14、水平留白</h3><p>水平留白使用根据在代码中的位置决定，但永远不要在行尾添加没意义的留白。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x[] = &#123; <span class="number">0</span> &#125;;<span class="type">int</span> x[] = &#123;<span class="number">0</span>&#125;;x++;v = w * (x + z);x = a &gt; b ? a : b;vector&lt;string&gt; x;y = <span class="built_in">static_cast</span>&lt;<span class="type">char</span> *&gt;(x);<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="15、垂直留白"><a href="#15、垂直留白" class="headerlink" title="15、垂直留白"></a>15、垂直留白</h3><h2 id="基本原则是：同一屏可以显示的代码越多，越容易理解程序的控制流。当然，过于密集的代码块和过于疏松的代码块同样难看，这取决于你的判断。但通常是垂直留白越少越好，且函数体首尾不要留空行，不要有连续的空行"><a href="#基本原则是：同一屏可以显示的代码越多，越容易理解程序的控制流。当然，过于密集的代码块和过于疏松的代码块同样难看，这取决于你的判断。但通常是垂直留白越少越好，且函数体首尾不要留空行，不要有连续的空行" class="headerlink" title="基本原则是：同一屏可以显示的代码越多，越容易理解程序的控制流。当然，过于密集的代码块和过于疏松的代码块同样难看，这取决于你的判断。但通常是垂直留白越少越好，且函数体首尾不要留空行，不要有连续的空行"></a>基本原则是：同一屏可以显示的代码越多，越容易理解程序的控制流。当然，过于密集的代码块和过于疏松的代码块同样难看，这取决于你的判断。但通常是垂直留白越少越好，且函数体首尾不要留空行，不要有连续的空行</h2><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="1、程序编译时产生的所有warning都应该被修复"><a href="#1、程序编译时产生的所有warning都应该被修复" class="headerlink" title="1、程序编译时产生的所有warning都应该被修复"></a>1、程序编译时产生的所有<code>warning</code>都应该被修复</h3><p>特殊的，LEX与YACC产生的移进-归约冲突及归约-归约冲突视情况而定，但原则上所有告警都应该被修复。</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试准备</title>
    <url>/2023/08/22/C++%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p>参考<a class="link" href="https://github.com/tomstillcoding/cs-roadmap/blob/main/c%2B%2B/2022_%E6%9C%80%E6%96%B0C%2B%2B%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF_%E7%A7%91%E7%8F%AD%E7%89%88.md">github <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><h3 id="计算机基础知识复习"><a href="#计算机基础知识复习" class="headerlink" title="计算机基础知识复习"></a>计算机基础知识复习</h3><ul>
<li>将上面你学习过的内容，包含下面关键词的，都重新复习、做笔记一下</li>
<li>C、C++、数据库原理与设计、操作系统、计算机网络、Linux程序设计、Shell、MySQL、Redis</li>
</ul>
<h3 id="面试常考内容复习（所谓的八股文，我不是很喜欢这个称呼）"><a href="#面试常考内容复习（所谓的八股文，我不是很喜欢这个称呼）" class="headerlink" title="面试常考内容复习（所谓的八股文，我不是很喜欢这个称呼）"></a>面试常考内容复习（所谓的八股文，我不是很喜欢这个称呼）</h3><ul>
<li><p>注：一定要在学习了上面的第一步之后，再来做这里的计算机基础知识复习，这里的复习主要是针对面试会考的内容，高频内容，针对面试去复习，并不适合作为学习内容！</p>
</li>
<li><p>《CS-Notes》</p>
<ul>
<li><a class="link" href="http://www.cyc2018.xyz/">http://www.cyc2018.xyz/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
<h3 id="刷“面试算法”题"><a href="#刷“面试算法”题" class="headerlink" title="刷“面试算法”题"></a>刷“面试算法”题</h3><ul>
<li><p>推荐：codetop高频题</p>
<ul>
<li>codetop能够按照出题的频度去排序刷的题目，甚至能按照不同的企业、岗位去展示从高到低频度的题目，手动整理，童叟无欺！</li>
<li><a class="link" href="https://zhuanlan.zhihu.com/p/365332969">https://zhuanlan.zhihu.com/p/365332969 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link" href="https://codetop.cc/home">https://codetop.cc/home <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>《剑指Offer》</p>
<ul>
<li><a class="link" href="https://leetcode-cn.com/problem-list/xb9nqhhg/">https://leetcode-cn.com/problem-list/xb9nqhhg/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>《TOP面试题》</p>
<ul>
<li><a class="link" href="https://leetcode-cn.com/problem-list/2ckc81c/">https://leetcode-cn.com/problem-list/2ckc81c/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
<h3 id="数据结构与SQL题"><a href="#数据结构与SQL题" class="headerlink" title="数据结构与SQL题"></a>数据结构与SQL题</h3><ul>
<li><p>《SQL题库》</p>
<ul>
<li><a class="link" href="https://leetcode-cn.com/study-plan/sql/">https://leetcode-cn.com/study-plan/sql/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>《数据结构题库》</p>
<ul>
<li><a class="link" href="https://leetcode-cn.com/study-plan/data-structures/">https://leetcode-cn.com/study-plan/data-structures/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
<h3 id="场景题以及智力题（可以通过google去搜索解决问题，锻炼搜索能力-）"><a href="#场景题以及智力题（可以通过google去搜索解决问题，锻炼搜索能力-）" class="headerlink" title="场景题以及智力题（可以通过google去搜索解决问题，锻炼搜索能力~）"></a>场景题以及智力题（可以通过google去搜索解决问题，锻炼搜索能力~）</h3><ul>
<li><p>书籍</p>
<ul>
<li>《数据密集型应用系统设计》</li>
</ul>
</li>
<li><p>场景题资源</p>
<ul>
<li><p>面试系列 场景题与智力题收集</p>
<ul>
<li><a class="link" href="https://zhuanlan.zhihu.com/p/359538568">https://zhuanlan.zhihu.com/p/359538568 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>写一个面试中场景题的总结</p>
<ul>
<li><a class="link" href="https://blog.51cto.com/u_15076209/4244803">https://blog.51cto.com/u_15076209/4244803 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>后端场景题</p>
<ul>
<li><a class="link" href="https://blog.csdn.net/qq_37574623/article/details/117255234">https://blog.csdn.net/qq_37574623/article/details/117255234 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>面试场景题：如何设计一个排行榜？</p>
<ul>
<li><a class="link" href="https://www.1024sou.com/article/783326.html">https://www.1024sou.com/article/783326.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>其他问题</p>
<ul>
<li>假如有 10 亿个数，只有一个重复，内存只能放下 5 亿个数，怎么找到这个重复的数字？</li>
<li>如何设计一个秒杀系统（服务端、数据库、分布式）？分布式系统的设计？</li>
<li>有一个服务器专门接收大量请求，怎么设计？</li>
<li>如果让你自己设计 RPC 框架你会如何设计？</li>
<li>怎么快速出现一个 stackoverflow 错误？</li>
</ul>
</li>
<li><p>大厂面试助手(十二)：场景和设计</p>
<ul>
<li><a class="link" href="https://juejin.cn/post/6909437717596241927">https://juejin.cn/post/6909437717596241927 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
</li>
<li><p>智力题资源</p>
<ul>
<li><p>【盘点】面试中常常看见的智力题  烫</p>
<ul>
<li><a class="link" href="https://www.nowcoder.com/discuss/262595">https://www.nowcoder.com/discuss/262595 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>【智力题】大厂最爱问的智力题</p>
<ul>
<li><a class="link" href="https://chowdera.com/2022/01/202201071409493219.html">https://chowdera.com/2022/01/202201071409493219.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>互联网大厂最爱问的智力题总结（带详细答案）  烫</p>
<ul>
<li><a class="link" href="https://www.nowcoder.com/discuss/754712?type=1&amp;channel=-1&amp;source_id=discuss_terminal_discuss_hot_nctrack">https://www.nowcoder.com/discuss/754712?type=1&amp;channel=-1&amp;source_id=discuss_terminal_discuss_hot_nctrack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="简历编写"><a href="#简历编写" class="headerlink" title="简历编写"></a>简历编写</h3><ul>
<li><p>使用超级简历，最后生成PDF</p>
<ul>
<li><a class="link" href="https://www.wondercv.com/">https://www.wondercv.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>优秀简历排版</p>
<ul>
<li><a class="link" href="https://github.com/billryan/resume">https://github.com/billryan/resume <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>简历对比</p>
<ul>
<li><p>排版不合适的简历</p>
<ul>
<li>简历来自网络</li>
</ul>
</li>
<li><p>排版合适的简历</p>
<ul>
<li>简历来自网络</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="简历投递与内推"><a href="#简历投递与内推" class="headerlink" title="简历投递与内推"></a>简历投递与内推</h3><ul>
<li><p>对于投递方式的说明</p>
<ul>
<li><p>直接投递</p>
<ul>
<li>即到各个公司的校招官网，上传简历，等待公司的面试官筛选你的简历并发起面试</li>
</ul>
</li>
<li><p>内推</p>
<ul>
<li>内推对于面试者来说，唯一的作用是能够将我们的简历定向到具体的小组里。首先一个公司不同部门、不同小组之间是千差万别的，所以这种方式能让我们去到比较好评的部门；其次不要认为内推就能减少面试轮次，是不行的，所有的面试基本都是3轮技术面（1面同事或mentor，2面leader，3面leader的leader或者交叉面，即其他组的同级别leader）+1轮轻松的HR面。</li>
</ul>
</li>
</ul>
</li>
<li><p>牛客网找内推</p>
<ul>
<li>使用方式：翻到下面的帖子，选择感兴趣的方向，留言、发送邮件给发帖人，或按照发帖人提供的方式进行联系。这样内推需要海投，发帖人不一定会处理，可能是简历不过，可能是忘记处理</li>
<li><a class="link" href="https://www.nowcoder.com/discuss/referral/index">https://www.nowcoder.com/discuss/referral/index <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>官网投递（一样很高效）</p>
<ul>
<li><p>腾讯</p>
<ul>
<li><a class="link" href="https://join.qq.com/">https://join.qq.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>字节跳动</p>
<ul>
<li><a class="link" href="https://jobs.bytedance.com/campus">https://jobs.bytedance.com/campus <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>阿里巴巴</p>
<ul>
<li><a class="link" href="https://talent.alibaba.com/campus/home">https://talent.alibaba.com/campus/home <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>微软</p>
<ul>
<li><a class="link" href="https://www.microsoft.com/zh-cn/ard/recruitment">https://www.microsoft.com/zh-cn/ard/recruitment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
</li>
<li><p>实习僧海投</p>
<ul>
<li><a class="link" href="https://www.shixiseng.com/">https://www.shixiseng.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
<h3 id="面试套路"><a href="#面试套路" class="headerlink" title="面试套路"></a>面试套路</h3><ul>
<li><p>关于面经</p>
<ul>
<li>我建议你不要看别人的面经，除了徒增焦虑，感觉自己菜以外，没有任何有效信息摄入，别人考的内容，你不一定考；别人的知识储备，你不一定有，简单的面经没人看，难的面经一堆人卷，复习接雨水，面试二叉树反转。只关注好自己有没有复习好，不要过分关注别人怎么样。</li>
</ul>
</li>
<li><p>关于面试常见QA</p>
<ul>
<li><p>实习和校招面试流程是怎样的？</p>
<ul>
<li><p>一般是面试官直接和你联系，然后约定一个面试时间，发给你一个在线会议的链接。到了约定时间后，双方一起进入面试的在线会议链接，然后打开摄像头，面试官提问，你回答问题。而做算法题的时候，一般会给你一个在线编辑器，里面你输入的内容，面试官也能够看到，许多面试官会直接采用牛客网的面试链接，因此你要熟悉没有IDE的情况下，刷算法题，比较推荐的就是leetcode刷题，acm模式，不要有什么联想功能</p>
</li>
<li><p>当问题问完，以及算法题做完后，面试官会让你反问，这个时候</p>
<ul>
<li><p>如果你感觉面试情况不错</p>
<ul>
<li>可以和面试官积极交流一下，展现出你比较积极的一面，比如询问具体需要做什么，面试中还需要补充哪些知识，是否有特别不足的地方，需要提升的地方。建议这时候不要询问上班时间、加班情况、卷不卷这种问题。除非你个人技术实力确实比较强，那么其实可以对这些你的底线问题进行询问，避免之后在后续面试浪费时间，当然最好的建议还是，在面试之前就大概了解，你的底线是否会触及，这样可以节约你的面试官的时间。</li>
</ul>
</li>
<li><p>如果感觉面试情况一般</p>
<ul>
<li>建议就少说话了，好好准备下一次面试，不要陷入面试失利的情绪中，好好准备下一次面试，复盘一下问题，哪些是没有复习到的知识要点？哪些是面试流程上，你可以更主动地避免？哪些是面试官的原因。不需要太过自责，有时候面试官的友好引导，也会影响我们的面试发挥。</li>
</ul>
</li>
<li><p>可以问过没过吗？</p>
<ul>
<li>一般来说，面试官都是不会回答这个问题的，事实上，过没过最清楚的应该是你自己，大概80%的问题答出来了，而且你的竞争者不卷、这个岗位的hc不卷的话，过面试没什么问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>面试一般要多久？</p>
<ul>
<li>不管是实习生面试还是应届生面试，每一轮技术面试的时长都是固定的，一般来说就是40-80分钟，包括做算法题的时间。由于面试一开始是由你自己做自我介绍，因此事实上一开始面试的主动权是掌握在你手上的，如果你自我介绍几十秒钟就结束了，而你的简历又写得非常简单，那么面试官大概率会让你先做几道算法题，再通过做题的第一印象来对你进行面试，判断你是否通过。</li>
</ul>
</li>
<li><p>一开始就做算法题？</p>
<ul>
<li>然而事实上，很多人面试，算法题是最后一个步骤，甚至对于面试表现比较好的同学来说，最后做算法题的数量也许就一道两道的样子，然后提供一个思路，代码实现就好了，甚至都不要求你运行，面试官也许会一眼就能看出你的思路大概是不是正确的。因此，最好保证你的算法题是最后来做，而不是在一开始的时候就做算法题，如果遇到了面试官在开始的时候直接打断你，要求你先做算法题，只能说你运气不是很好。</li>
</ul>
</li>
<li><p>实习生面试会比应届生的面试要简单吗？</p>
<ul>
<li>一般来说，从面试的实际体验上，面试官明面上会告诉你，实习生和应届生的要求是一模一样的，不会有任何的包容。但实际执行的过程中，有可能会感受到，对实习生回答不上来问题是更包容的，尽管对于应届生来说，回答不上来问题，也是比较包容的，毕竟每个人的精力是有限的，大部分的同学都不是对于每一个问题都能够回答得非常好，总有纰漏的地方，或者并不了解的地方。</li>
</ul>
</li>
<li><p>遇到不会的技术怎么办？</p>
<ul>
<li>和面试官，不卑不亢地说清楚：“不好意思，这个技术我不是很清楚。”当然如果你只是了解，并不知道其源码实现，也是很正常的，也要和面试官说清楚，不要强答，也不要害怕。</li>
</ul>
</li>
<li><p>答不上来问题就会挂吗？</p>
<ul>
<li>不会。面试是人和人的交流，绝对是会有运气的存在的，因此答不上来，最后却过了，是很正常的情况，把每一次面试都当作</li>
</ul>
</li>
<li><p>全部答上来就会拿到offer吗？</p>
<ul>
<li>不一定。过的概率比较大，但是每一次面试，一般都是有另外几个同学在同时和你们竞争，如果人家一样答得很好，但是在简历上、其他地方上有比你突出的地方，比如实习公司和学校在同一所位置，实习时间比你更长，他和hr面试时的稳定性更好，很有可能最后offer就发给他（如果hc只有一个，不能发给多个人）。</li>
</ul>
</li>
<li><p>和HR面试有什么注意的？</p>
<ul>
<li>HR面试的问题都比较开放性，一般问的问题是看你是否适合过来，看看你的稳定性，你要站在hr的角度去考虑hr的问题。比如问你有没有对象？你的对象在什么城市？你以后打算在哪里发展？可能就是看你的稳定性，那么对你来说最有利，但不一定是事实的回答就是，你没有女朋友，你对象就在公司所在城市，你打算在公司所在城市发展，未来想要在公司越干越好，绝对没想过跳槽。。。这样那样的回答，是比较符合hr的期望的，所以在回答每一个问题的时候，好好思考一下对方主要是想问什么，根据你自身的情况，去回答对应的问题。规则是死的，人是活的，不要有做题家思想，考虑太多真实与虚假，正确与错误，正义与不正义的问题</li>
</ul>
</li>
<li><p>为什么官网简历一直在筛选？</p>
<ul>
<li>可能是因为你的简历不够突出，一直没有面试官捞起来，并向你发起面试，可以考虑重新改一下简历，再重新上传，一般一周内都会有面试发起的，好的简历一般两三天就会发起新的面试（即便是被挂掉之后的情况）</li>
<li>这时候也可以考虑询问内推人、或者相关联系人（你投递简历的时候联系的那个人，前提是你不是使用的校招官网直接投递），你的简历情况</li>
</ul>
</li>
<li><p>为什么面试结束后，一直没有通知下一步进展（没有挂，也没有说发起下一次面试）？</p>
<ul>
<li>1、可能只是面试官还要面试其他人，当你们所有人面试通过后，就会进行排序，最后选出hc个数量的面试者通过，然后参加下一次面试；2、这种情况，也可以直接询问你的内推人，到底是什么情况，如果面试官认为是挂掉了，那就催促一下对方，尽快结束流程，然后等待下一次面试官的捞起简历、发起面试</li>
</ul>
</li>
<li><p>面试挂掉还会有人捞吗？</p>
<ul>
<li>即使是面试挂掉，并不代表是你能力不行，也许只是简单的因为hc数量不够，根据排序你被筛掉而已，这很正常，所以很运气。因此即使是挂掉，只要之前有人向你发起面试（显然的，毕竟你是面试挂了），正常情况下都会有新的面试官向你发起面试的。</li>
</ul>
</li>
<li><p>面评是什么？很重要吗？</p>
<ul>
<li>面评，就是当你结束面试之后，面试官会将本次面试的评价、对面试者的评价写入系统。只要没有出现很糟糕的情况：1、和面试官吵架、双方态度很差，以及各种奇怪的状况；2、你的面试完全没有认真准备，90%的问题都没有回答上来，显然是假的；3、各种方面的不认可面试官等等。。。</li>
<li>不能说很重要，也不能说不重要。只要是正常情况下，面评不会影响任何事情，就算是面试挂了，也没有什么问题。</li>
</ul>
</li>
</ul>
</li>
<li><p>最好的面试实践</p>
<ul>
<li><p>0、好好丰富你的简历，让你的简历有话可说，你的实习经历、你的项目经历都有话可说。在刚进入面试会议间的时候，面试官让你先做自我介绍。</p>
</li>
<li><p>1、做完自我介绍，不要简单的就是介绍你是谁，你哪里来的，想去哪。而是自我介绍结束，立刻开始聊你自己的简历，你会的技术栈是什么，你的项目经历是什么，你主要做了什么东西，用到了什么技术，为什么要用这个技术？你负责的是哪块，难点是什么？你的实习是在哪里，实习主要工作是什么？</p>
<ul>
<li>你要知道的是，你的简历里的内容，一定是你比面试官掌握得更清楚的，这时候主动权在你的手上，好好把握这部分的节奏，既要有深度又要有广度，不要被面试官带了太多节奏。</li>
</ul>
</li>
<li><p>2、当你经过第1点之后，你会发现，时间已经过了差不多20分钟了，这时候你的简历已经聊完了，你和面试官已经亲切交流过了。这时候，一般面试官会直接问你“八股文”，也就是问你很多，我告诉你复习过的知识，一般都是一问一答的形式，或者是对一个问题，一起深入探究。</p>
<ul>
<li>你要记得，这部分，并不是绝对的一问一答的方式，也不是做题，当遇到困难需要你思考的问题的时候，适当请求面试官的点拨，达到一个在面试的时候，就有的一个共同合作的关系（就像在工作一样），当然你绝对不能直接问面试官怎么做，而是带有思考地给出方案，然后询问面试官的看法。</li>
</ul>
</li>
<li><p>3、当你完成第2点的时候，你会发现又20分钟过去了，差不多就已经快结束了。这时候，双方都比较累了，大概率面试官会让你做算法题，这样他会轻松一点，当然如果你俩现在就已经60多分钟了，可能就不做算法题了，也不是不可能的事情。这时候剩20分钟，做算法题，给一道做一道即可</p>
<ul>
<li>先记住，你做完了一道题，如果做得很好，那就会给你一道新的题，更难的题，题是做不完的，除非你把面试官的题库做完了，一般在一次面试中都有四五道。</li>
<li>既然如此，那到底怎么办呢：）巧妙的方法是，刷太快的话，不要急着提交，大概差不多的时候你再提交，比如面试官询问你是否已经完成的时候，你再提交，这时候你可以解释你在思考是否有遗漏的情况、以及有没有更好的解决方式，如果你有时间，顺便分析一下时间空间复杂度，在解释给面试官的时候，这样会更科班、更专业。</li>
</ul>
</li>
<li><p>4、等算法题做完之后，面试基本上就算是完成了，这时候面试官也许会让你反问他一些问题，不过如果面试情况不是很好的话，可以选择不问，当然也可以直接比较礼貌地告诉面试官：“感觉今天面试的发挥不是很好，如果没有通过的话，希望他能够帮忙快一些释放简历，然后自己方便好好复盘，准备被其他面试官捞起来重新面试，好好准备下一次的面试。”</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Sharing</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>就业</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode debug配置对比</title>
    <url>/2023/05/28/VSCode%20debug%E9%85%8D%E7%BD%AE%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line"># 测试c++代码</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string longestCommonPrefix(vector&lt;string&gt; &amp;strs) &#123;</span><br><span class="line">  int maxLen = 0, strNum = strs.size();</span><br><span class="line">  for (int l = 0; l &lt; strs[0].length(); l++) &#123;</span><br><span class="line">    char c = strs[0][l];    // 断点设置位置;</span><br><span class="line">    for (int i = 1; i &lt; strNum; i++) &#123;</span><br><span class="line">      if (strs[i].length() &lt; l || strs[i][l] != c)</span><br><span class="line">        return strs[0].substr(0, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    maxLen++;</span><br><span class="line">  &#125;</span><br><span class="line">  return strs[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  vector&lt;string&gt; strs = &#123;&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;&#125;;</span><br><span class="line">  string output = longestCommonPrefix(strs);</span><br><span class="line">  cout &lt;&lt; output &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line"># launch.json</span><br><span class="line">&#123;</span><br><span class="line">    // 欲了解更多信息，请访问: https://code.visualstudio.com/docs/cpp/launch-json-reference</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;clang + codelldb&quot;, // 对容器的支持弱于gdb</span><br><span class="line">            &quot;type&quot;: &quot;lldb&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/main&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;clang++ build&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;clang + cppdbg&quot;, // 混搭gdb和clang效果不好; 还是应该统一使用gnu或llvm</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/main&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,</span><br><span class="line">            &quot;linux&quot;: &#123;</span><br><span class="line">                &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">                &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;osx&quot;: &#123;</span><br><span class="line">                &quot;MIMode&quot;: &quot;lldb&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;clang++ build&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;gcc + cppdbg&quot;, // gcc + gdb 效果最好</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/main&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,</span><br><span class="line">            &quot;linux&quot;: &#123;</span><br><span class="line">                &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">                &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;osx&quot;: &#123;</span><br><span class="line">                &quot;MIMode&quot;: &quot;lldb&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: false</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;g++ build&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="codelldb"><a href="#codelldb" class="headerlink" title="codelldb"></a>codelldb</h2><p>对容器的支持有待提高</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/05/28/VSCode%20debug%E9%85%8D%E7%BD%AE%E5%AF%B9%E6%AF%94/ed0313a6_Untitled.png" alt="Untitled"></p>
<h2 id="gcc-gdb"><a href="#gcc-gdb" class="headerlink" title="gcc+gdb"></a>gcc+gdb</h2><p>设置的断点位置异常可能导致调试出错, 当然普通的变量监控是没问题的. 但是在监控中调用方法就可能出错.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/05/28/VSCode%20debug%E9%85%8D%E7%BD%AE%E5%AF%B9%E6%AF%94/b60f99f5_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/05/28/VSCode%20debug%E9%85%8D%E7%BD%AE%E5%AF%B9%E6%AF%94/7bec4bf5_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/05/28/VSCode%20debug%E9%85%8D%E7%BD%AE%E5%AF%B9%E6%AF%94/f1810100_Untitled.png" alt="Untitled"></p>
<h2 id="clang-gdb"><a href="#clang-gdb" class="headerlink" title="clang + gdb"></a>clang + gdb</h2><p>显然, 混用gnu和llvm的配置并不好. 其实还有一种lldb+gcc, 这种我甚至运行不起来..</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/05/28/VSCode%20debug%E9%85%8D%E7%BD%AE%E5%AF%B9%E6%AF%94/3e31da96_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>如果只是简单的监控变量, llvm和gnu系列的体验都不错, 都能够看到容器内的变量;</p>
</li>
<li><p>但是在watch中调用方法的体验, 都有各自的问题, 硬要说的话,  可能gnu的搭配还是要好一些.</p>
<ul>
<li>结论, 最好不要在watch中调用方法!</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Application</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>vscode</tag>
        <tag>debug</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>clang工具链搭建踩坑</title>
    <url>/2023/04/08/clang%E5%B7%A5%E5%85%B7%E9%93%BE%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h2 id="目标环境"><a href="#目标环境" class="headerlink" title="目标环境"></a>目标环境</h2><ul>
<li>VSCode + LunarVim</li>
<li>clang for compile<ul>
<li>Clangd for intelligent coding</li>
<li>clang-format for document format</li>
<li>LLDB for debug</li>
</ul>
</li>
</ul>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><ul>
<li>在编译命令后加 -v 可以看到具体的报错信息</li>
<li>libstdc++是gcc使用的C++标准库, 其中包括容器,io,算法,迭代器等, 而libc++是LLVM团队实现的, 需要单独安装(不会在安装clang时同时安装)</li>
<li>clang编译时, 如果不加入-stdlib&#x3D;libc++, 则默认使用libstdc++, 即使用g++的标准实现<ul>
<li>libc++是对c++标准库的实现，而libc++abi（application binary interface）提供内存管理，异常处理等底层支持。libc++依赖libc++abi或pathscale的libcxxrt或gcc的libsupcxx三者之一进行构建。</li>
</ul>
</li>
</ul>
<h3 id="clang-无法找到头文件iostream"><a href="#clang-无法找到头文件iostream" class="headerlink" title="clang++无法找到头文件iostream"></a>clang++无法找到头文件iostream</h3><p>通过apt install clang++之后, 进行编译测试</p>
<p>clang main.cpp -o main报错: <strong>Clang++: fatal error: ‘iostream’ file not found</strong></p>
<p><a class="link" href="https://stackoverflow.com/questions/54521402/locating-iostream-in-clang-fatal-error-iostream-file-not-found">Locating iostream in Clang++: fatal error: ‘iostream’ file not found <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>根本原因: clang++在编译过程中, 需要使用g++中的头文件, 而具体使用的版本是通过gcc —version来确定的, 那么导致上诉错误的原因有两种:</p>
<ol>
<li>本地未安装gcc或g++</li>
<li>gcc 版本与g++版本不一致: gcc版本高于g++导致无法找到gcc对应版本的g++头文件</li>
</ol>
<p>解决方法: 安装相同版本的gcc和g++, 保证gcc —version和g++ —version结果相同</p>
<ul>
<li>通过apt install新版gcc和g++, 到&#x2F;usr&#x2F;bin&#x2F;中重新构建gcc和g++的软链接</li>
</ul>
<h3 id="clang编译过程中加入-stdlib-x3D-libc-报错"><a href="#clang编译过程中加入-stdlib-x3D-libc-报错" class="headerlink" title="clang编译过程中加入-stdlib&#x3D;libc++报错"></a>clang编译过程中加入-stdlib&#x3D;libc++报错</h3><p>当使用-stdlib&#x3D;libstdc++时编译正常, 但是&#x3D;libc++时, 因为找不到头文件而编译失败了</p>
<ul>
<li>sudo apt install libc++-14-dev</li>
<li>sudo apt install libc++abi-14-dev</li>
<li>14为clang版本号</li>
</ul>
<h3 id="VSCode中完成配置"><a href="#VSCode中完成配置" class="headerlink" title="VSCode中完成配置"></a>VSCode中完成配置</h3><p>下载所需插件:</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/04/08/clang%E5%B7%A5%E5%85%B7%E9%93%BE%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91/Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/04/08/clang%E5%B7%A5%E5%85%B7%E9%93%BE%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91/1.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/04/08/clang%E5%B7%A5%E5%85%B7%E9%93%BE%E6%90%AD%E5%BB%BA%E8%B8%A9%E5%9D%91/2.png" alt="Untitled"></p>
<p>编写tasks.json 和 launch.json</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;process&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang++ build&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang++&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-std=c++17&quot;</span><span class="punctuation">,</span> <span class="comment">// C++标准(语法支持)</span></span><br><span class="line">                <span class="string">&quot;-stdlib=libc++&quot;</span><span class="punctuation">,</span> <span class="comment">// C++标准库</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang debug&quot;</span><span class="punctuation">,</span> <span class="comment">//名称随便取</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span> <span class="comment">//正在使用的调试器,使用Visual Studio Windows时必须为cppvsdbg,使用GDB或LLDB时必须为cppdbg; 此时使用codelldb因此type为lldb</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span> <span class="comment">//表示此配置是用于启动程序还是附加到已运行的实例上</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span> <span class="comment">//要执行的可执行文件的完整路径</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span> <span class="comment">//可执行程序完整路径（不包含程序名称）</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang++ build&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p><a class="link" href="https://juejin.cn/post/7218564871831748664">libc++abi介绍 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link" href="https://zhuanlan.zhihu.com/p/54779018">c++编译工具链 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link" href="https://juejin.cn/post/7177664925915938875">LLVM的相关介绍,以及clang工具链安装教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下次还是不要想当然直接apt下载了, 老老实实搜一搜了解一下, 会避免很多坑! 不过说到底还是自己对C++的编译过程太不了解…</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>vscode</tag>
        <tag>LLVM</tag>
        <tag>clang</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>时间序列预测的多粒度残差学习</title>
    <url>/2022/06/24/clash%E4%BB%A3%E7%90%86%E4%B8%8Enotion%E7%9A%84%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<h1 id="情景描述"><a href="#情景描述" class="headerlink" title="情景描述"></a>情景描述</h1><p>当打开clash代理之后，notion就无法上传图片</p>
<img lazyload src="/images/loading.svg" data-src="/2022/06/24/clash%E4%BB%A3%E7%90%86%E4%B8%8Enotion%E7%9A%84%E5%86%B2%E7%AA%81/image-1656073091111.png" class>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>这里是描述我解决问题的过程，如果只需要解决方法，可以直接看到最后面的部分</strong></p>
<h3 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h3><p>第一时间想到的当然是去设置转发规则，设置parser，添加DIRECT规则：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">parsers:</span> <span class="comment"># array</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">-----</span> <span class="string">subscribe</span> <span class="string">url</span> <span class="string">--------</span></span><br><span class="line">    <span class="attr">yaml:</span></span><br><span class="line">      <span class="attr">prepend-rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,</span> <span class="string">notion.so,DIRECT</span></span><br></pre></td></tr></table></figure></div>

<p>然后更新订阅profile</p>
<p>此时再去查看notion相关的链接：</p>
<img lazyload src="/images/loading.svg" data-src="/2022/06/24/clash%E4%BB%A3%E7%90%86%E4%B8%8Enotion%E7%9A%84%E5%86%B2%E7%AA%81/image-1656073252115.png" class>

<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>然而问题是，即使这里采用DIRECT规则，依旧无法上传图片，只有把clash的System Proxy关闭才能上传图片，就很奇怪。<br>将代理改成DIRECT之后，发现也是可以成功的，说明是加入的规则不正确，没有涵盖上传图片的api。</p>
<img lazyload src="/images/loading.svg" data-src="/2022/06/24/clash%E4%BB%A3%E7%90%86%E4%B8%8Enotion%E7%9A%84%E5%86%B2%E7%AA%81/image-1656073478536.png" class>
<p>经过测试，才发现，原来notion的文件管理使用的是亚马逊的云服务</p>
<img lazyload src="/images/loading.svg" data-src="/2022/06/24/clash%E4%BB%A3%E7%90%86%E4%B8%8Enotion%E7%9A%84%E5%86%B2%E7%AA%81/image-1656073672219.png" class>
<p>通过选中notion中图片，并View Original，就可以发现图片在亚马逊云上的链接：”<a class="link" href="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/xxxxxxxxxxxxxxxxxxxxx&quot;%EF%BC%8C">https://s3.us-west-2.amazonaws.com/secure.notion-static.com/xxxxxxxxxxxxxxxxxxxxx&quot;， <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 而且这个链接是没有被墙的，所以我们就可以在parser中添加这条规则：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">parsers:</span> <span class="comment"># array</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">-----</span> <span class="string">subscribe</span> <span class="string">url</span> <span class="string">--------</span></span><br><span class="line">    <span class="attr">yaml:</span></span><br><span class="line">      <span class="attr">prepend-rules:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,</span> <span class="string">notion.so,DIRECT</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,</span> <span class="string">amazonaws.com,DIRECT</span></span><br></pre></td></tr></table></figure></div>

<p>至此，问题解决。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>clash</tag>
        <tag>notion</tag>
      </tags>
  </entry>
  <entry>
    <title>C++代码规范</title>
    <url>/2023/08/29/notion-C++%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC-0e5515b0/</url>
    <content><![CDATA[<p><a class="link" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/#">google C++规范中文文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ol>
<li><p>self-contained头文件</p>
</li>
<li><p>#define保护: 命名格式为 <code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H</code></p>
</li>
<li><p>尽量避免使用前置声明(纯粹的声明, 没有定义)</p>
</li>
<li><p>只有当函数小于10行时才将其定义为内联函数</p>
</li>
<li><p>#include的路径和顺序</p>
<ul>
<li><p>项目内的头文件按照项目源代码目录树结构排列, 避免使用UNIX特殊快捷目录<code>.</code>和<code>..</code></p>
</li>
<li><p>使用标准的include顺序: 相关头文件, C 库, C++ 库, 其他库的头文件, 本项目内的头文件</p>
</li>
</ul>
</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ol>
<li><p><strong>命名空间</strong>: 鼓励在 <code>.cc</code> 文件中使用匿名命令空间或 <code>static</code> 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</p>
<ul>
<li><p>在命名空间的最后注释出命名空间的名字。</p>
</li>
<li><p>用命名空间把文件包含, gflags 的声明&#x2F;定义, 以及类的前置声明以外的整个源文件封装起来</p>
</li>
<li><p>不使用 <em>using 指示</em> 引入整个命名空间的标识符号。</p>
</li>
<li><p>不要在头文件中使用 <em>命名空间别名</em> 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</p>
</li>
</ul>
</li>
<li><p>**匿名命名空间和静态变量:**在 <code>.cc</code> 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 <code>static</code> 。但是不要在 <code>.h</code> 文件中这么做。</p>
</li>
<li><p>**非成员函数、静态成员函数和全局函数:**使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p>
</li>
<li><p><strong>局部变量</strong>: 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化, 离第一次使用越近越好</p>
<ul>
<li>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.</li>
</ul>
</li>
<li><p><strong>静态和全局变量</strong>: 禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p>
</li>
</ol>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li><p><strong>构造函数的职责</strong>: 不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>
</li>
<li><p><strong>不要定义隐式类型转换</strong>. 对于转换运算符和单参数构造函数, 请使用 <code>explicit</code> 关键字.</p>
<ul>
<li>一个例外是, 拷贝和移动构造函数不应当被标记为 <code>explicit</code>, 因为它们并不执行类型转换</li>
</ul>
</li>
<li><p>**可拷贝类型和可移动类型:**如果你的类型需要, 就让它们支持拷贝 &#x2F; 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>
</li>
<li><p>**结构体 VS. 类:**仅当只有数据成员时使用 <code>struct</code>, 其它一概使用 <code>class</code>.</p>
</li>
<li><p><strong>继承</strong>: 使用组合常常比使用继承更合理. 如果使用继承的话, <strong>定义为</strong><code>**public**</code><strong>继承</strong>.</p>
<ul>
<li><p>如果你的类有虚函数, 则析构函数也应该为虚函数.</p>
</li>
<li><p>在声明重载时, 请使用 <code>override</code>, <code>final</code> 或 <code>virtual</code> 的其中之一进行标记.</p>
</li>
</ul>
</li>
<li><p><strong>多重继承</strong>: 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <code>Interface</code> 为后缀的纯接口类.</p>
</li>
<li><p><strong>接口</strong>: 接口是指满足特定条件的类, 这些类以 <code>Interface</code> 为后缀 (不强制).</p>
</li>
<li><p><strong>运算符重载</strong>: 除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.</p>
</li>
<li><p><strong>存取控制</strong>: 将 <em>所有</em> 数据成员声明为 <code>private</code>, 除非是 <code>static const</code> 类型成员.</p>
</li>
<li><p><strong>声明顺序</strong>: 将相似的声明放在一起, 将 <code>public</code> 部分放在最前.</p>
</li>
</ol>
<ul>
<li>建议以如下的顺序: 类型 (包括 <code>typedef</code>, <code>using</code> 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol>
<li><p>**输入和输出:**我们倾向于按值返回， 否则按引用返回。 避免返回指针， 除非它可以为空.</p>
</li>
<li><p>**编写简短函数:**倾向于编写简短, 凝练的函数. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p>
</li>
<li><p>**引用参数:**所有按引用传递的参数必须加上 <code>const</code>.</p>
</li>
<li><p>**函数重载:**若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</p>
</li>
<li><p>**缺省参数:**只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 函数重载 遵循同样的规则. 一般情况下建议使用函数重载.</p>
</li>
<li><p>**函数返回类型后置语法:**只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.</p>
</li>
</ol>
<h2 id="来自google的奇技"><a href="#来自google的奇技" class="headerlink" title="来自google的奇技"></a>来自google的奇技</h2><ol>
<li><p>**所有权与智能指针:**动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p>
<ul>
<li><p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 <code>std::unique_ptr</code> 来明确所有权传递</p>
</li>
<li><p>如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 <code>std::shared_ptr</code> .</p>
</li>
</ul>
</li>
<li><p>使用cpplint检查风格错误</p>
</li>
</ol>
<h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><ol>
<li><p>函数命名, 变量命名, 文件命名要有描述性; <strong>少用缩写</strong>.</p>
</li>
<li><p>文件命名: <strong>文件名要全部小写</strong>, 可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>), 依照项目的约定. 如果没有约定, 那么 “<code>_</code>” 更好.</p>
<ul>
<li><p>C++ 文件要以 <code>.cc</code> 结尾, 头文件以 <code>.h</code> 结尾. 专门插入文本的文件则以 <code>.inc</code> 结尾</p>
</li>
<li><p>不要使用已经存在于 <code>/usr/include</code> 下的文件名</p>
</li>
<li><p>定义类时文件名一般成对出现, 如 <code>foo_bar.h</code> 和 <code>foo_bar.cc</code>, 对应于类 <code>FooBar</code>.</p>
</li>
</ul>
</li>
<li><p>类型命名: <strong>类型名称的每个单词首字母均大写, 不包含下划线</strong>: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p>
</li>
<li><p>变量命名: 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. <strong>类的成员变量以下划线结尾</strong>, 但结构体的就不用, 如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code></p>
</li>
<li><p>常量命名: 声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, <strong>命名时以 “k” 开头</strong>, 大小写混合.</p>
</li>
<li><p>函数命名: <strong>常规函数使用大小写混合</strong>, 取值和设值函数则要求与变量名匹配</p>
</li>
<li><p>命名空间命名: 命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突. 不使用缩写</p>
</li>
<li><p>枚举命名: 枚举的命名应当和 常量 或 宏 一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>. 单独的枚举值应该<strong>优先采用 常量 的命名方式</strong>. 但 <a class="link" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#macro-names">宏 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 方式的命名也可以接受.</p>
</li>
<li><p>宏命名: 通常 <em>不应该</em> 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线</p>
</li>
</ol>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol>
<li><p>注释风格: 使用 <code>//</code> 或 <code>/* */</code>, 统一就好,  <code>//</code> <em>更</em> 常用.</p>
</li>
<li><p>文件注释: 在每一个文件开头加入版权公告. 文件注释描述了该文件的内容.</p>
</li>
<li><p>类注释: 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</p>
<ul>
<li><p>类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.</p>
</li>
<li><p>如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适.</p>
</li>
<li><p>如果类的声明和定义分开了(例如分别放在了 <code>.h</code> 和 <code>.cc</code> 文件中), 此时, <strong>描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起.</strong></p>
</li>
</ul>
</li>
<li><p>函数注释: 函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p>
<p> 函数声明处注释的内容:</p>
<ul>
<li>函数的输入输出.</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>
<li>函数是否分配了必须由调用者释放的空间.</li>
<li>参数是否可以为空指针.</li>
<li>是否存在函数使用上的性能隐患.</li>
<li>如果函数是可重入的, 其同步前提是什么?</li>
</ul>
</li>
<li><p>变量注释: 通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
</li>
<li><p>如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释.</p>
</li>
<li><p>特别地, 如果变量可以接受 <code>NULL</code> 或 <code>-1</code> 等警戒值, 须加以说明.</p>
</li>
<li><p>实现注释:</p>
</li>
<li><p>**代码前注释:**巧妙或复杂的代码段前要加注释.</p>
</li>
<li><p>**行注释:**比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释.</p>
</li>
<li><p>**函数参数注释:**如果函数参数的意义不明显, 考虑用下面的方式进行弥补:</p>
<ul>
<li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破.</li>
<li>考虑更改函数的签名, 让某个 <code>bool</code> 类型的参数变为 <code>enum</code> 类型, 这样可以让这个参数的值表达其意义.</li>
<li>如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改.</li>
<li>用具名变量代替大段而复杂的嵌套表达式.</li>
<li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li>
</ul>
</li>
<li><p>TODO注释: 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 <code>TODO</code> 相关的 issue.</p>
</li>
<li><p>DEPRECATED注释: 通过弃用注释（<code>DEPRECATED</code> comments）以标记某接口点已弃用. 可以放在接口声明前, 或者同一行.</p>
</li>
<li><p>标点和语法: 注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句. 大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释, 比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性.</p>
</li>
</ol>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><blockquote>
<p>直接使用google风格的代码格式化工具即可.</p>
</blockquote>
<ol>
<li><p>每一行代码字符数不超过 80.</p>
</li>
<li><p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p>
</li>
<li><p>只使用空格, 每次缩进 2 个空格.</p>
</li>
<li><p>函数声明与定义: 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行</p>
</li>
<li><p>Lambda表达式: Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p>
</li>
<li><p>函数调用: 要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p>
</li>
<li><p>条件语句: 尽可能不省略大括号. 只有<code>if (condition) dosomething();</code> 语句很短时可以写为一行.</p>
 <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 圆括号里没有空格.</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>循环和switch: <code>switch</code> 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 <code>&#123;&#125;</code> 或 <code>continue</code>. 在单语句循环里, 括号可用可不用</p>
</li>
<li><p>指针和引用表达式: 句点或箭头前后不要有空格. 指针&#x2F;地址操作符 (<code>*, &amp;</code>) 之后不能有空格. 在声明指针变量或参数时, 星号与类型或变量名紧挨都可以</p>
</li>
<li><p>布尔表达式: 如果一个布尔表达式超过 <a class="link" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#line-length">标准行宽 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, 断行方式要统一一下.</p>
</li>
<li><p>预处理指令**:**预处理指令不要缩进, 从行首开始.</p>
</li>
<li><p>类格式: 访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每个都缩进 1 个空格.</p>
</li>
<li><p>构造函数初始值列表: 构造函数初始化列表放在同一行或按四格缩进并排多行.</p>
</li>
<li><p>命名空间: 命名空间内容不缩进.</p>
</li>
<li><p>垂直留白越少越好. 基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看</p>
</li>
</ol>
<h2 id="其他C-特性"><a href="#其他C-特性" class="headerlink" title="其他C++特性"></a>其他C++特性</h2><ol>
<li><p>引用参数: 所有按引用传递的参数必须加上 <code>const</code>.</p>
</li>
<li><p>右值引用: 只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 <code>std::forward</code>.</p>
</li>
<li><p>禁止使用 RTTI(运行时类型识别), 如使用 <code>typeid</code> 或者 <code>dynamic_cast</code> .只允许在单元测试中使用RTTI</p>
</li>
<li><p>使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用 <code>int y = (int)x</code> 或 <code>int y = int(x)</code> 等转换方式</p>
</li>
<li><p>只在记录日志时使用流.</p>
</li>
<li><p>对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增, 自减运算符.</p>
</li>
<li><p>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化.</p>
</li>
<li><p>C++ 内建整型中, 仅使用 <code>int</code>. 如果程序中需要不同大小的变量, 可以使用 <code>&lt;stdint.h&gt;</code> 中长度精确的整型, 如 <code>int16_t</code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 <code>int64_t</code>.</p>
</li>
<li><p>代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记</p>
</li>
<li><p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用 <code>&#39;\0&#39;</code>.</p>
</li>
<li><p>尽可能用 <code>sizeof(varname)</code> 代替 <code>sizeof(type)</code>.</p>
</li>
<li><p>用 <code>auto</code> 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方.</p>
</li>
<li><p>适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</p>
</li>
<li><p>只使用 Boost 中被认可的库.</p>
<ul>
<li><p><a class="link" href="http://www.boost.org/doc/libs/1_58_0/libs/utility/call_traits.htm">Call Traits <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> : <code>boost/call_traits.hpp</code></p>
</li>
<li><p><a class="link" href="http://www.boost.org/libs/utility/compressed_pair.htm">Compressed Pair <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> : <code>boost/compressed_pair.hpp</code></p>
</li>
<li><p><a class="link" href="http://www.boost.org/doc/libs/1_58_0/libs/graph/doc/index.html">&lt;The Boost Graph Library (BGL) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> : <code>boost/graph</code>, except serialization (<code>adj_list_serialize.hpp</code>) and parallel&#x2F;distributed algorithms and data structures(<code>boost/graph/parallel/*</code> and <code>boost/graph/distributed/*</code>)</p>
</li>
<li><p><a class="link" href="http://www.boost.org/libs/property_map/">Property Map <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> : <code>boost/property_map.hpp</code></p>
</li>
<li><p>The part of <a class="link" href="http://www.boost.org/libs/iterator/">Iterator <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> that deals with defining iterators: <code>boost/iterator/iterator_adaptor.hpp</code>, <code>boost/iterator/iterator_facade.hpp</code>, and <code>boost/function_output_iterator.hpp</code></p>
</li>
<li><p>The part of <a class="link" href="http://www.boost.org/libs/polygon/">Polygon <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> that deals with Voronoi diagram construction and doesn’t depend on the rest of Polygon: <code>boost/polygon/voronoi_builder.hpp</code>,  <code>boost/polygon/voronoi_diagram.hpp</code>, and <code>boost/polygon/voronoi_geometry_type.hpp</code></p>
</li>
<li><p><a class="link" href="http://www.boost.org/libs/bimap/">Bimap <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> : <code>boost/bimap</code></p>
</li>
<li><p><a class="link" href="http://www.boost.org/libs/math/doc/html/dist.html">Statistical Distributions and Functions <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> : <code>boost/math/distributions</code></p>
</li>
<li><p><a class="link" href="http://www.boost.org/libs/multi_index/">Multi-index <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> : <code>boost/multi_index</code></p>
</li>
<li><p><a class="link" href="http://www.boost.org/libs/heap/">Heap <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> : <code>boost/heap</code></p>
</li>
<li><p>The flat containers from <a class="link" href="http://www.boost.org/libs/container/">Container <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>: <code>boost/container/flat_map</code>, and <code>boost/container/flat_set</code></p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针之我见</title>
    <url>/2023/09/01/notion-None-e640217e/</url>
    <content><![CDATA[<p><a class="link" href="https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/">https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>《Effective modern C++: 42 specific ways to improve your use of C++11 and C++14》Item 18: Use std::unique_ptr for exclusive-ownership resource management.</p>
<p>本文整理一下个人对智能指针用法的总结</p>
<h2 id="为什么使用智能指针"><a href="#为什么使用智能指针" class="headerlink" title="为什么使用智能指针?"></a>为什么使用智能指针?</h2><ul>
<li>unique_ptr保证指针的归属权, 并且能够在指针生命周期结束时自动销毁对象, 释放空间</li>
<li>shared_ptr会进行对象的引用统计, 当引用数为0时, 对象会被销毁.</li>
<li>使用智能指针后, 几乎不再需要delete, 无论是生命周期正常结束, 指针重新赋值甚至发生异常, 都不需要手动释放空间, 可以极大程度避免内存泄漏.</li>
</ul>
<h2 id="选择哪个智能指针"><a href="#选择哪个智能指针" class="headerlink" title="选择哪个智能指针?"></a>选择哪个智能指针?</h2><ul>
<li><p>无论是从安全性还是性能上来看, 都应该优先考虑unique_ptr而不是shared_ptr;</p>
<ul>
<li>如果对象全局唯一, 考虑单例模式</li>
</ul>
</li>
<li><p>只有对象确实同时被多个对象<strong>拥有</strong>, 再考虑使用shared_ptr</p>
</li>
</ul>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><h3 id="什么时候使用"><a href="#什么时候使用" class="headerlink" title="什么时候使用"></a>什么时候使用</h3><ul>
<li>首先是在类中用于管理<strong>专属的数据</strong>. 如字符串等data对象</li>
<li>其次是声明生命周期仅限于函数内部的局部指针变量, 使用unique_ptr就不用手动delete, 在函数有多条return时尤其方便</li>
</ul>
<h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ul>
<li><p>形参是否使用智能指针, 取决于函数是否会发生归属权的变化.</p>
<ul>
<li><p>对于需要获取指针进行赋值, 拷贝, 比较等操作, 而不改变指针归属的函数, 形参采用raw pointer</p>
</li>
<li><p>对于会改变指针归属的函数, 形参采用智能指针的引用.</p>
</li>
</ul>
</li>
<li><p>返回值是否使用智能指针, 取决于是否允许调用者改变指针归属权</p>
<ul>
<li><p>若不允许改变归属权的接口, 返回值为raw pointer</p>
</li>
<li><p>对于允许指针归属权改变的接口ref_api, 返回值为智能指针的引用.</p>
</li>
<li><p>对于要求指针归属权改变的接口ref_api, 返回值为智能指针.</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若调用者要改变指针归属权</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Obj&gt; <span class="title">up</span><span class="params">(src.ref_api(args…).release();</span></span></span><br><span class="line"><span class="params"><span class="function">src.ref_api(args...).move(up);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// 若调用者只是需要获取指针进行赋值, 拷贝, 比较等操作, 而不改变指针归属</span></span></span></span><br><span class="line"><span class="params"><span class="function">Obj *ptr = src.ref_api(args..).get();</span></span></span><br></pre></td></tr></table></figure></div>


]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>RAII优化资源管理</title>
    <url>/2023/08/20/notion-RAII%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86-5cb599b9/</url>
    <content><![CDATA[<p><a class="link" href="https://zhuanlan.zhihu.com/p/34660259">https://zhuanlan.zhihu.com/p/34660259 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>RAII（<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization）是由c++之父Bjarne Stroustrup提出的，中文翻译为资源获取即初始化，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如内存、网络套接字等等，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入；</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>资源的使用一般经历三个步骤a.获取资源 b.使用资源 c.销毁资源，但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？c++之父给出了解决问题的方案：RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期。</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章 RDB持久化</title>
    <url>/2023/08/25/notion-%E7%AC%AC10%E7%AB%A0%20RDB%E6%8C%81%E4%B9%85%E5%8C%96-f4952a77/</url>
    <content><![CDATA[<p>Redis是内存数据库, 如果不进行持久化, 一旦服务器进程退出, 服务器中的数据库状态也会消失不见</p>
<p>RDB持久化既可以手动执行, 也可以根据配置定期执行.</p>
<p>RDB持久化所生成的RDB文件时一个经过压缩的二进制文件.</p>
<h2 id="10-1-RDB文件的创建与载入"><a href="#10-1-RDB文件的创建与载入" class="headerlink" title="10.1 RDB文件的创建与载入"></a>10.1 RDB文件的创建与载入</h2><ul>
<li><p>SAVE命令: 会阻塞Redis服务器进程, 直到RDB文件创建完毕.</p>
</li>
<li><p>BGSAVE命令: 派生出一个子进程, 由子进程负责创建RDB文件.</p>
<ul>
<li><p>BGSAVE执行期间, 另外的SAVE和BGSAVE命令会被拒绝, 避免竞争条件;</p>
</li>
<li><p>BGREWRITEAOF不能和BGSAVE同时执行, 若正在执行BGSAVE, BGREWRITEAOF会延迟执行, 若正在执行BGREWRITEAOF, BGSAVE会被拒绝执行.</p>
</li>
</ul>
</li>
<li><p>载入工作在服务器启动时自动执行, 没有专门的命令, 载入期间处于阻塞状态.</p>
<ul>
<li>另外, 因为AOF文件的更新频率通常比RDB文件高, 所以如果开启了AOF持久化, 会优先使用AOF文件来还原数据库</li>
</ul>
</li>
</ul>
<h2 id="10-2-自动间隔性保存"><a href="#10-2-自动间隔性保存" class="headerlink" title="10.2 自动间隔性保存"></a>10.2 自动间隔性保存</h2><p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行, 所以可以配置save选项来定期执行BGSAVE命令.</p>
<ul>
<li><p>save选项支持多个条件, 只要满足其一就会自动保存</p>
<ul>
<li>save <interval> <changes>: 只要在interval时间间隔内, 发生了changes次修改, 就自动保存</changes></interval></li>
</ul>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC10%E7%AB%A0%20RDB%E6%8C%81%E4%B9%85%E5%8C%96-f4952a77/2863e725_Untitled.png" alt="Untitled"></p>
<ul>
<li>saveparams表示save选项的多个条件</li>
<li>dirty统计修改次数</li>
<li>lastsave记录上次保存的时间戳</li>
</ul>
<h2 id="10-3-RDB文件结构"><a href="#10-3-RDB文件结构" class="headerlink" title="10.3 RDB文件结构"></a>10.3 RDB文件结构</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC10%E7%AB%A0%20RDB%E6%8C%81%E4%B9%85%E5%8C%96-f4952a77/f622a890_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC10%E7%AB%A0%20RDB%E6%8C%81%E4%B9%85%E5%8C%96-f4952a77/fbeeb774_Untitled.png" alt="Untitled"></p>
<ul>
<li>SELECTDB常量长1字节, 表示一个数据库数据的开始.</li>
<li>db_number表示数据库号码</li>
<li>key_value_pairs保存了数据库中所有的键值对数据, 如果键值对带有过期时间, 过期时间也会保存在一起.</li>
</ul>
<pre><code>[//]: # (column is not supported)

    ![Untitled](ec30893b_Untitled.png)

[//]: # (column is not supported)

    ![Untitled](51c0ac93_Untitled.png)
</code></pre>
<h3 id="value的编码"><a href="#value的编码" class="headerlink" title="value的编码"></a>value的编码</h3><ul>
<li><p>TYPE&#x3D;&#x3D;REDIS_RDB_TYPE_STRING, 字符串对象. 具体方式与ENCODING有关:</p>
<ul>
<li><p>REDIS_ENCODING_INT: 有ENCODING和interger两部分, 前者表示整型所占的位数</p>
</li>
<li><p>REDIS_ENCODING_RAW: 如果字符串长度小于等于20字节, value包含len和string两部分, 否则会使用LZF算法进行压缩.</p>
</li>
</ul>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC10%E7%AB%A0%20RDB%E6%8C%81%E4%B9%85%E5%8C%96-f4952a77/76ea6a75_Untitled.png" alt="Untitled"></p>
</li>
<li><p>TYPE&#x3D;&#x3D;REDIS_RDB_TYPE_LIST, 列表对象, 包括列表长度(元素个数)list_length以及列表元素, 每个列表元素包括元素长度以及元素的值</p>
</li>
<li><p>TYPE&#x3D;&#x3D;REDIS_RDB_TYPE_SET, 集合对象, 与列表对象类似, 包括set_size和集合元素.</p>
</li>
<li><p>TYPE&#x3D;&#x3D;REDIS_RDB_TYPE_HASH, 哈希表对象, </p>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC10%E7%AB%A0%20RDB%E6%8C%81%E4%B9%85%E5%8C%96-f4952a77/c563e951_Untitled.png" alt="Untitled"></p>
</li>
<li><p>TYPE&#x3D;&#x3D;REDIS_RDB_TYPE_ZSET, 有序集合对象,</p>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC10%E7%AB%A0%20RDB%E6%8C%81%E4%B9%85%E5%8C%96-f4952a77/402b1f28_Untitled.png" alt="Untitled"></p>
</li>
<li><p>TYPE&#x3D;&#x3D;REDIS_RDB_TYPE_INTSET, 整数集合对象, 先将整数集合转换为字符串对象, 然后将这个字符串对象保存到RDB文件中.</p>
</li>
<li><p>TYPE&#x3D;&#x3D;REDIS_RDB_TYPE_LIST_ZIPLIST | REDIS_RDB_TYPE_HASH_ZIPLIST | REDIS_RDB_TYPE_ZSET_ZIPLIST, 压缩列表对象, 会将压缩列表转换成一个字符串对象, 再进行保存.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第11章 AOF持久化</title>
    <url>/2023/08/25/notion-%E7%AC%AC11%E7%AB%A0%20AOF%E6%8C%81%E4%B9%85%E5%8C%96-a7da7386/</url>
    <content><![CDATA[<p>除了RDB持久化功能外, Redis还提供了AOF(Append Only File)持久化功能, 通过保存Redis服务器所执行的写命令来记录数据库状态.</p>
<h2 id="11-1-AOF持久化的实现"><a href="#11-1-AOF持久化的实现" class="headerlink" title="11.1 AOF持久化的实现"></a>11.1 AOF持久化的实现</h2><p>AOF持久化的实现分为追加, 文件写入, 文件同步三个步骤.</p>
<ul>
<li><p>命令追加: AOF持久化打开时, 服务器执行完写命令后, 会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾.</p>
</li>
<li><p>写入与同步: Redis的服务器在处理文件事件时可能会执行写命令, 所以每次结束一个事件循环之前, 都会调用flushApeendOnlyFile函数, 具体同步方案则是根据配置中的appendfsync选项有所不同(默认为everysec).</p>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC11%E7%AB%A0%20AOF%E6%8C%81%E4%B9%85%E5%8C%96-a7da7386/27629655_Untitled.png" alt="Untitled"></p>
</li>
</ul>
<h2 id="11-2-AOF文件的载入与数据还原"><a href="#11-2-AOF文件的载入与数据还原" class="headerlink" title="11.2 AOF文件的载入与数据还原"></a>11.2 AOF文件的载入与数据还原</h2><p>因为AOF文件里面包含了重建数据库所需的所有写命令, 所以服务器只要读入并重新执行一遍就可以还原数据库.</p>
<h2 id="11-3-AOF重写"><a href="#11-3-AOF重写" class="headerlink" title="11.3 AOF重写"></a>11.3 AOF重写</h2><p>为了解决AOF文件体积膨胀(不断增大)的问题, Redis提供了AOF文件重写的功能. 通过该功能, Redis服务器创建一个新的AOF文件, 能够保存相同的数据库状态(数据), 但是不会包含任何浪费空间的冗余命令, 所以新文件体积会更小.</p>
<p>为避免大量写入操作阻塞进程, AOF重写任务交给子进程完成. 另外, 为了避免数据不一致问题, Redis设置了一个AOF重写缓冲区, 当Redis服务器执行完一个写命令后, 会同时将这个写命令发送给AOF缓冲区和重写缓冲区.</p>
<p>当子进程完成AOF重写工作后, 会向父进程发送一个信号, 父进程在接到该信号后, 调用信号处理函数, 将AOF重写缓冲区的所有内容写入到新AOF文件中, 再原子地(atomic)替换现有地AOF文件.</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第12章 事件</title>
    <url>/2023/08/27/notion-%E7%AC%AC12%E7%AB%A0%20%E4%BA%8B%E4%BB%B6-dae64edf/</url>
    <content><![CDATA[<p>redis服务器是一个事件驱动程序, 包括:</p>
<ul>
<li>文件事件, 服务器与客户端的连接socket被抽象为文件事件, 通过一系列IO实现通信</li>
<li>时间事件, 要求在给定时间执行目标操作的事件.</li>
</ul>
<h2 id="12-1-文件-socket-事件"><a href="#12-1-文件-socket-事件" class="headerlink" title="12.1 文件(socket)事件"></a>12.1 文件(socket)事件</h2><p>Redis网络事件处理特点:</p>
<ul>
<li>Reactor多线程并发模式: 父进程负责监听, 当有新连接或新数据到来时通过消息队列告知子进程, 子进程负责应答, 读写数据</li>
<li>通过IO多路复用: 同时处理多个socket的IO事件</li>
</ul>
<p>文件事件处理器包含四个部分:</p>
<ol>
<li><p>套接字(socket): 对网络IO的封装</p>
</li>
<li><p>IO多路复用程序: 一个进程(线程)同时监听多个连接(socket)的文件(socket)事件</p>
</li>
<li><p>文件事件分派器: 将就绪的文件事件以队列的形式进行分派</p>
</li>
<li><p>事件处理器</p>
</li>
</ol>
<p>通常分派器和事件处理器都是阻塞的, 即只有分派的事件被对应处理器完成后才会分派下一个事件.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/27/notion-%E7%AC%AC12%E7%AB%A0%20%E4%BA%8B%E4%BB%B6-dae64edf/dc2183e3_Untitled.png" alt="Untitled"></p>
<p>Redis包装了多种IO复用底层实现, 编译时自动选择系统中性能最高的底层实现(evport&gt;epoll&gt;kqueue&gt;select)</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/27/notion-%E7%AC%AC12%E7%AB%A0%20%E4%BA%8B%E4%BB%B6-dae64edf/4d249dc3_Untitled.png" alt="Untitled"></p>
<p>事件类型与处理器:</p>
<ul>
<li>连接应答处理器(accept): 应答新客户端连接</li>
<li>命令请求处理器(readable): 接收和处理新的请求</li>
<li>命令回复处理器(writable): 将命令执行结果回复给客户端</li>
</ul>
<h2 id="12-2-时间事件"><a href="#12-2-时间事件" class="headerlink" title="12.2 时间事件"></a>12.2 时间事件</h2><p>分为两类 <strong>定时事件</strong> 和 <strong>周期性事件</strong></p>
<p>一个时间事件包括 id, 事件到达时间when和时间事件处理器timeProc</p>
<p>服务器将所有时间事件都放在一个无序列表中, 每当时间事件执行器运行时, 就会遍历查找并调用相应的事件处理器</p>
<blockquote>
<p>正常情况下, Redis服务器只使用serverCron一个时间事件, 即使是benchmark模式下, 也只使用两个时间事件. 所以无序列表不影响性能(采用惰性删除策略处理过期键, 只需要定期处理即可)</p>
</blockquote>
<p>serverCron的工作内容:</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li>
<li>清理数据库中的过期键值对。</li>
<li>关闭和清理连接失效的客户端。尝试进行AOF或RDB持久化操作。</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步。</li>
<li>如果处于集群模式，对集群进行定期同步和连接测试。</li>
</ul>
<h2 id="12-3-事件的调度与执行"><a href="#12-3-事件的调度与执行" class="headerlink" title="12.3 事件的调度与执行"></a>12.3 事件的调度与执行</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">	# 获取到达时间离当前时间最接近的时间事件 </span></span><br><span class="line"><span class="function">	time_event =</span> <span class="built_in">aeSearchNearestTimer</span>()</span><br><span class="line">	</span><br><span class="line">	# 计算最接近的时间事件距离到达还有多少毫秒 </span><br><span class="line">	remaind_ms = time_event.when - <span class="built_in">unix_ts_now</span>()</span><br><span class="line">	</span><br><span class="line">	# 如果事件已到达，那么remaind ms的值可能为负数，将它设定为O </span><br><span class="line">	<span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>: </span><br><span class="line">		remaind_ms = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	# 根据remaind ms的值，创建timeval结构 </span><br><span class="line">	timeval = <span class="built_in">create_timeval_with_ms</span>(remaind_ms)</span><br><span class="line">	</span><br><span class="line">	# 阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定</span><br><span class="line">	# 如果remaind_ms的值为O,那么aeApiPol1调用之后马上返回，不阻塞 </span><br><span class="line">	<span class="built_in">aeApiPoll</span>(timeval)</span><br><span class="line"></span><br><span class="line">	# 处理所有已产生的文件事件</span><br><span class="line">	<span class="built_in">processFileEvents</span>()</span><br><span class="line"></span><br><span class="line">	# 处理所有已到达的时间事件</span><br><span class="line">	<span class="built_in">processTimeEvents</span>()</span><br></pre></td></tr></table></figure></div>
<ul>
<li><p>aeApilPoll(timeval)为阻塞式的IO复用, 会返回事件队列</p>
<ul>
<li>如果统一事件源, 可以在一个队列中同时处理文件事件, 时间事件(甚至信号等)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
        <tag>IO复用</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>第13章 客户端</title>
    <url>/2023/08/27/notion-%E7%AC%AC13%E7%AB%A0%20%E5%AE%A2%E6%88%B7%E7%AB%AF-fe700913/</url>
    <content><![CDATA[<p>Redis服务器是典型的一对多服务器程序, Redis使用<strong>单进程单线程</strong>的方式来处理命令多客户端的请求.</p>
<h2 id="13-1-客户端属性"><a href="#13-1-客户端属性" class="headerlink" title="13.1 客户端属性"></a>13.1 客户端属性</h2><p>客户端状态保存在结构体redisClient中, 包括:</p>
<ul>
<li>客户端的套接字描述符. 伪客户端(来自AOF文件或者Lua脚本)的fd为-1, 否则为正整数</li>
<li>客户端的名字. 通过 <code>Client setname</code> 设置, 默认为空</li>
<li>客户端的标志值（flag). 通过各种常量标识客户端的角色和状态</li>
<li>指向客户端正在使用的数据库的指针，以及该数据库的号码。</li>
<li>客户端当前要执行的命令、命令的参数、命令参数的个数，以及指向命令实现函数的指针。</li>
<li>客户端的输人缓冲区和输出缓冲区。</li>
<li>客户端的复制状态信息，以及进行复制所需的数据结构。</li>
<li>客户端执行BRPOP、BLPOP等列表阻塞命令时使用的数据结构。</li>
<li>客户端的事务状态，以及执行WATCH命令时用到的数据结构。</li>
<li>客户端执行发布与订阅功能时用到的数据结构。</li>
<li>客户端的身份验证标志。0标识未通过身份验证, 用<code>AUTH</code>命令通过身份验证后值为1</li>
<li>客户端的创建时间，客户端和服务器最后一次通信的时间，以及客户端的输出缓冲区大小超出软性限制（soft limit)的时间。</li>
</ul>
<h3 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h3><p>客户端的请求保存到querybuf中后, 服务器将会分析请求内容, 得到argv和argc</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/27/notion-%E7%AC%AC13%E7%AB%A0%20%E5%AE%A2%E6%88%B7%E7%AB%AF-fe700913/0250510b_Untitled.png" alt="Untitled"></p>
<p>再根据argv[0]的值, 在命令表中查找对应的命令实现函数</p>
<h2 id="13-2-客户端的创建与关闭"><a href="#13-2-客户端的创建与关闭" class="headerlink" title="13.2 客户端的创建与关闭"></a>13.2 客户端的创建与关闭</h2><h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><p>客户端通过connect函数连接到服务器, 服务器则调用连接事件处理器, 为其创建相应的客户端状态, 并添加到clients列表的末尾.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/27/notion-%E7%AC%AC13%E7%AB%A0%20%E5%AE%A2%E6%88%B7%E7%AB%AF-fe700913/1909b8d4_Untitled.png" alt="Untitled"></p>
<h3 id="关闭客户端"><a href="#关闭客户端" class="headerlink" title="关闭客户端"></a>关闭客户端</h3><p>客户端的关闭有多种原因:</p>
<ul>
<li>如果客户端进程退出或者被杀死，那么客户端与服务器之间的网络连接将被关闭，从而造成客户端被关闭。</li>
<li>如果客户端向服务器发送了带有不符合协议格式的命令请求，那么这个客户端也会被服务器关闭。</li>
<li>如果客户端成为了CLIENT KILL命令的目标，那么它也会被关闭。</li>
<li>如果用户为服务器设置了timeout配置选项，那么当客户端的空转时间超过 timeout选项设置的值时，客户端将被关闭。不过timeout选项有一些例外情况：如果客户端是主服务器（打开了REDIS MASTER标志），从服务器（打开了 REDIS SLAVE标志)，正在被BLPOP等命令阻塞（打开了REDIS BLOCKED标志)，或者正在执行SUBSCRIBE、PSUBSCRIBE等订阅命令，那么即使客户端的空转时间超过了timeout选项的值，客户端也不会被服务器关闭。</li>
<li>如果客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1GB),那么这个客户端会被服务器关闭。如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小，那么这个客户端会被服务器关闭。</li>
</ul>
<h3 id="伪客户端"><a href="#伪客户端" class="headerlink" title="伪客户端"></a>伪客户端</h3><ul>
<li>服务器会创建负责执行Lua脚本中包含的Redis命令的伪客户端, 这个伪客户端在Redis服务器的整个生命周期都存在.</li>
<li>载入AOF文件时, 会创建用于执行AOF文件的伪客户端, 载入完成后关闭.</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第14章 服务器</title>
    <url>/2023/08/27/notion-%E7%AC%AC14%E7%AB%A0%20%E6%9C%8D%E5%8A%A1%E5%99%A8-b0fd0b68/</url>
    <content><![CDATA[<p>Rdis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。</p>
<h2 id="14-1-命令请求的执行过程"><a href="#14-1-命令请求的执行过程" class="headerlink" title="14.1 命令请求的执行过程"></a>14.1 命令请求的执行过程</h2><p>一条客户端命令如SET KEY VALUE命令从发送到收到回复共有4个步骤</p>
<ol>
<li><p>发送命令请求: 用户输入的命令转换成协议, 然后发送给服务器</p>
</li>
<li><p>读取命令请求: 服务器上的连接socket可读事件就绪, 通过命令请求处理器读取套接字中协议格式的命令请求, 并保存到输入缓冲区, 再解析协议把参数和个数保存到argv, argc, 最后调用命令执行器执行.</p>
</li>
<li><p>查找命令实现: </p>
<ol>
<li><p>根据argv[0]在命令表中查找(<strong>命令不区分大小写</strong>)对应的命令, 并保存到客户端状态的cmd属性中</p>
</li>
<li><p>进行一系列的检查, 如cmd是否为NULL, 参数个数正确? 客户端是否通过了身份验证? 检查内存占用情况等等</p>
</li>
<li><p>执行命令</p>
</li>
<li><p>执行后续工作, 如添加日志? 写入到AOF缓冲区? 传播给从服务器?等等</p>
</li>
</ol>
</li>
<li><p>将命令回复发送给客户端: 先保存到输出缓冲区, 等待socket写入事件就绪后进行发送. 客户端接收到回复后, 以可读形式打印.</p>
</li>
</ol>
<h2 id="14-2-serverCron函数"><a href="#14-2-serverCron函数" class="headerlink" title="14.2 serverCron函数"></a>14.2 serverCron函数</h2><p>该函数默认每100ms执行一次, 负责管理服务器的资源.</p>
<ul>
<li>更新服务器的时间缓存</li>
<li>更新LRU时钟</li>
<li>更新服务器每秒执行命令次数</li>
<li>更新服务器内存峰值记录</li>
<li>处理SIGTERM信号</li>
<li>管理客户端资源</li>
<li>管理数据库资源</li>
<li>执行被延迟的BGREWRITEAOF</li>
<li>检查持久化操作的运行状态</li>
<li>将AOF缓冲区中的内容写入AOF文件</li>
<li>关闭异步客户端</li>
<li>增加cronloops计数器的值</li>
</ul>
<h2 id="14-3-初始化服务器"><a href="#14-3-初始化服务器" class="headerlink" title="14.3 初始化服务器"></a>14.3 初始化服务器</h2><ol>
<li><p>初始化服务器状态结构: 设置运行ID, 运行频率, 运行架构, 默认配置文件, 端口号, 持久化条件, 初始化LRU时钟, 创建命令表</p>
</li>
<li><p>载入配置选项</p>
</li>
<li><p>初始化服务器数据结构, 如clients链表, db数组, lua环境等等</p>
</li>
<li><p>还原数据库状态(载入AOF文件或RDB文件)</p>
</li>
<li><p>执行事件循环</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第15章 复制</title>
    <url>/2023/08/28/notion-%E7%AC%AC15%E7%AB%A0%20%E5%A4%8D%E5%88%B6-dca76475/</url>
    <content><![CDATA[<p>Redis中, 用户可以通过SLAVEOF命令或者设置slaveof选项让一个服务器去复制(replicate)另一个服务器, 被复制的服务器为主服务器(master), 进行复制的服务器为从服务器(slave)</p>
<p>进行复制中的主从服务器双方数据库保存相同的数据, 称为”数据库状态一致”, 或简称”一致”</p>
<h2 id="15-1-旧版复制功能的实现"><a href="#15-1-旧版复制功能的实现" class="headerlink" title="15.1 旧版复制功能的实现"></a>15.1 旧版复制功能的实现</h2><p>Redis的复制功能分为同步(sync)和命令传播(command propagate):</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>同步操作让从服务器的数据库状态更新至主服务器当前状态. 当客户端向从服务器发送SLAVEOF命令后, 就会先执行同步操作</p>
<ol>
<li><p>从服务器向主服务器发送SYNC命令。 </p>
</li>
<li><p>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。 </p>
</li>
<li><p>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。 </p>
</li>
<li><p>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。</p>
</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/28/notion-%E7%AC%AC15%E7%AB%A0%20%E5%A4%8D%E5%88%B6-dca76475/6b1eb3ff_Untitled.png" alt="Untitled"></p>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>同步操作完成后, 仍需要命令传播来保持主从服务器的一致. 命令传播操作用于在服务器的数据库状态被修改, 导致主从服务器的数据库状态出现不一致时, 让主从服务器的数据库重新回到一致状态.</p>
<p>主服务器会将自己执行的写命令, 也就是造成主从服务器状态不一致的命令, 发送给从服务器并执行.</p>
<h2 id="15-2-旧版复制功能的缺陷"><a href="#15-2-旧版复制功能的缺陷" class="headerlink" title="15.2 旧版复制功能的缺陷"></a>15.2 旧版复制功能的缺陷</h2><p>在Redis中，从服务器对主服务器的复制可以分为以下两种情况：</p>
<ul>
<li>初次复制：从服务器以前没有复制过任何主服务器，或者从服务器当前要复制的主服务器和上一次复制的主服务器不同。</li>
<li>断线后重复制：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。</li>
</ul>
<p>旧版复制功能在断线后重复制时效率非常低. (使用的SYNC命令会重传大量冗余数据)</p>
<h2 id="15-3-新版复制功能的实现"><a href="#15-3-新版复制功能的实现" class="headerlink" title="15.3 新版复制功能的实现"></a>15.3 新版复制功能的实现</h2><p>从Redis2.8开始, 使用PSYNC代替SYNC命令实现同步, PSYNC具有两种模式:</p>
<ul>
<li>完整重同步(full resynchronization)用于处理初次复制情况</li>
<li>部分重同步(partial resynchronization)用于处理断线重复制情况, 主服务器可以将断开期间执行的写命令发送给从服务器, 从服务器只要执行这一部分命令重新实现一致.</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/28/notion-%E7%AC%AC15%E7%AB%A0%20%E5%A4%8D%E5%88%B6-dca76475/890bc105_Untitled.png" alt="Untitled"></p>
<h2 id="15-4-部分重同步的实现"><a href="#15-4-部分重同步的实现" class="headerlink" title="15.4 部分重同步的实现"></a>15.4 部分重同步的实现</h2><p>部分重同步功能由以下三个部分构成：</p>
<ul>
<li>主服务器的复制偏移量（replication offset)和从服务器的复制偏移量: 主服务器每次发送N字节数据, 就让复制偏移量加N; 从服务器每次收到N个字节的数据时, 就将自己的复制偏移量加N.</li>
<li>主服务器的复制积压缓冲区（replication backlog): 一个固定长度的FIFO队列, 保存着一部分最近传播的写命令(以及相应的偏移量)</li>
<li>服务器的运行ID（run ID): 40个随机的十六进制字符, 用于标识服务器. 从服务器重连到主服务器后, 比较之前保存的运行ID和当前主服务器运行ID, 若相同, 则部分重同步; 否则说明是不同的主服务器, 执行完整重同步操作.</li>
</ul>
<h2 id="15-5-PSYNC命令的实现"><a href="#15-5-PSYNC命令的实现" class="headerlink" title="15.5 PSYNC命令的实现"></a>15.5 PSYNC命令的实现</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/28/notion-%E7%AC%AC15%E7%AB%A0%20%E5%A4%8D%E5%88%B6-dca76475/e7efca56_Untitled.png" alt="Untitled"></p>
<h2 id="15-6-复制的实现"><a href="#15-6-复制的实现" class="headerlink" title="15.6 复制的实现"></a>15.6 复制的实现</h2><ol>
<li><p>设置主服务器的地址和端口</p>
</li>
<li><p>建立套接字连接</p>
</li>
<li><p>发送ping命令</p>
</li>
<li><p>身份验证</p>
</li>
<li><p>发送端口信息</p>
</li>
<li><p>同步</p>
</li>
<li><p>命令传播</p>
</li>
</ol>
<h2 id="15-7-心跳检测"><a href="#15-7-心跳检测" class="headerlink" title="15.7 心跳检测"></a>15.7 心跳检测</h2><p>命令传播阶段, 从服务器默认以每秒一次的频率发送 <code>REPLCONF ACK &lt;replication_offset&gt;</code></p>
<p>主要作用:</p>
<ul>
<li>检测主从服务器的网络连接状态</li>
<li>辅助实现min-slaves配置选项, 可以配置min-slaves-to-write和min-slaves-max-lag选项来防止主服务器在不安全情况(从服务器数量小于xx, 或从服务器延迟高于xxx)下执行写命令.</li>
<li>检测命令丢失</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
        <tag>一致</tag>
      </tags>
  </entry>
  <entry>
    <title>第16章 Sentinel</title>
    <url>/2023/08/28/notion-%E7%AC%AC16%E7%AB%A0%20Sentinel-2d9e38a3/</url>
    <content><![CDATA[<p>Sentinel(哨岗, 哨兵)是Redis的高可用性(high availability)解决方案: 由一个或多个Sentinel实例组成的系统可以监视任意多个主服务器及其所有从服务器, 并在主服务器下线时自动升级从服务器为新主服务器代替原先主服务器.</p>
<h2 id="16-1-启动并初始化Sentinel"><a href="#16-1-启动并初始化Sentinel" class="headerlink" title="16.1 启动并初始化Sentinel"></a>16.1 启动并初始化Sentinel</h2><p>使用命令 <code>redis-sentinel /path/to/sentinel.conf</code> 或者 <code>redis-server /path/to/sentinel.conf --sentinel</code></p>
<p>启动时的步骤:</p>
<ol>
<li><p>初始化服务器。 </p>
</li>
<li><p>将普通Redis服务器使用的代码替换成Sentinel专用代码。 </p>
</li>
<li><p>初始化Sentinel状态。 </p>
</li>
<li><p>根据给定的配置文件，初始化Sentinel的监视主服务器列表。 </p>
</li>
<li><p>创建连向主服务器的网络连接。</p>
</li>
</ol>
<h2 id="16-2-获取主服务器信息"><a href="#16-2-获取主服务器信息" class="headerlink" title="16.2 获取主服务器信息"></a>16.2 获取主服务器信息</h2><p>Sentinel默认以10秒一次的频率<strong>向主服务器发送INFO命令</strong>, 并根据回复内容获取主服务器当前信息, 包括:</p>
<ul>
<li>主服务器本身的信息, 包括run_id, 以及服务器角色</li>
<li>主服务器下所有从服务器的信息, 包括IP和端口.</li>
</ul>
<h2 id="16-3-获取从服务器信息"><a href="#16-3-获取从服务器信息" class="headerlink" title="16.3 获取从服务器信息"></a>16.3 获取从服务器信息</h2><p>当Sentinel发现主服务器有新的从服务器出现时(通过向主服务器的INFO命令), 除了为其创建实例数据结构, 还会创建连接到从服务器的命令连接和订阅连接.</p>
<p>建立命令连接后, 也会以默认10秒每次的频率向从服务器发送INFO命令, 从回复提取以下信息:</p>
<ul>
<li>从服务器的运行D run id。</li>
<li>从服务器的角色role。</li>
<li>主服务器的IP地址master_host,以及主服务器的端口号master_port。</li>
<li>主从服务器的连接状态master_link_status。</li>
<li>从服务器的优先级slave_priority</li>
<li>从服务器的复制偏移量slave_repl_offset。</li>
</ul>
<h2 id="16-4-向主服务器和从服务器发送信息"><a href="#16-4-向主服务器和从服务器发送信息" class="headerlink" title="16.4 向主服务器和从服务器发送信息"></a>16.4 向主服务器和从服务器发送信息</h2><p>Sentinel默认以每两秒一次的频率向所有被监视的主服务器和从服务器发送以下命令(信息)</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">PUBLISH sentinel:hello <span class="string">&quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span></span><br></pre></td></tr></table></figure></div>


<h2 id="16-5-接收来自主服务器和从服务器的频道信息"><a href="#16-5-接收来自主服务器和从服务器的频道信息" class="headerlink" title="16.5 接收来自主服务器和从服务器的频道信息"></a>16.5 接收来自主服务器和从服务器的频道信息</h2><p>当Sentinel与一个主服务器或者从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送以下命令： </p>
<p><code>SUBSCRIBE sentinel_:hello </code></p>
<p>Sentinel对 <code>sentinel:hello</code> 频道的订阅会一直持续到Sentinel与服务器的连接断开为止。</p>
<p>对于监视同一个服务器的多个Sentinel, 其中一个Sentinel发送的信息会被其他Sentinel接收到, 用于更新Sentinel对彼此的认知, 也会更新其他Sentinel对被监视服务器的认知(信息).</p>
<h2 id="16-6-检测主观下线状态"><a href="#16-6-检测主观下线状态" class="headerlink" title="16.6 检测主观下线状态"></a>16.6 检测主观下线状态</h2><p>Sentinel默认以每秒一次的频率向所有创建了连接的实例(主从服务器和其他Sentinel)发送PING命令, 从而检测实例是否在线.</p>
<h2 id="16-7-检查客观下线状态"><a href="#16-7-检查客观下线状态" class="headerlink" title="16.7 检查客观下线状态"></a>16.7 检查客观下线状态</h2><p>当Sentinel将一个主服务器判断为<strong>主观下线</strong>后, 为了进行确认, 会向监视该主服务器的其他Sentinel进行询问. 当从其他Sentinel接收到足够数量的已下线判断后, 就会将主服务器判定为** 客观下线** ,并进行故障转移操作.</p>
<h2 id="16-8-选举领头Sentinel"><a href="#16-8-选举领头Sentinel" class="headerlink" title="16.8 选举领头Sentinel"></a>16.8 选举领头Sentinel</h2><p>当一个主服务器被判断为客观下线后, 监视该服务器的多个Sentinel会通过协商选举出一个领头Sentinel, 由其执行故障转移.</p>
<h2 id="16-9-故障转移"><a href="#16-9-故障转移" class="headerlink" title="16.9 故障转移"></a>16.9 故障转移</h2><p>由领头Sentinel执行的故障转移操作包括三个步骤:</p>
<ol>
<li><p>在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。 </p>
</li>
<li><p>让已下线主服务器属下的所有从服务器改为复制新的主服务器。</p>
</li>
<li><p>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
        <tag>sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章 简单动态字符串</title>
    <url>/2023/08/24/notion-%E7%AC%AC2%E7%AB%A0%20%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-7992ce8b/</url>
    <content><![CDATA[<p>Rdis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串)，而是自己构建了一种名为简单动态字符串(simple dynamic string,SDS)的抽象类型，并将SDS用作Redis的默认字符串表示。</p>
<p>Redis中所有可修改的字符串值都会用SDS表示, 如键值对的键, 字符串对象, 缓冲区等等.</p>
<h2 id="2-1-SDS的定义"><a href="#2-1-SDS的定义" class="headerlink" title="2.1 SDS的定义"></a>2.1 SDS的定义</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC2%E7%AB%A0%20%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-7992ce8b/fcedaf04_Untitled.png" alt="Untitled"><br><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC2%E7%AB%A0%20%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-7992ce8b/b1782b5b_Untitled.png" alt="Untitled"></p>
<ul>
<li>SDS遵循C字符串以‘\0’结尾的惯例, 从而可以复用C字符串库中的函数</li>
<li>该空字符串既不属于len, 也不属于free</li>
</ul>
<h2 id="2-2-SDS与C字符串的区别"><a href="#2-2-SDS与C字符串的区别" class="headerlink" title="2.2 SDS与C字符串的区别"></a>2.2 SDS与C字符串的区别</h2><p>可以将SDS视为对C语言字符串的简单封装, 以满足安全性, 效率以及功能上的要求.</p>
<ul>
<li><p>获取字符串长度: O(N) → O(1)</p>
</li>
<li><p>杜绝缓冲区溢出: 在拼接操作时进行检查, 防止溢出</p>
</li>
<li><p>减少修改字符串时带来的内存重分配次数</p>
<ul>
<li><p>空间预分配: 当SDS变长后长度小于1MB, 程序将分配和len属性同样大小的未使用空间(free &#x3D;&#x3D; len); 当重分配后长度≥1MB, 会额外分配1MB的未使用空间(free&#x3D;1MB)</p>
</li>
<li><p>惰性空间释放: 需要缩短SDS时, 并不立即使用内存重分配来回收缩短后的字节, 而是使用free属性暂时记录起来, 等待将来使用. 需要真正释放未使用空间, 需要使用专用的API.</p>
</li>
</ul>
</li>
<li><p>二进制安全: SDS API是二进制安全的, 不会对其中的数据做任何限制, 过滤, 或者假设, 数据写入时是什么样, 读取时就是什么样. 因此SDS不仅可以保存文本, 还能保存二进制数据</p>
</li>
<li><p>兼容部分C字符串函数</p>
</li>
</ul>
<h2 id="2-3-SDS-API"><a href="#2-3-SDS-API" class="headerlink" title="2.3 SDS API"></a>2.3 SDS API</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC2%E7%AB%A0%20%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-7992ce8b/d05f316f_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC2%E7%AB%A0%20%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2-7992ce8b/f9318d08_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章 链表</title>
    <url>/2023/08/24/notion-%E7%AC%AC3%E7%AB%A0%20%E9%93%BE%E8%A1%A8-e2cfe5ab/</url>
    <content><![CDATA[<p>链表在Redis中应用广泛, 如列表键, 发布与订阅, 慢查询, 监视器等功能.</p>
<h2 id="3-1-链表和链表节点表示"><a href="#3-1-链表和链表节点表示" class="headerlink" title="3.1 链表和链表节点表示"></a>3.1 链表和链表节点表示</h2><p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC3%E7%AB%A0%20%E9%93%BE%E8%A1%A8-e2cfe5ab/bbc32ecd_Untitled.png" alt="Untitled"></p>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC3%E7%AB%A0%20%E9%93%BE%E8%A1%A8-e2cfe5ab/e55f516c_Untitled.png" alt="Untitled"></p>
<ul>
<li>dup函数用于复制链表节点所保存的值</li>
<li>free函数用于释放链表节点所保存的值</li>
<li>match函数用于对比链表节点所保存的值是否与输入值相等</li>
</ul>
<p>链表特点: 双向双端, 无环, 带表头和表尾指针以及长度计数器, 多态(支持不同类型的值)</p>
<h2 id="3-2-链表和链表节点的API"><a href="#3-2-链表和链表节点的API" class="headerlink" title="3.2 链表和链表节点的API"></a>3.2 链表和链表节点的API</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC3%E7%AB%A0%20%E9%93%BE%E8%A1%A8-e2cfe5ab/e6ad8747_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC3%E7%AB%A0%20%E9%93%BE%E8%A1%A8-e2cfe5ab/4d14815a_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章 字典</title>
    <url>/2023/08/24/notion-%E7%AC%AC4%E7%AB%A0%20%E5%AD%97%E5%85%B8-1d0f2603/</url>
    <content><![CDATA[<p>字典又称符号表(symbol table), 关联数组(associative array), 映射(map), 是一种用于保存键值对的数据结构. 字典中的每个键都是独一无二的.</p>
<p>Redis的数据库就是使用字典来作为底层实现的, 对数据库的增删查改操作都是构建在对字典的操作之上.</p>
<h2 id="4-1-字典的实现"><a href="#4-1-字典的实现" class="headerlink" title="4.1 字典的实现"></a>4.1 字典的实现</h2><p>Redis的字典使用哈希表作为底层实现</p>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC4%E7%AB%A0%20%E5%AD%97%E5%85%B8-1d0f2603/5cec3fd4_Untitled.png" alt="Untitled"></p>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC4%E7%AB%A0%20%E5%AD%97%E5%85%B8-1d0f2603/07a7cf8e_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC4%E7%AB%A0%20%E5%AD%97%E5%85%B8-1d0f2603/7bc4c167_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC4%E7%AB%A0%20%E5%AD%97%E5%85%B8-1d0f2603/cce28c70_Untitled.png" alt="Untitled"></p>
<ul>
<li>dictType提供了一簇用于操作特定类型键值对的函数, privdata则保存了需要传给那些类型特定函数的可选参数</li>
<li>ht属性包含两个哈希表, 一般只使用ht[0], 只有在rehash时使用ht[1]</li>
</ul>
<h2 id="4-2-哈希算法"><a href="#4-2-哈希算法" class="headerlink" title="4.2 哈希算法"></a>4.2 哈希算法</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;<span class="built_in">hashFunction</span>(key); </span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask; <span class="comment">// 使用sizemask和哈希值计算出索引值</span></span><br></pre></td></tr></table></figure></div>

<p>redis使用MurmurHash2算法来计算键的哈希值</p>
<h2 id="4-3-解决键冲突"><a href="#4-3-解决键冲突" class="headerlink" title="4.3 解决键冲突"></a>4.3 解决键冲突</h2><p>当有两个及以上的键被分配到了哈希表的同一个索引上时, 称发生了冲突(collision)</p>
<p>Redis的哈希表使用链地址法(separate chaining)来解决键冲突, 每个哈希表节点都有一个next指针, 同一个索引上的多个节点存储为单向链表.</p>
<h2 id="4-4-rehash"><a href="#4-4-rehash" class="headerlink" title="4.4 rehash"></a>4.4 rehash</h2><p>当哈希表保存的键值对数量太多或太少时, 程序需要对哈希表的大小进行相应的扩展或者收缩:</p>
<ol>
<li><p>依据ht[0].used为ht[1]分配空间, <strong>扩展时, 大小为第一个大于等于used*2的2^n; 收缩时, 大小为第一个大于等于used的2^n</strong></p>
</li>
<li><p>将ht[0]的全部键值对迁移到ht[1]</p>
</li>
<li><p>释放ht[0], 将ht[1]设置为ht[0], 并为ht[1]新建一个空白哈希表</p>
</li>
</ol>
<p>rehash的自动触发条件与负载因子有关:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负载因子 = 已保存节点数量 / 哈希表大小</span></span><br><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>服务器目前没有执行BGSAVE或BGREWRITEAOF命令, 且负载因子≥1, 自动扩展</li>
<li>正在执行BGSAVE或BGREWRITEAOF命令, 但负载因子≥ 5, 自动扩展</li>
<li>负载因子小于0.1, 自动收缩</li>
</ul>
<h2 id="4-5-渐进式rehash"><a href="#4-5-渐进式rehash" class="headerlink" title="4.5 渐进式rehash"></a>4.5 渐进式rehash</h2><p>为了避免rehash对服务器性能造成影响, 服务器不是一次性迁移所有键值对, 而是分多次, 渐进式的.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC4%E7%AB%A0%20%E5%AD%97%E5%85%B8-1d0f2603/f104e189_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>在渐进式rehash期间, 会同时使用ht[0]和ht[1]</p>
<ul>
<li><p>查找和更新操作会先查询ht[0], 没找到则再查询ht[1]</p>
</li>
<li><p>新增键值对会直接保存到ht[1]</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-6-字典API"><a href="#4-6-字典API" class="headerlink" title="4.6 字典API"></a>4.6 字典API</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC4%E7%AB%A0%20%E5%AD%97%E5%85%B8-1d0f2603/1e1c6cbb_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC4%E7%AB%A0%20%E5%AD%97%E5%85%B8-1d0f2603/9980cbad_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章 跳跃表</title>
    <url>/2023/08/24/notion-%E7%AC%AC5%E7%AB%A0%20%E8%B7%B3%E8%B7%83%E8%A1%A8-295025c7/</url>
    <content><![CDATA[<p><a class="link" href="https://www.jianshu.com/p/9d8296562806">https://www.jianshu.com/p/9d8296562806 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>跳跃表(skiplist)是一种有序数据结构, 它通过在每个节点中维持多个指向其他节点的指针, 从而达到快速访问节点的目的. 跳跃表支持平均O(logN), 最坏O(N)的节点查找复杂度, 效率可以与平衡树媲美, 而且实现比平衡树简单; 还可以使用顺序性操作来批量处理节点.</p>
<p>Redis使用跳跃表作为有序集合键的底层实现之一. 如果一个有序集合包含的元素数量比较多, 或者元素的成员是比较常的字符串时, 就会使用跳跃表.</p>
<p>除此之外, 跳跃表只被用在集群节点中作为内部数据结构.</p>
<h2 id="5-1-跳跃表的实现"><a href="#5-1-跳跃表的实现" class="headerlink" title="5.1 跳跃表的实现"></a>5.1 跳跃表的实现</h2><p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC5%E7%AB%A0%20%E8%B7%B3%E8%B7%83%E8%A1%A8-295025c7/c36b9f1e_Untitled.png" alt="Untitled"></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zskiplist</span> &#123;</span><br><span class="line"> <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">skiplistNode</span> *header, *tail;</span><br><span class="line"> <span class="comment">// 节点的数量</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line"> <span class="comment">// 层数最大的节点的层数</span></span><br><span class="line"> <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>每次创建一个新跳跃表节点时, 程序都根据幂次定律随机生成一个介于1到32之间的值作为level数组的大小, 即节点的索引级别.</p>
<ul>
<li><p>每层都有一个指向表尾方向的前进指针forward, 用于向表尾方向访问节点</p>
</li>
<li><p>层的跨度span用于记录两个节点之间的距离. <strong>跨度与遍历无关, 而是用于计算rank</strong>, 在查找过程中的跨度之和就是节点的rank</p>
</li>
</ul>
</li>
<li><p>节点的后退指针backward每次只能后退至前一个节点, (用于增删改节点时更新前置节点的span???)</p>
</li>
<li><p>节点还包含一个分值score和一个对象obj指针, obj中则保存一个SDS值. 节点保存的成员对象必须唯一, 但是分值允许相同, 节点间先比较分值, 分值相同再比较对象的字典序, 从小到大排序.</p>
</li>
</ul>
<h2 id="5-2-跳跃表API"><a href="#5-2-跳跃表API" class="headerlink" title="5.2 跳跃表API"></a>5.2 跳跃表API</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC5%E7%AB%A0%20%E8%B7%B3%E8%B7%83%E8%A1%A8-295025c7/93effb85_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章 整数集合</title>
    <url>/2023/08/24/notion-%E7%AC%AC6%E7%AB%A0%20%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88-6dbc8af8/</url>
    <content><![CDATA[<p>整数集合(intset)是集合键的底层实现之一, 当一个集合只包含整数值元素, 并且这个集合的元素数量不多时, 则使用整数集合作为底层实现.</p>
<p>整数集合的保存类型为int16_t, int32_t, int64_t的整型, <strong>集合中不会有重复元素</strong>.</p>
<h2 id="6-1-整数集合的实现"><a href="#6-1-整数集合的实现" class="headerlink" title="6.1 整数集合的实现"></a>6.1 整数集合的实现</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC6%E7%AB%A0%20%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88-6dbc8af8/43e2026d_Untitled.png" alt="Untitled"></p>
<ul>
<li>contents的采用int8_t作为底层实现, 但是整数集合中保存数据的实际类型取决于encoding</li>
<li>encoding的取值为INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</li>
</ul>
<h2 id="6-2-升级"><a href="#6-2-升级" class="headerlink" title="6.2 升级"></a>6.2 升级</h2><p>每当我们要将一个新元素添加到整数集合中, 且新元素的类型比集合现有所有元素的类型都要长时, 整数集合需要先进行升级, 才能完成添加. 具体步骤分三步:</p>
<ol>
<li><p>根据新元素的类型, 扩展整数集合底层数组的空间大小, 并为新元素分配空间</p>
</li>
<li><p>将底层数组现有的所有元素替换成新元素相同的类型, 并将转换后的元素放置到正确的位上.</p>
</li>
<li><p>将新元素添加到底层数组中</p>
</li>
</ol>
<p>假设现在要将int32_t的整数值添加到int16_t的整数集合中:</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC6%E7%AB%A0%20%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88-6dbc8af8/1f581c61_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC6%E7%AB%A0%20%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88-6dbc8af8/32055446_Untitled.png" alt="Untitled"></p>
<p>在原有底层数组的基础上扩展空间</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC6%E7%AB%A0%20%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88-6dbc8af8/7ddef56a_Untitled.png" alt="Untitled"></p>
<p>从后往前移动旧元素</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC6%E7%AB%A0%20%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88-6dbc8af8/4ac9d47d_Untitled.png" alt="Untitled"></p>
<p>添加新元素. (新元素只会出现在底层数组的最开头或者最末尾)</p>
<h2 id="6-3-升级的好处"><a href="#6-3-升级的好处" class="headerlink" title="6.3 升级的好处"></a>6.3 升级的好处</h2><ol>
<li><p>提升整数集合的灵活性: 可以随意添加不同类型地整型, 不必担心类型错误. (适配其他语言)</p>
</li>
<li><p>尽可能地节约内存</p>
</li>
</ol>
<h2 id="6-4-降级"><a href="#6-4-降级" class="headerlink" title="6.4 降级"></a>6.4 降级</h2><p>省流: 不支持捏</p>
<h2 id="6-5-整数集合API"><a href="#6-5-整数集合API" class="headerlink" title="6.5 整数集合API"></a>6.5 整数集合API</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/24/notion-%E7%AC%AC6%E7%AB%A0%20%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88-6dbc8af8/61a7367c_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章 压缩列表</title>
    <url>/2023/08/25/notion-%E7%AC%AC7%E7%AB%A0%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-4955ac0d/</url>
    <content><![CDATA[<p>压缩列表(ziplist)时列表键和哈希键地底层实现之一. 当一个列表键只包含少量列表项, 并且每个列表项要么就是小整数值, 要么就是长度比较短的字符串, 那么Redis就会使用压缩列表来做列表键的底层实现.</p>
<h2 id="7-1-压缩列表的构成"><a href="#7-1-压缩列表的构成" class="headerlink" title="7.1 压缩列表的构成"></a>7.1 压缩列表的构成</h2><p>压缩列表是Redis为了节约内存而开发的, 由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC7%E7%AB%A0%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-4955ac0d/c01f9438_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC7%E7%AB%A0%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-4955ac0d/6267ccad_Untitled.png" alt="Untitled"></p>
<h2 id="7-2-压缩列表节点的构成"><a href="#7-2-压缩列表节点的构成" class="headerlink" title="7.2 压缩列表节点的构成"></a>7.2 压缩列表节点的构成</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC7%E7%AB%A0%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-4955ac0d/a4e7067e_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>previous_entry_length属性的长度只能是1字节或5字节, 便于从后往前遍历节点:</p>
<ul>
<li><p>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。</p>
</li>
<li><p>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254)，而之后的四个字节则用于保存前一节点的长度。</p>
</li>
</ul>
</li>
<li><p>encoding属性记录了节点的数据类型以及长度:</p>
<ul>
<li><p>一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；</p>
</li>
<li><p>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；</p>
</li>
</ul>
</li>
</ul>
<h2 id="7-3-连锁更新"><a href="#7-3-连锁更新" class="headerlink" title="7.3 连锁更新"></a>7.3 连锁更新</h2><p>在压缩列表中添加或删除节点可能导致它后一个节点的previous_entry_length字节数发生变化, 而这种变化又可能导致后续节点继续发生变化, 从而导致压缩列表的连锁更新.</p>
<p>因为连锁更新在最坏的情况下需要对压缩列表执行N次空间重分配操作, 而每次空间重分配最坏复杂度为O(N), 所以连锁更新的最坏情况为O(N^2). 但是连锁更新导致性能问题的几率很低:</p>
<ul>
<li>条件严苛: 恰好有多个连续的长度介于250-253字节的节点;</li>
<li>N不大就无所谓</li>
</ul>
<h2 id="7-4-压缩列表API"><a href="#7-4-压缩列表API" class="headerlink" title="7.4 压缩列表API"></a>7.4 压缩列表API</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC7%E7%AB%A0%20%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-4955ac0d/bf22eca7_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章 对象</title>
    <url>/2023/08/25/notion-%E7%AC%AC8%E7%AB%A0%20%E5%AF%B9%E8%B1%A1-d6fbaebc/</url>
    <content><![CDATA[<p>Redis并没有直接使用SDS, 链表, 字典等数据结构来实现键值对数据库, 而是基于这些数据结构构建了一个对象系统, 包含字符串对象, 列表对象, 哈希对象, 集合对象和有序集合对象五类.</p>
<h2 id="8-1-对象的类型与编码"><a href="#8-1-对象的类型与编码" class="headerlink" title="8.1 对象的类型与编码"></a>8.1 对象的类型与编码</h2><p>每次在Redis中新建一个键值对时, 会至少创建两个对象, 分别用作键(总是字符串对象)和值</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC8%E7%AB%A0%20%E5%AF%B9%E8%B1%A1-d6fbaebc/93d79cbe_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC8%E7%AB%A0%20%E5%AF%B9%E8%B1%A1-d6fbaebc/9a2d9006_Untitled.png" alt="Untitled"></p>
<h2 id="8-2-字符串对象"><a href="#8-2-字符串对象" class="headerlink" title="8.2 字符串对象"></a>8.2 字符串对象</h2><p>字符串对象的编码可以是int, raw和embstr</p>
<ul>
<li><p>如果一个字符串保存的是可以用long表示的整数值, 那么字符串对象会将整数值保存到ptr里面(将void* 转换成long)</p>
</li>
<li><p>如果字符串长度大于32字节, 使用SDS(raw)</p>
</li>
<li><p>如果小于等于32字节, 使用embstr编码. redisObject和sdshdr保存在一块连续内存中.</p>
<ul>
<li><p>申请和释放内存时都只用调用一次相关函数(raw需要两次, 分别针对redisObject和sdshdr)</p>
</li>
<li><p>更好地利用缓存带来的优势</p>
</li>
<li><p>embstr没配备修改程序, 因此该类型是只读的, 若要做出修改, 会被转换为raw类型</p>
</li>
</ul>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC8%E7%AB%A0%20%E5%AF%B9%E8%B1%A1-d6fbaebc/e5401e4b_Untitled.png" alt="Untitled"></p>
</li>
<li><p>浮点数会被转换成字符串值进行保存.</p>
</li>
<li><p>字符串对象是Redis五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象.</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC8%E7%AB%A0%20%E5%AF%B9%E8%B1%A1-d6fbaebc/6dad69ca_Untitled.png" alt="Untitled"></p>
<h2 id="8-3-列表对象"><a href="#8-3-列表对象" class="headerlink" title="8.3 列表对象"></a>8.3 列表对象</h2><p>列表对象可以是压缩列表(ziplist)或者双端链表(linkedlist).</p>
<p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于64字节</li>
<li>列表对象保存的元素数量小于512个</li>
<li>条件的具体上限值可以在配置文件中修改</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC8%E7%AB%A0%20%E5%AF%B9%E8%B1%A1-d6fbaebc/ea2252d7_Untitled.png" alt="Untitled"></p>
<h2 id="8-4-哈希对象"><a href="#8-4-哈希对象" class="headerlink" title="8.4 哈希对象"></a>8.4 哈希对象</h2><p>哈希对象的编码可以是ziplist或者hashtable</p>
<ul>
<li>以ziplist作为底层实现的哈希对象, 会依次将键和值加入列表末尾</li>
<li>以hashtable编码的哈希对象底层通过字典进行实现, 每个键值对的键和值都是字符串对象</li>
</ul>
<p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li>
<li>哈希对象保存的键值对数量小于512个；</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC8%E7%AB%A0%20%E5%AF%B9%E8%B1%A1-d6fbaebc/ca1160ef_Untitled.png" alt="Untitled"></p>
<h2 id="8-5-集合对象"><a href="#8-5-集合对象" class="headerlink" title="8.5 集合对象"></a>8.5 集合对象</h2><p>集合对象的编码可以是intset或者hashtable</p>
<ul>
<li>使用hashtable编码的集合对象使用字典作为底层实现, 字典的每个键都是一个字符串对象, 表示一个集合元素, 而字典的值呗设置为NULL.</li>
</ul>
<p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p>
<ul>
<li>集合对象保存的所有元素都是整数值</li>
<li>集合对象保存的元素数量不超过512个</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC8%E7%AB%A0%20%E5%AF%B9%E8%B1%A1-d6fbaebc/5f941bba_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC8%E7%AB%A0%20%E5%AF%B9%E8%B1%A1-d6fbaebc/1b79f073_Untitled.png" alt="Untitled"></p>
<h2 id="8-6-有序集合对象"><a href="#8-6-有序集合对象" class="headerlink" title="8.6 有序集合对象"></a>8.6 有序集合对象</h2><p>有序集合的编码可以是ziplist或者skiplist</p>
<ul>
<li>使用ziplist作为底层实现时, 每个集合元素使用两个挨在一起的压缩列表来保存, 分别记录元素的成员和分值(score). 元素按分值从小到大排列.</li>
<li>skiplist编码的有序集合使用zset作为底层实现, 一个zset同时包含一个字典和一个跳跃表. 跳跃表按分值从小到大保存了所有集合元素, 字典则为有序集合创建了一个从成员到分值的映射, 键为成员, 值为分值. (字典和跳跃表会共享元素的成员和分值, 因此不会造成数据重复)</li>
</ul>
<p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</p>
<ul>
<li>有序集合保存的元素数量小于128个</li>
<li>有序集合保存的所有元素成员的长度都小于64字节</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC8%E7%AB%A0%20%E5%AF%B9%E8%B1%A1-d6fbaebc/3aa703aa_Untitled.png" alt="Untitled"></p>
<h2 id="8-7-类型检查与命令多态"><a href="#8-7-类型检查与命令多态" class="headerlink" title="8.7 类型检查与命令多态"></a>8.7 类型检查与命令多态</h2><ul>
<li><p>对任意类型的键均可执行的命令: DEL, EXPIRE, RENAME, TYPE, OBJECT等</p>
</li>
<li><p>只能对特定类型的键执行:</p>
<ul>
<li><p>字符串键: SET, GET, APPEND, STRLEN等</p>
</li>
<li><p>哈希键: HDEL, HSET, HGET, HLEN等</p>
</li>
<li><p>列表键: RPUSH, LPOP, LINSERT, LLEN等</p>
</li>
<li><p>集合键: SADD, SPOP, SINTER, SCARD等</p>
</li>
<li><p>有序集合键: ZADD, ZCARD, ZRANK, ZSCORE等</p>
</li>
</ul>
</li>
<li><p>在执行一个类型特定的命令前, Redis会进行检测</p>
</li>
</ul>
<h3 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h3><p>Redis还会根据对象的编码方式, 选择对应的命令实现代码. 无论具体是哪种底层实现, 都会执行命令, 因此称这样的命令是多态的.</p>
<h2 id="8-8-内存回收"><a href="#8-8-内存回收" class="headerlink" title="8.8 内存回收"></a>8.8 内存回收</h2><p>Redis为对象系统构建了一个引用计数的内存回收机制.</p>
<p>对象的引用计数信息refcount会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时，refcount &#x3D; 1</li>
<li>当对象被一个新程序使用时，refcount+1</li>
<li>当对象不再被一个程序使用时，refcount-1</li>
<li>当refcount &#x3D;&#x3D; 0时，对象所占用的内存会被释放</li>
</ul>
<h2 id="8-9-对象共享"><a href="#8-9-对象共享" class="headerlink" title="8.9 对象共享"></a>8.9 对象共享</h2><p>对象的引用计数还带有对象共享的作用.</p>
<p>Redis会在初始化服务器时, 创建一万个字符串对象, 涵盖从0-9999的所有整数值, 用作共享对象.</p>
<h2 id="8-10-对象空转时长"><a href="#8-10-对象空转时长" class="headerlink" title="8.10 对象空转时长"></a>8.10 对象空转时长</h2><p>redisObject还维护一个lru属性, 表示对象最后一次被命令程序访问的时间.</p>
<ul>
<li>可以通过 <code>OBJECT IDLETIME</code> 打印出来</li>
<li>如果服务器打开了maxmemory选项, 并且服务器的回收内存算法为volatile-lru或者allkeys-lru, 那么当占用内存超过上限时, 空转时长较高的那部分键会优先被释放.</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章 数据库</title>
    <url>/2023/08/25/notion-%E7%AC%AC9%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93-b8c4e74c/</url>
    <content><![CDATA[<p>本章将对Redis服务器的数据库实现进行详细介绍，说明服务器保存数据库的方法，客户端切换数据库的方法，数据库保存键值对的方法，以及针对数据库的添加、删除、查看、更新操作的实现方法等。除此之外，本章还会说明服务器保存键的过期时间的方法，以及服务器自动删除过期键的方法。最后，本章还会说明Redis2.8新引入的数据库通知功能的实现方法。</p>
<h2 id="9-1-服务器中的数据库"><a href="#9-1-服务器中的数据库" class="headerlink" title="9.1 服务器中的数据库"></a>9.1 服务器中的数据库</h2><p>Redis服务器将所有数据库都保存在服务器状态redis.h&#x2F;redisServer结构的db数组中</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC9%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93-b8c4e74c/21a740a3_Untitled.png" alt="Untitled"></p>
<h2 id="9-2-切换数据库"><a href="#9-2-切换数据库" class="headerlink" title="9.2 切换数据库"></a>9.2 切换数据库</h2><p>每个Redis客户端都有自己的目标数据库, 默认为0号数据库, 可以通过SELECT命令进行切换.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC9%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93-b8c4e74c/607f8e72_Untitled.png" alt="Untitled"></p>
<h2 id="9-3-数据库键空间"><a href="#9-3-数据库键空间" class="headerlink" title="9.3 数据库键空间"></a>9.3 数据库键空间</h2><p>Redis是一个键值对(key-value pair)数据库服务器，服务器中的每个数据库都由一个redis.h&#x2F;redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间(key space)键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li>
</ul>
<p>键空间命令:</p>
<ul>
<li>增删改查: SET, DEL, SET, GET</li>
<li>其他操作: FLUSHDB, RANDOMKEY, DBSIZE, EXISTS, RENAME, KEYS等等</li>
</ul>
<h2 id="9-4-设置键的生存时间或过期时间"><a href="#9-4-设置键的生存时间或过期时间" class="headerlink" title="9.4 设置键的生存时间或过期时间"></a>9.4 设置键的生存时间或过期时间</h2><ul>
<li><p>设置生存时间间隔: EXPIRE(以秒为单位), PEXPIRE(ms)</p>
</li>
<li><p>设计过期时间节点: EXPIREAT(以秒为单位, UNIX时间戳), PEXPIREAT(ms)</p>
<ul>
<li>上诉4个命令实际上都由PEXPIREAT转换实现, redisDb维护一个expires字典, 保存了数据库中所有键(不包含没设置过期时间)的过期时间.</li>
</ul>
</li>
<li><p>移除过期时间: PERSIST, PEXPIREAT的反操作,</p>
</li>
<li><p>计算剩余生存时间: TTL(秒), PTTL(ms)</p>
</li>
</ul>
<h2 id="9-5-过期键删除策略"><a href="#9-5-过期键删除策略" class="headerlink" title="9.5 过期键删除策略"></a>9.5 过期键删除策略</h2><ul>
<li>定时删除: 使用定时器, 保证尽快删除过期的对象, 从而释放内存. 但是对CPU不友好, 可能对CPU的响应时间和吞吐量造成影响.</li>
<li>惰性删除: 程序只在取出键时才对键进行过期检查, 保证删除过期键的操作指挥在非做不可得情况下进行, 并且删除的目标仅限于当前处理的键. 但是这对内存不友好, 有些过期键可能长期存在于内存中, 占用内存.</li>
<li>定期删除: 结合上述两个策略, 每隔一段时间执行一次删除过期键操作.</li>
</ul>
<h2 id="9-6-Redis的过期键删除策略"><a href="#9-6-Redis的过期键删除策略" class="headerlink" title="9.6 Redis的过期键删除策略"></a>9.6 Redis的过期键删除策略</h2><ul>
<li>惰性删除策略实现: 在所有命令执行前对输入键进行检查, 若过期则删除.</li>
<li>定期删除策略实现: 在规定时间内, 分多次遍历服务器的各个数据库, 随机检查一部分键的过期时间, 并删除其中的过期键.</li>
</ul>
<h2 id="9-7-AOF-RDB和复制功能对过期键的处理"><a href="#9-7-AOF-RDB和复制功能对过期键的处理" class="headerlink" title="9.7 AOF, RDB和复制功能对过期键的处理"></a>9.7 AOF, RDB和复制功能对过期键的处理</h2><p>RDB持久化功能, AOF持久化功能以及复制功能处理过期键的方式</p>
<ul>
<li><p>生成RDB文件时(SAVE, BGSAVE), 对键进行检查, 若过期则不保存.</p>
</li>
<li><p>载入RDB文件时, 若为主服务器模式, 对键进行检查, 若过期则不载入; 若为从服务器模式, 全部载入数据库中, 但是主从服务器进行数据同步时会先清空数据库, 所以影响不大.</p>
</li>
<li><p>AOF文件写入: 如果过期键还没被删除, 则没有任何影响; 如果以及被删除, 则会像AOF文件追加一条DEL命令</p>
</li>
<li><p>AOF重写: 会对键进行检查, 已过期的键不会保存.</p>
</li>
<li><p>复制: 服务器的过期键删除动作由主服务器控制</p>
<ul>
<li><p>主服务器删除一个过期键后, 会显式地向所有从服务器发送一条DEL</p>
</li>
<li><p>从服务器不主动处理过期键, 只有收到主服务器地DEL命令后, 才会删除过期键</p>
</li>
</ul>
</li>
</ul>
<h2 id="9-8-数据库通知"><a href="#9-8-数据库通知" class="headerlink" title="9.8 数据库通知"></a>9.8 数据库通知</h2><p>客户端可以通过订阅给定地频道或者模式, 来获取数据库中键的变化以及命令执行情况.</p>
<ul>
<li>键空间通知: 跟踪键, 其键执行了什么命令</li>
<li>键事件通知: 跟踪命令, 该命令被哪些键执行</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/25/notion-%E7%AC%AC9%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%BA%93-b8c4e74c/41ce1cf4_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Redis设计与实现》</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 TCP/IP协议族</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E4%B8%80%E7%AB%A0%20TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F-4ef1f319/</url>
    <content><![CDATA[<h2 id="1-1-体系结构与主要协议族"><a href="#1-1-体系结构与主要协议族" class="headerlink" title="1.1 体系结构与主要协议族"></a>1.1 体系结构与主要协议族</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%80%E7%AB%A0%20TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F-4ef1f319/7383d780_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%80%E7%AB%A0%20TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F-4ef1f319/1e332d0b_Untitled.png" alt="Untitled"></p>
<ul>
<li>封装: 上层协议基于下层协议实现, 但上层协议不关注下层的实现细节</li>
<li>链路层, 网络层, 传输层负责网络通信细节, 要求可靠, 稳定和高效, 因此往往在内核中实现</li>
</ul>
<h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><ul>
<li>使用物理(MAC)地址寻址机器</li>
<li>通过ARP和RARP实现IP地址和MAC地址的相互转换</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li><p>实现数据包的选址和转发</p>
</li>
<li><p>IP协议: 用于表达数据包的源头和目标, 路由器通过IP地址进行转发</p>
</li>
<li><p>ICMP协议对IP协议进行补充, 包含差错报文和查询报文</p>
<ul>
<li>ICMP基于IP协议实现</li>
</ul>
</li>
</ul>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul>
<li>实现端到端的通信, 只在乎通信的起始段和目的端, 而不在乎数据中转的过程; 因此, 网络的中间节点(路由器)不包含传输层协议</li>
<li>TCP协议提供可靠的, 面向连接和基于流的服务.</li>
<li>UDP协议提供不可靠的, 不面向连接和基于数据报的服务</li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul>
<li>通常在用户空间实现, 可以实现各种复杂的功能</li>
<li>包含各种各样用途的协议, 如HTTP, DNS, telnet, FTP, 以及应用程序, 如ping.</li>
</ul>
<h2 id="1-2-1-3-封装和分用"><a href="#1-2-1-3-封装和分用" class="headerlink" title="1.2, 1.3 封装和分用"></a>1.2, 1.3 封装和分用</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%80%E7%AB%A0%20TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F-4ef1f319/21693edf_Untitled.png" alt="Untitled"></p>
<ul>
<li>封装: 发送数据时, 数据自顶向下层层包装, 最后发出</li>
<li>分用: 接受到数据时, 数据自底向上层层解析, 不断交给指定的协议和目标程序</li>
</ul>
<h2 id="1-6-DNS协议"><a href="#1-6-DNS协议" class="headerlink" title="1.6 DNS协议"></a>1.6 DNS协议</h2><p>常用类型:</p>
<ul>
<li>类型A, 值为1: 查询目标主机的IP</li>
<li>类型CNAME, 值为5: 查询目标主机的别名</li>
<li>类型PTR, 值为12: 反向查询(IP → 域名)</li>
</ul>
<p> 主机dns服务器存在 <code>/etc/resolv.conf</code> 中, 使用host命令与DNS服务器通信 <code>host -t A baidu.com</code>, 可以使用tcpdump进行抓包</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%80%E7%AB%A0%20TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F-4ef1f319/0d89dd13_Untitled.png" alt="Untitled"></p>
<h2 id="1-7-socket与TCP-x2F-IP协议族的关系"><a href="#1-7-socket与TCP-x2F-IP协议族的关系" class="headerlink" title="1.7 socket与TCP&#x2F;IP协议族的关系"></a>1.7 socket与TCP&#x2F;IP协议族的关系</h2><ul>
<li>传输层, 网络层, 链路层的实现在内核当中, 因此OS需要提供一组系统调用以便应用程序使用服务, 现在最常用的便是socket. socket的主要功能为</li>
</ul>
<ol>
<li><p>将应用程序数据从用户缓存区复制到内核发送缓存区, 以交付内核进行数据传输</p>
</li>
<li><p>应用程序可以精细化地修改各层协议的具体格式和内容, 从而控制底层数据传输行为</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>计网</tag>
        <tag>TCP</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 Linux服务器程序规范</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83-4e5cab6a/</url>
    <content><![CDATA[<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83-4e5cab6a/1b7d86ab_Untitled.png" alt="Untitled"></p>
<h2 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h2><h3 id="Linux系统日志"><a href="#Linux系统日志" class="headerlink" title="Linux系统日志"></a>Linux系统日志</h3><ul>
<li>Linux提供一个守护进程syslogd来处理系统日志, 不过现在都用的都是升级版rsyslogd</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span>* message, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ident, <span class="type">int</span> logopt, <span class="type">int</span> facility)</span></span>; <span class="comment">// 修改syslog的默认输出方式</span></span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83-4e5cab6a/f27f9fc3_Untitled.png" alt="Untitled"></p>
<ul>
<li>rsyslogd既能接收用户进程输出的日志, 又能接收内核日志. syslog函数将日志输出到一个UNIX本地域socket类型(AF_UNIX)的文件&#x2F;dev&#x2F;log中, rsyslogd则监听该文件以获取用户进程的输出.</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83-4e5cab6a/9d5fcd2c_Untitled.png" alt="Untitled"></p>
<h2 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h2><ul>
<li>UID 真实用户ID: 程序的执行用户</li>
<li>EUID 有效用户ID: 程序访问资源时的用户权限</li>
<li>GID 真实组ID</li>
<li>EGID 有效组ID</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83-4e5cab6a/542b2b8a_Untitled.png" alt="Untitled"></p>
<h2 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>Linux下每个程序都隶属于一个程序组, 因此除了PID信息, 还有进程组ID - PGID; 每个进程组都有一个首领进程, 其PGID和PID相同.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>一些有关联的进程组将形成一个会话(session)</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="type">void</span>)</span></span>; </span><br></pre></td></tr></table></figure></div>

<p>setsid不仅创建新会话, 还有如下效果</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83-4e5cab6a/ea69b5c8_Untitled.png" alt="Untitled"></p>
<h2 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit* rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit* rlim)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83-4e5cab6a/a65c8513_Untitled.png" alt="Untitled"></p>
<h2 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getcwd</span><span class="params">(<span class="type">char</span>* buf, <span class="type">size_t</span> size)</span></span>; <span class="comment">// 获取当前工作目录</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>; <span class="comment">// 修改工作目录</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>; <span class="comment">// 修改根目录</span></span><br></pre></td></tr></table></figure></div>

<h2 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">daemon</span><span class="params">(<span class="type">int</span> nochdir, <span class="type">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>nochdir参数用于指定是否改变工作目录，如果给它传递0，则工作目录将被设置为“&#x2F;”（根目录），否则继续使用当前工作目录.</li>
<li>noclose参数为0时，标准输入、标准输出和标准错误输出都被重定向到&#x2F;dev&#x2F;null文件，否则依然使用原来的设备</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 类</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/</url>
    <content><![CDATA[<h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul>
<li>类的思想</li>
<li>各种成员函数类型</li>
<li>类的作用域</li>
</ul>
<p>设计类的目的：数据抽象和封装</p>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><ul>
<li><p>定义在类内部的函数是隐式的inline函数</p>
</li>
<li><p>成员函数通过名为 <code>this</code>的隐式形参来访问调用这个函数的对象</p>
</li>
<li><p>成员函数的参数列表之后可以跟一个const，表示该成员函数是常量成员函数，即调用该函数时的 <code>this</code> 是指向常量对象的常量指针（默认是指向非常量的常量指针）</p>
<ul>
<li>常量对象，以及常量对象的指针和引用，只能调用常量成员函数</li>
</ul>
</li>
</ul>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><ul>
<li>当且仅当类没有声明任何构造函数时，编译器才会为类自动生成默认构造函数</li>
<li><code>=default</code>显式地要求编译器声明默认构造函数</li>
<li>形参列表之后可以通过冒号和构造函数初始值列表，来为新对象中的一些成员变量赋初值</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/d749827c_Untitled.png" alt="Untitled"></p>
<ul>
<li>在初始值列表中进行初始化和赋值初始化是不同的</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/a8b6405e_Untitled.png" alt="Untitled"></p>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/c5c0a34b_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>数据的初始化顺序，与类中这些成员的声明顺序有关，与列表中的顺序无关</p>
<ul>
<li>因此最好让初始值列表的成员顺序与类中的声明顺序一致，否则互相调用的成员初始化可能会出错</li>
</ul>
</li>
<li><p>C++11新增委托构造函数，即使用其他构造函数执行自己的初始化过程，但是它的初始值列表只有一个入口，即类名本身</p>
<ul>
<li>会先执行被委托的构造函数体，再执行委托者的构造函数体</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/e8af24e8_Untitled.png" alt="Untitled"></p>
<ul>
<li>默认构造函数的使用情况</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/378a0e93_Untitled.png" alt="Untitled"></p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/02dea02c_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>struct和class都能用来声明类，只是两者的默认权限不一样</p>
<ul>
<li><p>默认访问权限对出现在第一个权限声明符（ <code>private:</code>or <code>public:</code> ）之前的成员生效</p>
</li>
<li><p>struct默认public，class默认private</p>
</li>
</ul>
</li>
<li><p>可以在类内部声明友元，从而允许访问私有的成员或函数（友元只是声明了权限，类外部必须再次声明函数）</p>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/86fb47d7_Untitled.png" alt="Untitled"></p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><ul>
<li>定义一个类型成员</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/b66171b6_Untitled.png" alt="Untitled"></p>
<ul>
<li>使用mutable关键字，可以使得const对象的该成员可以被修改</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/c9c8391f_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>返回调用对象的引用：return *this；这样就可以连续调用成员函数了（有java那味儿了）</p>
</li>
<li><p>注：非常量版本的成员函数对常量对象是不可用的；常量对象return *this的结果还是常量对象</p>
</li>
<li><p>类的类型转换：类的构造函数（只有一个<strong>实参</strong>）隐式地定义了类型转换的方式。注：编译器只会执行一步类型转换</p>
<ul>
<li>可以使用explicit来阻止这种隐式转换</li>
</ul>
</li>
<li><p>字面值常量类：</p>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E7%B1%BB-1facc976/e3e14ffa_Untitled.png" alt="Untitled"></p>
<h2 id="类的作用域-1"><a href="#类的作用域-1" class="headerlink" title="类的作用域"></a>类的作用域</h2><ul>
<li>一个类就是一个作用域</li>
<li>名字匹配的顺序依旧是由内而外</li>
<li>当发生目标变量被隐藏的情况时，可以用this访问对象的成员，用::表明作用域访问类外部（全局）的变量</li>
</ul>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><ul>
<li><p>静态成员，表明该成员直接与类相关，而不是和每个对象相关，关键词为static</p>
<ul>
<li><p>类的静态成员数据存在于任何对象之外，只是表示数据的从属关系</p>
<ul>
<li>但是仍然可以通过对象（包括指针和引用）来访问静态成员（只要该成员为public）</li>
</ul>
</li>
<li><p>静态成员函数也不与任何对象绑定，因此函数内不可使用this指针，也不能被声明为const</p>
</li>
</ul>
</li>
<li><p>可以直接通过类名（作用域）来访问静态成员</p>
</li>
<li><p>静态成员可以作为函数的默认实参</p>
</li>
<li><p>静态成员可以是不完全类型（还未完全定义的类），如在一个类内声明自己</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>class</tag>
        <tag>《C++ Primer》</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 TCP协议详解</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-c14662ea/</url>
    <content><![CDATA[<h2 id="3-1-TCP服务的特点"><a href="#3-1-TCP服务的特点" class="headerlink" title="3.1 TCP服务的特点"></a>3.1 TCP服务的特点</h2><ul>
<li>面向连接: 通信双方必须先建立连接才能进行通信</li>
<li>字节流: 与UDP的基于数据报不同, 应用程序对数据的发送和接收没有边界限制. 具体来讲, 发送端和接收方各自维护缓存区, 两端执行的读写操作没有数量关系.</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-c14662ea/4f4dfe1d_Untitled.png" alt="Untitled"></p>
<ul>
<li>可靠传输: 采用应答机制和超时重传机制, 保证数据被接收方收到.</li>
</ul>
<h2 id="3-2-TCP头部"><a href="#3-2-TCP头部" class="headerlink" title="3.2 TCP头部"></a>3.2 TCP头部</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-c14662ea/62087c76_Untitled.png" alt="Untitled"></p>
<ul>
<li>序号: 报文段中携带数据的编号, 具体值为ISN(初始序号值) + 数据部分第一字节在字节流中的偏移</li>
<li>确认号: 用于确认对数据的接收, 其值为收到的报文段序号的值+1</li>
<li>头部长度: 以4字节为单位, 因此头部最长为(2^4 - 1) * 4 &#x3D; 60 字节</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-c14662ea/016f3fef_Untitled.png" alt="Untitled"></p>
<ul>
<li>窗口大小: RWND接收窗口的大小, 用于进行流量控制</li>
<li>校验和: 采用CRC算法对整个TCP报文段进行校验</li>
<li>紧急指针: 也可称为紧急偏移, 是一个正的偏移量, 与序号相加表示紧急数据结束的位置(紧急数据最后一字节的下一字节序号)</li>
</ul>
<h2 id="3-3-TCP连接的建立与关闭"><a href="#3-3-TCP连接的建立与关闭" class="headerlink" title="3.3 TCP连接的建立与关闭"></a>3.3 TCP连接的建立与关闭</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-c14662ea/ece03263_Untitled.png" alt="Untitled"></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol>
<li><p>同步报文段发起连接: 主机A发送带有<code>SYN标志和A端初始序号</code> 的报文段到主机B</p>
</li>
<li><p>同步报文段同意连接: 主机B接收后返回带有 <code>SYN标志, B端初始序号以及确认号</code> 的报文段到主机A</p>
</li>
<li><p>确认第二个同步报文段: 主机A向主机B发送第二个同步报文段的确认报文段</p>
</li>
</ol>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol>
<li><p>第一个结束报文段: 主机A发送带有FIN标志的结束报文段</p>
</li>
<li><p>主机B确认第一个结束报文段</p>
</li>
<li><p>第二个结束报文段: 主机B发送带有FIN标志的结束报文段</p>
</li>
<li><p>主机A确认第二个结束报文段</p>
</li>
</ol>
<p>注:</p>
<ul>
<li><p>服务端和客户端都可以主动结束连接</p>
</li>
<li><p>第一个确认报文段的必要性:</p>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h3><p>TCP连接是全双工的, 双方都可以接发数据. 双方也都可以主动发送结束报文段表示数据发送结束, 但另一方依旧可以继续发送数据(以及接受确认报文段), 直至另一方也发送结束报文段结束TCP连接, 这种状态就是半关闭状态. 不过, 使用半关闭状态的程序比较少见.</p>
<h3 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h3><p>建立连接时, 若发起方未收到确认报文段, 则会先尝试多次重连. 发送间隔为2^n, 即1s, 2s, 4s, 8s, 16s…. 具体重连次数由内核定义.</p>
<h2 id="3-4-状态转移"><a href="#3-4-状态转移" class="headerlink" title="3.4 状态转移"></a>3.4 状态转移</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-c14662ea/d6a2ec8a_Untitled.png" alt="Untitled"></p>
<p>粗虚线表示典型的服务端连接的状态转移; 粗实线表示典型的客户端连接的状态转移.</p>
<p>补充:</p>
<ul>
<li><p>正常的由客户端发起的四次挥手是 ESTABLISHED→ FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT; FIN_WAIT_1状态时, 服务端的状态时CLOSE_WAIT; FIN_WAIT_2 相当于半关闭状态.</p>
<ul>
<li><p>若FIN_WAIT_1状态的客户端直接收到带有ACK信息的结束报文段 (不进行第二次挥手而直接第三次挥手), 则可直接转到TIME_WAIT状态</p>
</li>
<li><p>同时关闭: 客户端主动关闭连接进入到FIN_WAIT_1后, 也收到了服务端的主动关闭连接报文段, 则发送ACK报文段, 然后进入CLOSING, 收到ACK后也转移到TIME_WAIT</p>
</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-c14662ea/089db006_Untitled.png" alt="Untitled"></p>
<p>TIME_WAIT状态的意义:</p>
<ol>
<li><p>可靠地结束TCP连接: 要保证 第四次挥手的确认报文段能够被对方接收</p>
</li>
<li><p>保证让迟来的TCP报文段有足够的时间被识别和丢弃: 让应用程序保持对端口的占用, 避免在连接完全结束前被其他应用程序使用.</p>
</li>
</ol>
<h2 id="3-5-复位报文段"><a href="#3-5-复位报文段" class="headerlink" title="3.5 复位报文段"></a>3.5 复位报文段</h2><p>某些情况下, TCP一端会向另一端发送带有RST标志的复位报文段, 以通知对方关闭或重新建立连接:</p>
<ul>
<li>访问不存在的端口(或该端口仍被处于TIME_WAIT状态的连接占用): 第一次握手指向的端口不存在, 则返回一个带有 <code>RST标志, 接收窗口为0</code> 的确认报文段</li>
<li>异常终止连接: 发送复位报文段后, 发送端所有等待发送的数据将被丢弃</li>
<li>处理半打开连接: 当一端系统关闭或异常终止连接, 而另一端没有接收到结束报文段, 则另一端处于半打开状态. 若此时另一端继续尝试往这个半打开状态的连接写入数据, 则对方会回应一个复位报文段</li>
</ul>
<h2 id="3-6-TCP交互数据流"><a href="#3-6-TCP交互数据流" class="headerlink" title="3.6 TCP交互数据流"></a>3.6 TCP交互数据流</h2><p>TCP报文段根据携带数据长度分为 <code>交互数据</code> 和 <code>成块数据</code></p>
<ul>
<li><p>交互数据仅包含很少的字节, 对实时性要求高, 如ssh, telnet</p>
</li>
<li><p>成块数据的长度通常为TCP报文段允许的最大数据长度, 对传输效率高, 如ftp</p>
<ul>
<li>当发送大量大块数据时, 发送方会连续发送多个TCP报文段</li>
</ul>
</li>
</ul>
<h2 id="3-8-带外数据"><a href="#3-8-带外数据" class="headerlink" title="3.8 带外数据??????"></a>3.8 带外数据??????</h2><p>有些传输层协议具有带外(Out Of Band, OOB)数据的概念, 用于迅速通告对方本段发生的重要事件. 因此带外数据比普通数据有更高的优先级, 总是被立即发送.</p>
<ul>
<li>UDP没有实现带外数据传输;</li>
<li>而TCP利用头部的紧急指针标志 <code>URG</code> 和紧急指针来模拟</li>
</ul>
<h2 id="3-9-TCP超时重传"><a href="#3-9-TCP超时重传" class="headerlink" title="3.9 TCP超时重传"></a>3.9 TCP超时重传</h2><p>TCP模块为每个TCP报文段都维护了一个重传定时器, 当超过时间未收到确认报文段, 则重新发送报文段, 每次重传超时时间都会增加一倍, 直至放弃连接.</p>
<h2 id="3-10-拥塞控制"><a href="#3-10-拥塞控制" class="headerlink" title="3.10 拥塞控制"></a>3.10 拥塞控制</h2><p>拥塞控制能够提高网络利用率, 包含四个部分:</p>
<ol>
<li><p>慢启动</p>
</li>
<li><p>拥塞避免</p>
</li>
<li><p>快速启动</p>
</li>
<li><p>快速恢复</p>
</li>
</ol>
<ul>
<li>拥塞控制的最终受控变量是发送窗口(SWND)即发送端向网络一次连续写入的数据量(报文段数量)</li>
<li>为了实现拥塞控制, 发送端引入一个拥塞窗口(CWND)的状态变量. 实际的SWND是RWND和CWND的较小值</li>
</ul>
<h3 id="慢启动和拥塞避免"><a href="#慢启动和拥塞避免" class="headerlink" title="慢启动和拥塞避免"></a>慢启动和拥塞避免</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-c14662ea/e9ed87f7_Untitled.png" alt="Untitled"></p>
<ul>
<li>慢启动: 每接收到一个报文段的确认, 就CWND增加一个该报文段的数据大小</li>
<li>慢启动使得CWND能够指数型增加, 但这很可能导致网络拥塞, 因此TCP还定义了一个重要的状态变量 - 慢启动门限, 当CWND超过该值时, 进入拥塞避免状态.</li>
<li>拥塞避免状态使得CWND能够线性增加, 有如下两种实现方式:</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-c14662ea/7578dc1d_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>法一是根据时间线性增加</p>
</li>
<li><p>法二的公式等价于$ \frac{SMSS}{CWND&#x2F;SMSS} $, 可以近似理解为, 收到当前所有发出的报文段才使CWND+1个SMSS</p>
</li>
</ul>
<p>拥塞的发生包含两种情况:</p>
<ol>
<li>传输超时, 即TCP重传定时器溢出 → 慢启动和拥塞避免</li>
</ol>
<blockquote>
<p>此时, 更新状态变量: $ ssthresh &#x3D;max(FlightSize &#x2F; 2, 2*SMSS)  $, $ CWND&lt;&#x3D; SMSS $</p>
</blockquote>
<ol>
<li>接收到重复的确认报文段 → 快速重传和快速恢复</li>
</ol>
<blockquote>
<p>如果该情况发生在传输超时之后, 则也被当做第一种情况对待.</p>
</blockquote>
<h3 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-c14662ea/e5148b76_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>计网</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 字符串，向量和数组</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/</url>
    <content><![CDATA[<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul>
<li>cin&gt;&gt;str的返回值还是std::cin，若读入eof，则返回值为空，因此有</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/564e868f_Untitled.png" alt="Untitled"></p>
<ul>
<li>刷题的时候经常遇到，得用一个getchar()把回车先读进来</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/bb1eae51_Untitled.png" alt="Untitled"></p>
<ul>
<li>string对象的比较规则</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/c60e0411_Untitled.png" alt="Untitled"></p>
<ul>
<li>c++新增遍历元素的for，若想改变遍历的对象，采用引用即可</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/6e22b286_Untitled.png" alt="Untitled"></p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>初始化时采用(), {}的区别巨大</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/2373ba82_Untitled.png" alt="Untitled"></p>
<ul>
<li>注意下标，不能越界；</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/741b2659_Untitled.png" alt="Untitled"></p>
<ul>
<li>vector可以采用push_back来添加元素</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>end指向尾元素的后一个位置，即容器中不存在的尾后元素</li>
<li>迭代器可以进行解运算和加减运算</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>声明形式为type name[sz]，其中sz为constexp，与vector的最大区别是定长</li>
<li>由内向外理解声明</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/4b5ca743_Untitled.png" alt="Untitled"></p>
<ul>
<li>数组的取别名</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/db571c1f_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>不允许使用一个数组初始化另一个数组</p>
</li>
<li><p>数组与指针：一些情况下，数组的操作，实际上就是指针的操作</p>
<ul>
<li><p>编译器会把用到数组名字的地方，换成指向数组首元素的指针</p>
</li>
<li><p>decltype中用到数组名字时，不会换成指针</p>
</li>
<li><p>指针也是迭代器</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/568c9473_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>C++11新增begin和end函数（iterator头文件中），获取数组的首元素指针和尾后指针</p>
</li>
<li><p>指针之间可以进行类似迭代器的加减运算</p>
</li>
<li><p>arr[i]等价于*(arr + i)</p>
</li>
</ul>
</li>
<li><p>string s.c_str()方法先前的返回值可能会因为字符串s的变化而失效，因此建议备份而不只是用一个指针来记录</p>
</li>
<li><p>多维数组初始化：</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/1e71277e_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/7c24e556_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/5eca35fb_Untitled.png" alt="Untitled"></p>
<ul>
<li>C++新增范围for语句，可以用来调用多维数组，外层要用引用，避免数组对象被替换为指针</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/0894b3be_Untitled.png" alt="Untitled"></p>
<ul>
<li>也可以使用begin，end函数来实现循环便利</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84-2377ea53/b007b7af_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《C++ Primer》</tag>
      </tags>
  </entry>
  <entry>
    <title>第九章 IO复用</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/</url>
    <content><![CDATA[<p>IO复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要。通常，网络程序在下列情况下需要使用&#x2F;O复用技术：</p>
<ul>
<li>客户端程序要同时处理多个socket。.比如本章将要讨论的非阻塞connect技术。</li>
<li>客户端程序要同时处理用户输入和网络连接。比如本章将要讨论的聊天室程序。</li>
<li>TCP服务器要同时处理监听socket和连接socket。这是I&#x2F;O复用使用最多的场合。后续章节将展示很多这方面的例子。</li>
<li>服务器要同时处理TCP请求和UDP请求。比如本章将要讨论的回射服务器。</li>
<li>服务器要同时监听多个端口，或者处理多种服务。比如本章将要讨论的xinetd服务器。</li>
</ul>
<blockquote>
<p>需要指出的是，&#x2F;O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。</p>
</blockquote>
<h2 id="9-1-select系统调用"><a href="#9-1-select系统调用" class="headerlink" title="9.1 select系统调用"></a>9.1 select系统调用</h2><p>select系统调用的用途是: 在一段指定时间内, 监听用户感兴趣的文件描述符上的可读, 可写和异常等事件.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">struct</span> timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>nfds 监听的文件描述符总数</p>
</li>
<li><p>readfds, writefds, exceptfds分别指向可读, 可写和异常事件对应的文件描述符集合. select调用返回时, 内核将修改他们来通知应用程序哪些文件描述符已经就绪.</p>
<ul>
<li>fd_set结构体仅包含一个整型数组, 该数组的每个元素的每一位标记一个文件描述符</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于位操作过于烦琐, 可以使用一系列宏简化</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(fd_set *fdset );  <span class="comment">/*清除fdset的所有位*/</span></span><br><span class="line"><span class="built_in">FD_SET</span>(<span class="type">int</span> fd, fd_set *fdset );  <span class="comment">/*设置fdset的位fd*/</span></span><br><span class="line"><span class="built_in">FD_CLR</span>(<span class="type">int</span> fd, fd_set *fdset );  <span class="comment">/*清除fdset的位fd*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set*fdset)</span></span>;  <span class="comment">/*测试fdset的位fd是否被设置*/</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>timeout可以设置超时时间(精确到微秒). 如果传入NULL, 则select将一直阻塞, 知道某个文件描述符就绪.</li>
<li>select成功时返回就绪（可读、可写和异常）文件描述符的总数。如果在超时时间内没有任何文件描述符就绪，select将返回0。select失败时返回-l并设置errno。如果在select等待期间，程序接收到信号，则select立即返回-1, 并设置errno为EINTR。</li>
</ul>
<h3 id="文件描述符就绪条件"><a href="#文件描述符就绪条件" class="headerlink" title="文件描述符就绪条件"></a>文件描述符就绪条件</h3><p>可读:</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/cf5f5b47_Untitled.png" alt="Untitled"></p>
<p>可写:</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/b5be4a83_Untitled.png" alt="Untitled"></p>
<h3 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h3><p>socket收到带外数据也将使select返回, 不同于接收到普通数据的socket, 前者处于异常状态</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于接收普通数据的就绪socket</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(connfd, &amp;read_fds))&#123;</span><br><span class="line"> ret = <span class="built_in">recv</span>(connfd, buf, <span class="built_in">sizeof</span>(buf)<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于接收带外数据的就绪socket</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(connfd, &amp;exception_fds)) &#123;</span><br><span class="line"> ret = <span class="built_in">recv</span>(connfd, buf, <span class="built_in">sizeof</span>(buf)<span class="number">-1</span>, MSG_OOB);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="9-2-poll系统调用"><a href="#9-2-poll系统调用" class="headerlink" title="9.2 poll系统调用"></a>9.2 poll系统调用</h2><p>poll与select类似, 也是在指定时间内轮询一定数量的文件描述符, 以测试其中是否有就绪者.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd* fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/f9ad5e58_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/aa5b114b_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/37312740_Untitled.png" alt="Untitled"></p>
<ul>
<li>timeout的单位是毫秒, 值为-1时, poll将永远阻塞, 直至某个事件发生.</li>
</ul>
<h2 id="9-3-epoll系列系统调用"><a href="#9-3-epoll系列系统调用" class="headerlink" title="9.3 epoll系列系统调用"></a>9.3 epoll系列系统调用</h2><p>epoll是Linux特有的IO复用函数, 在实现和使用上与select, poll有很大差异.</p>
<ul>
<li><strong>epoll使用一组函数</strong>来完成任务，而不是单个函数。</li>
<li>epoll把用户关心的文件描述符上的<strong>事件放在内核里的一个事件表中</strong>，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>size参数暂时不起作用, 只是提示内核这个事件表需要多大, 该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数, 以指定访问的内核事件表.</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line"> <span class="type">__uint32_t</span> events; <span class="comment">// epoll 事件</span></span><br><span class="line"> <span class="type">epoll_data_t</span> data; <span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line"> <span class="type">void</span>* ptr;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="type">uint32_t</span> u32;</span><br><span class="line"> <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>fd指明要操作的文件描述符, op则指定操作类型:</p>
<ul>
<li>EPOLL_CTL_ADD: 往事件表中注册fd上的事件</li>
<li>EPOLL_CTL_MOD: 修改fd上的注册事件</li>
<li>EPOLL_CTL_DEL: 删除fd上的注册事件</li>
</ul>
<p>epoll支持的事件类型与poll类似, 在poll对应的宏前加上’E’. 但epoll有额外的两个事件类型(EPOLLET和EPOLLONESHOT)</p>
<p>epoll_data_t是一个联合体, 使用最多的fd, 用于指定事件所丛书的目标文件描述符; ptr指定与fd相关的用户数据.</p>
<h3 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h3><p>epoll系列的主要接口, 在一段超时时间内等待一组文件描述符上的事件</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>timeout单位是毫秒</li>
<li>maxevents 指定最多监听多少个事件, 必须大于0</li>
<li>epoll_wait函数如果检测到事件, 就将所有就绪的事件从内核事件表复制到events指向的数组中(这个数组只用于存储就绪事件, 不用于输入).</li>
</ul>
<h3 id="LT和ET模式"><a href="#LT和ET模式" class="headerlink" title="LT和ET模式"></a>LT和ET模式</h3><p>epoll对文件描述符的操作有两种模式：LT(Level Trigger,电平触发)模式和ET(Edge Trigger,边沿触发)模式。LT模式是默认的工作模式，这种模式下epoll相当于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。ET模式是epoll的高效工作模式。</p>
<p>对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，<strong>epoll_wait还会再次向应用程序通告此事件，直到该事件被处理</strong>。而对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，<strong>应用程序必须立即处理该事件</strong>，因为后续的epoll_wait调用将不再向应用程序通知这一事件。可见，<strong>ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高。</strong></p>
<h3 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h3><p>在并发模式中, 可能出现某个连接的新数据被另一个线程操作的情况, 即两个线程同时操作一个socket. 为避免这种情况, 可以使用epoll的EPOLLONESHOT事件实现.</p>
<p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。但反过来思考，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/7a40d1d6_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/b7bbf5b4_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/5f7ce7d8_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/d5d1c3bf_Untitled.png" alt="Untitled"></p>
<p>工作线程的核心部分. 用休眠5s模拟处理socket之前的请求, 结束之后, 工作线程等待5s后仍然没有收到socket上的下一批客户数据, 则退出, 否则继续为它服务.</p>
<h2 id="9-4-三组IO复用函数的比较"><a href="#9-4-三组IO复用函数的比较" class="headerlink" title="9.4 三组IO复用函数的比较"></a>9.4 三组IO复用函数的比较</h2><p>select, poll, epoll三组IO复用都能同时监听多个文件描述符.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/73e4abb0_Untitled.png" alt="Untitled"></p>
<blockquote>
<p>epoll_wait采取回调方式来检测就绪事件, 其算法时间复杂度为O(1), 但是当活动连接较多时, epoll_wait的效率未必比select和poll高, 因为此时回调函数被触发地过于频繁. 所以epoll_wait适用于连接数量多, 但是活动连接比较少地情况.</p>
</blockquote>
<h2 id="9-5-IO复用地高级应用1-非阻塞connect"><a href="#9-5-IO复用地高级应用1-非阻塞connect" class="headerlink" title="9.5 IO复用地高级应用1: 非阻塞connect"></a>9.5 IO复用地高级应用1: 非阻塞connect</h2><p>当非阻塞地socket调用connect, 而连接又没有立即建立时, 会一个errno值为<strong>EINPROGRESS</strong>的错误. 这种情况下, 可以通过select, poll等监听这个连接失败的socket上的可写事件, 当函数返回后, 在利用getsockopt来读取错误码和清除该socket上的错误. 如果错误码是0, 则表示连接成功.</p>
<ul>
<li>示例代理基于select系列实现</li>
</ul>
<h2 id="9-6-IO复用的高级应用2-聊天室程序"><a href="#9-6-IO复用的高级应用2-聊天室程序" class="headerlink" title="9.6 IO复用的高级应用2: 聊天室程序"></a>9.6 IO复用的高级应用2: 聊天室程序</h2><p>该聊天室程序能让所有用户同时在线群聊，它分为客户端和服务器两个部分。</p>
<p>客户端程序有两个功能：</p>
<ol>
<li><p>从标准输入终端读入用户数据，并将用户数据发送至服务器：</p>
</li>
<li><p>往标准输出终端打印服务器发送给它的数据。</p>
</li>
</ol>
<p>服务器的功能: 接收客户数据，并把客户数据发送给每一个登录到该服务器上的客户端（数据发送者除外）。</p>
<ul>
<li>示例代码基于poll系列实现</li>
</ul>
<h2 id="9-7-IO复用的高级应用3-同时处理TCP和UDP服务"><a href="#9-7-IO复用的高级应用3-同时处理TCP和UDP服务" class="headerlink" title="9.7 IO复用的高级应用3: 同时处理TCP和UDP服务"></a>9.7 IO复用的高级应用3: 同时处理TCP和UDP服务</h2><p>一个socket只能监听一个端口, 因此, 服务器如果要同时监听多个端口, 就必须创建多个socket, 并将它们分别绑定到各个端口上. 同理, 同一个端口, 同时处理TCP和UDP也需要创建两个socket.</p>
<ul>
<li>示例代码基于epoll实现</li>
<li>使用epoll的事件表同时管理多个socket, 针对不同socket的就绪事件采取不同的措施.</li>
</ul>
<h2 id="9-8-超级服务xinetd"><a href="#9-8-超级服务xinetd" class="headerlink" title="9.8 超级服务xinetd"></a>9.8 超级服务xinetd</h2><p>xinetd管理的子服务中有的是标准服务，比如时间日期服务daytime、回射服务echo和丢弃服务discard。xinetd服务器在内部直接处理这些服务。还有的子服务则需要调用外部的服务器程序来处理。xinetd通过调用fork和exec函数来加载运行这些服务器程序。比如telnet、fp服务都是这种类型的子服务。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%B9%9D%E7%AB%A0%20IO%E5%A4%8D%E7%94%A8-b67d62ab/a1b7d042_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 IP协议详解</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-d11fac78/</url>
    <content><![CDATA[<h2 id="2-1-IP协议的特点"><a href="#2-1-IP协议的特点" class="headerlink" title="2.1 IP协议的特点"></a>2.1 IP协议的特点</h2><ul>
<li>无状态: 通信双方不同步传输数据的状态信息, 每个报文的行为都相互独立, 没有上下文关系.</li>
<li>无连接: IP双方不长久地维护对方的任何信息.</li>
<li>不可靠: 不能保证数据报到达接收端的必然性和准确性.</li>
</ul>
<h2 id="2-2-IPv4-头部结构"><a href="#2-2-IPv4-头部结构" class="headerlink" title="2.2 IPv4 头部结构"></a>2.2 IPv4 头部结构</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-d11fac78/e827fe31_Untitled.png" alt="Untitled"></p>
<ul>
<li>头部长度的单位是4字节, 因此IPv4头部长度的最大长度为2^4 * 4字节</li>
<li>3位标志中第一位保留, 第二位DF表示Don’t Fragment, 第三位MF表示More Fragment</li>
<li>分片偏移的实际值是该值左移3位(*8)</li>
<li>头部校验和仅校验头部数据是否损坏(CRC算法)</li>
<li>头部长度至少为20字节</li>
</ul>
<h2 id="2-3-IP分片"><a href="#2-3-IP分片" class="headerlink" title="2.3 IP分片"></a>2.3 IP分片</h2><ul>
<li>IP数据报可能被多次分片(发送端和中转路由器), 但是只会在最终接收端被重新组装.</li>
<li>以太网帧的MTU是1500字节, 因此IP数据报的数据部分最大为1480字节</li>
</ul>
<h2 id="2-4-IP路由"><a href="#2-4-IP路由" class="headerlink" title="2.4 IP路由"></a>2.4 IP路由</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-d11fac78/3918a07b_Untitled.png" alt="Untitled"></p>
<h3 id="2-4-2-路由机制"><a href="#2-4-2-路由机制" class="headerlink" title="2.4.2 路由机制"></a>2.4.2 路由机制</h3><p>可以使用route命令查看路由表</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-d11fac78/ef5afa1b_Untitled.png" alt="Untitled"></p>
<p>对于数据报, 根据目标IP地址进行匹配:</p>
<ol>
<li><p>完全匹配</p>
</li>
<li><p>处于同一子网(IP * mask &#x3D;&#x3D; dest)</p>
</li>
<li><p>默认路由器项(通常为网关)</p>
</li>
</ol>
<h3 id="2-4-3-路由表更新"><a href="#2-4-3-路由表更新" class="headerlink" title="2.4.3 路由表更新"></a>2.4.3 路由表更新</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-d11fac78/7e455aaa_Untitled.png" alt="Untitled"></p>
<h2 id="2-6-重定向"><a href="#2-6-重定向" class="headerlink" title="2.6 重定向"></a>2.6 重定向</h2><h3 id="2-6-1-ICMP重定向报文"><a href="#2-6-1-ICMP重定向报文" class="headerlink" title="2.6.1 ICMP重定向报文"></a>2.6.1 ICMP重定向报文</h3><p>主机之间可以通过ICMP重定向报文优化主机的路由表(先修改路由表缓冲)</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-d11fac78/8e82c9aa_Untitled.png" alt="Untitled"></p>
<blockquote>
<p>实例中, 主机ern的默认网关为主机K, 请求以太网内容时, 主机K会发送ICMP报文优化ern的路由表, 实现更高效的网络传输</p>
</blockquote>
<h2 id="2-7-IPv6头部结构"><a href="#2-7-IPv6头部结构" class="headerlink" title="2.7 IPv6头部结构"></a>2.7 IPv6头部结构</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-d11fac78/f2384da2_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>计网</tag>
        <tag>IP</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 变量与基本类型</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-c35bfd0e/</url>
    <content><![CDATA[<h2 id="基本类型的字面值"><a href="#基本类型的字面值" class="headerlink" title="基本类型的字面值"></a>基本类型的字面值</h2><p>指定字面值的类型</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-c35bfd0e/80c0b4d3_Untitled.png" alt="Untitled"></p>
<p>类型的转换：</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-c35bfd0e/af112d93_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-c35bfd0e/6a717d15_Untitled.png" alt="Untitled"></p>
<ul>
<li>#define 是预定义变量，是给字面值取别名</li>
</ul>
<h2 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h2><ul>
<li>引用即别名</li>
<li>指针是指向对象的地址</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-c35bfd0e/7ed4285b_Untitled.png" alt="Untitled"></p>
<ul>
<li>循环和函数调用时使用 const type &amp;var，可以避免对对象（不一定是const）的拷贝，提高效率</li>
</ul>
<h2 id="const和constexpr"><a href="#const和constexpr" class="headerlink" title="const和constexpr"></a>const和constexpr</h2><ul>
<li><p>默认情况下，const只对跟文件内的变量有效</p>
<ul>
<li>编译器在编译时，会把const变量的地方替换成对应的值</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-c35bfd0e/6daf850d_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>const的引用和指针可能引用和指向一个不是const的对象</p>
<ul>
<li>（只是该引用和指针会误以为他们引用或指向的对象是const的，因此不允许进行修改操作）</li>
</ul>
</li>
<li><p>const表明该对象不允许修改操作</p>
</li>
<li><p>指针也是对象，因此可能存在常量指针（该指针也可能只想常量对象，如const int *const p&#x3D;&amp;a;）</p>
<ul>
<li><p>顶层const：*后面的const，该变量为常量</p>
</li>
<li><p>底层const：最前面的const，该变量是常量的引用或指针</p>
</li>
</ul>
</li>
<li><p>constexp表示&#x3D;右边的表达式为常量表达式</p>
</li>
</ul>
<h2 id="typedef和using"><a href="#typedef和using" class="headerlink" title="typedef和using"></a>typedef和using</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-c35bfd0e/45f058bc_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-c35bfd0e/aa06267e_Untitled.png" alt="Untitled"></p>
<h2 id="auto和decltype"><a href="#auto和decltype" class="headerlink" title="auto和decltype"></a>auto和decltype</h2><ul>
<li><p>auto必须有初始值</p>
<ul>
<li><p>编译器会自动通过初始值分析变量类型</p>
</li>
<li><p>auto会忽略顶层const但保留底层const特性</p>
</li>
</ul>
</li>
<li><p>decltype会根据括号内的表达式来推理变量类型</p>
<ul>
<li><p>decltype会返回顶层的const</p>
</li>
<li><p>decltype的返回结果可能是引用</p>
</li>
<li><p>decltype(<em>p)的返回类型不是int，而是int&amp;</em></p>
</li>
<li><p>decltype((var_exp))的返回结果一定是引用</p>
</li>
</ul>
</li>
</ul>
<h2 id="定义struct"><a href="#定义struct" class="headerlink" title="定义struct"></a>定义struct</h2><ul>
<li>可以进行初始化</li>
<li>定义最后必须有一个分号，表示类（结构体）定义结束</li>
<li>类的定义和变量声明最好分开进行</li>
</ul>
<h2 id="编写头文件"><a href="#编写头文件" class="headerlink" title="编写头文件"></a>编写头文件</h2><ul>
<li>通常定义多个源文件要共用的类，常量，函数</li>
<li>注意使用 #define, #ifdef, #ifndef来进行头文件保护（防止重复引入）</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《C++ Primer》</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 Linux网络编程基础API</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/</url>
    <content><![CDATA[<h2 id="socket是什么-个人理解"><a href="#socket是什么-个人理解" class="headerlink" title="socket是什么? (个人理解)"></a>socket是什么? (个人理解)</h2><blockquote>
<p>socket是操作系统对主机之间网络连接的抽象和封装, 是一套专门的系统调用.</p>
</blockquote>
<p>应用程序通过socket控制网络连接的细节和资源,</p>
<ul>
<li><p>更形象的比喻: 主机-不同部门, 应用程序-人, socket-电话座机;</p>
<ul>
<li>不同主机上的应用程序通过socket进行通信 ⇒ 不同部门的人通过电话进行交流</li>
</ul>
</li>
</ul>
<p>socket 有不同类型, 这些类型对应不同的连接类型或连接状态:</p>
<ul>
<li>监听socket: 监听某个端口的socket, 如处于LISTEN状态的TCP连接</li>
<li>连接socket: 包括主动发起和由监听socket产生, 如处于ESTABLISHED状态的TCP连接</li>
</ul>
<h2 id="5-1-socket地址API"><a href="#5-1-socket地址API" class="headerlink" title="5.1 socket地址API"></a>5.1 socket地址API</h2><h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><ul>
<li><p>字节序包括 <code>大端字节序</code> 和 <code>小端字节序</code> , 大端字节序是指一个整数的高位字节存储在内存的低地址(流的前端), 小端字节序与之相反.</p>
<ul>
<li><p>大多数现代PC采用小端字节序, 因此小端字节序又被称为 <code>主机字节序</code></p>
</li>
<li><p>为了统一, 数据传输时采用大端字节序, 因此大端字节序又叫 <code>网络字节序</code></p>
</li>
</ul>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/d3a79725_Untitled.png" alt="Untitled"></p>
<blockquote>
<p>htonl: host to network long</p>
</blockquote>
<h3 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/4de14f3e_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/b61e4696_Untitled.png" alt="Untitled"></p>
<h3 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/bd5035a7_Untitled.png" alt="Untitled"></p>
<ul>
<li>inet_addr的输入字符串为点分十进制的IPv4地址</li>
<li>inet_aton将转化结果存储到inp指针指向的结构体内</li>
<li>inet_ntoa则是将网络字节序的IPv4地址转换为点分十进制表示的IP地址</li>
</ul>
<h2 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h2><p>UNIX&#x2F;Linux的一个哲学是: 所有东西都是文件, socket也不例外, 它是可读写, 可控制和关闭的文件描述符.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>domain 指定底层协议族. PF_INET &#x3D; IPv4, PF_INET6 &#x3D; IPv6, PF_UNIX</li>
<li>type 指定服务类型. SOCK_STREAM &#x3D; TCP, SOCK_UGRAM &#x3D; UDP</li>
<li>protocol 用于选择具体协议, 但是在前两个参数确定时, 该值通常时唯一且等于0</li>
<li>函数调用成功后返回一个socket文件描述符, 失败则为-1</li>
</ul>
<h2 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h2><p>创建socket时并未给其指定地址族, 因此还需要即将一个socket和socket地址绑定, 即socket命名.</p>
<ul>
<li>服务端通常需要命名socket, 这样客户端才知道如何连接它(知道他的端口); 而客户端通常不需要命名socket, 而是采用匿名方式, 即使用OS分配的socket地址.</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* my_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>bind 将 my_addr 绑定到 sockfd 文件描述符上, addrlen参数指出该socket地址的长度.</p>
<ul>
<li>成功返回0, 失败则返回-1</li>
</ul>
</li>
</ul>
<h2 id="5-4-监听socket"><a href="#5-4-监听socket" class="headerlink" title="5.4 监听socket"></a>5.4 监听socket</h2><p>针对服务端, socket被命名后, 还不能马上接收客户连接, 需要创建一个监听队列来存放待处理的客户连接</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>sockfd 指定被监听的socket, backlog 表示内核监听队列的最大长度, 队列超过该长度后, 服务器将不再受理新的客户连接, 客户端收到 ECONNREFUSED 错误信息. listen 成功返回0, 失败则是-1.</p>
<blockquote>
<p>自Linux内核版本2.2之后, backlog代表处于完全连接状态(ESTABLISHED)的socket上限</p>
</blockquote>
<h2 id="5-5-接收连接"><a href="#5-5-接收连接" class="headerlink" title="5.5 接收连接"></a>5.5 接收连接</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, socklen <span class="type">_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>sockfd 时执行过listen系统调用的监听socket</li>
<li>addr用来获取被接受连接的远端socket地址, 该地址的长度由addrlen指出</li>
<li>accept成功时返回一个新的连接socket, 该socket唯一地标识了被接受的连接, 服务器可以通过读写该socket来实现通信; accept失败时返回-1.</li>
</ul>
<blockquote>
<p>accept只是从监听队列中取出连接, 而不论连接处于何种状态, 更不关心任何网络状态的变化</p>
</blockquote>
<h2 id="5-6-发起连接"><a href="#5-6-发起连接" class="headerlink" title="5.6 发起连接"></a>5.6 发起连接</h2><p>服务器通过listen调用被动接收连接, 而客户端则通过connect主动发起连接</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *serv_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="5-7-关闭连接"><a href="#5-7-关闭连接" class="headerlink" title="5.7 关闭连接"></a>5.7 关闭连接</h2><p>关闭连接实际上就是关闭该连接对应的socket</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>fd是待关闭的socket, 不过close并不是直接关闭该连接, 而是将fd的引用计数减1, 只有当计数为0时, 才真正关闭连接.</p>
<ul>
<li>多进程程序中, 一次fork系统调用默认将使父进程中打开的socket引用数+1, 因此必须在父进程和子进程中都对该socket执行close调用才能关闭连接</li>
</ul>
</li>
</ul>
<p>如果想要立即终止连接, 可以使用shutdown调用</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/b6a03bc6_Untitled.png" alt="Untitled"></p>
<h2 id="5-8-数据读写"><a href="#5-8-数据读写" class="headerlink" title="5.8 数据读写"></a>5.8 数据读写</h2><h3 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h3><p>对文件的读写操作同样适用于socket. 此外还有专门控制socket读写的系统调用</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>buf和len参数分别指定都缓冲区的位置和大小, recv调用成功后返回实际读取到的长度, 通常小于预期, 因此需要多次调用recv</li>
<li>同理, send成功时返回实际写入的数据长度</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/cad98043_Untitled.png" alt="Untitled"></p>
<h3 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* src_addr,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="keyword">struct</span> sockaddr* dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>UDP没有命名socket, 因此在接收和发送时需要指定socket地址</li>
<li>recvfrom &#x2F; sendto 也可以用于面向连接的socket的数据读写, 只需要将最后两个参数都设置为NULL</li>
</ul>
<h3 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/5fe358d4_Untitled.png" alt="Untitled"></p>
<h2 id="5-9-带外标记"><a href="#5-9-带外标记" class="headerlink" title="5.9 带外标记"></a>5.9 带外标记</h2><p>Linux内核检测到TCP紧急标志后, 可以通知应用程序有带外数据需要接收, 通知方式包括IO复用产生的异常事件以及SIGURG信号. 但要想知道带外数据在数据流中的具体位置, 还需要一下系统调用</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sockatmark</span><span class="params">(<span class="type">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>sockatmark判断sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据。如果是, sockatmark返回1, 此时我们就可以利用带MSG_OOB标志的recv调用来接收带外数据。如果不是，则sockatmark返回0。</p>
<h2 id="5-10-地址信息函数"><a href="#5-10-地址信息函数" class="headerlink" title="5.10 地址信息函数"></a>5.10 地址信息函数</h2><p>有时, 我们想获取一个连接socket的本端socket地址, 以及远端socket地址.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>getsockname获取sockfd对应的本端socket地址，并将其存储于address参数指定的内存中，该socket地址的长度则存储于address_len参数指向的变量中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。getpeername函数则对应获取远端socket地址.</p>
</blockquote>
<h2 id="5-11-socket选项"><a href="#5-11-socket选项" class="headerlink" title="5.11 socket选项"></a>5.11 socket选项</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span> option_value, <span class="type">socklen_t</span>* restrict option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">const</span> <span class="type">void</span>* option_value, <span class="type">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/90b6fec5_Untitled.png" alt="Untitled"></p>
<blockquote>
<p>部分socket选项只能在调用listen前针对监听socket设置才有用.</p>
</blockquote>
<h2 id="5-12-网络信息API"><a href="#5-12-网络信息API" class="headerlink" title="5.12 网络信息API"></a>5.12 网络信息API</h2><h3 id="主机信息"><a href="#主机信息" class="headerlink" title="主机信息"></a>主机信息</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/25e67f09_Untitled.png" alt="Untitled"></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span>* name);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>* <span class="built_in">gethostbyaddr</span>(<span class="type">const</span> <span class="type">void</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> type);</span><br></pre></td></tr></table></figure></div>

<h3 id="服务信息"><a href="#服务信息" class="headerlink" title="服务信息"></a>服务信息</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/587ffc21_Untitled.png" alt="Untitled"></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">servent</span>* <span class="built_in">getservbyname</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* proto);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">servent</span>* <span class="built_in">getservbyport</span>(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span>* proto);</span><br></pre></td></tr></table></figure></div>

<p>getaddrinfo函数既能通过主机名获取IP地址, 也能通过服务名获得端口号</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API-8348d8ee/99e8c606_Untitled.png" alt="Untitled"></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hostname, cosnt <span class="type">char</span>* service, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="keyword">struct</span> addrinfo* hints, <span class="keyword">struct</span> addrinfo** result)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>getnameinfo 函数能通过socket地址同时获得以字符串表示的主机名和服务名.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnameinfo</span><span class="params">(cosnt <span class="keyword">struct</span> sockaddr* sockaddr, <span class="type">socklen_t</span> addrlen, <span class="type">char</span>* host, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">socklen_t</span> hostlen, <span class="type">char</span>* serv, <span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>socket</tag>
        <tag>《Linux高性能服务器编程》</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 语句</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%AD%E5%8F%A5-87d45329/</url>
    <content><![CDATA[<h2 id="switch-case语句"><a href="#switch-case语句" class="headerlink" title="switch case语句"></a>switch case语句</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%AD%E5%8F%A5-87d45329/9175c7d4_Untitled.png" alt="Untitled"></p>
<ul>
<li>case标签可以写在一行，表示并列的情况</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%AD%E5%8F%A5-87d45329/0cc34319_Untitled.png" alt="Untitled"></p>
<ul>
<li>C++规定不能越过变量的初始化语句直接跳转到该变量作用域内的另一个位置</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%AD%E5%8F%A5-87d45329/71e0d9a7_Untitled.png" alt="Untitled"></p>
<ul>
<li>switch case语句中，如果要变量定义建议通过{}构成块</li>
</ul>
<h2 id="try语句和异常处理"><a href="#try语句和异常处理" class="headerlink" title="try语句和异常处理"></a>try语句和异常处理</h2><ul>
<li>throw在发现异常之和，抛出异常</li>
<li>try语句的格式</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%AD%E5%8F%A5-87d45329/8ecb24fd_Untitled.png" alt="Untitled"></p>
<ul>
<li>抛出异常后，会沿着程序的执行路径依次退出函数和寻找对应的catch子句（若始终没找到对应的catch子句，则程序非正常退出）</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%AD%E5%8F%A5-87d45329/b6508403_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《C++ Primer》</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章 IO库</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20IO%E5%BA%93-64967570/</url>
    <content><![CDATA[<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20IO%E5%BA%93-64967570/1bbe6e0f_Untitled.png" alt="Untitled"></p>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><ul>
<li>流对象不允许拷贝和赋值</li>
<li>一个流一旦发生错误，其后面的IO操作都会失败</li>
<li>流的条件状态：每个IO对象都会维护一组条件状态，用来指出此对象能否进行IO操作</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20IO%E5%BA%93-64967570/ace303b3_Untitled.png" alt="Untitled"></p>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20IO%E5%BA%93-64967570/0d1033e5_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>管理输出缓冲区</p>
<ul>
<li>遇到以下情况时会刷新</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20IO%E5%BA%93-64967570/74c8b189_Untitled.png" alt="Untitled"></p>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20IO%E5%BA%93-64967570/518a03d8_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>还可以用flush和ends操作符来刷新缓冲区，ends会输出一个空字符</p>
</li>
<li><p>使用unitbuf操作符（cout&lt;&lt;unitbuf），可以让流每次完成写操作后都自动flush， nonunitbuf则让流恢复默认缓冲管理方法</p>
</li>
</ul>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20IO%E5%BA%93-64967570/220d53eb_Untitled.png" alt="Untitled"></p>
<ul>
<li>当离开文件流的作用域时，这个流会被自动析构，此时会自动调用close函数</li>
<li>每个流都有各自的文件模式</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20IO%E5%BA%93-64967570/30ffb420_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>ofstream若不混合使用app（append）模式，则out会丢失文件中的原始内容</p>
<ul>
<li>或者采用读写模式的fstream，也不会丢失数据</li>
</ul>
</li>
</ul>
<h2 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20IO%E5%BA%93-64967570/99e05255_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《C++ Primer》</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章 高性能服务器程序框架</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/</url>
    <content><![CDATA[<p>根据服务器程序的一般原理, 将服务器解构为三个主要模块:</p>
<ol>
<li><p>IO处理单元. 本章介绍四种IO模型和两种高效事件处理模式</p>
</li>
<li><p>逻辑单元. 本章介绍两种高效并发模式, 以及有限状态机</p>
</li>
<li><p>存储单元</p>
</li>
</ol>
<blockquote>
<p>请求队列是各单元之间通信方式的抽象.</p>
</blockquote>
<h2 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h2><h3 id="C-x2F-S模型"><a href="#C-x2F-S模型" class="headerlink" title="C&#x2F;S模型"></a>C&#x2F;S模型</h3><p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/a12ebbee_Untitled.png" alt="Untitled"></p>
<p>  C&#x2F;S模型适合资源相对集中的场合.</p>
<p>  缺点: 服务器时通信的中心, 当访问量过大时, 可能所有客户端都将得到很慢的响应. (对服务端不友好)</p>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/8e3d9f28_Untitled.png" alt="Untitled"></p>
<h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><p>P2P模型使得每台机器在消耗服务的同时也给别人提供服务.</p>
<p>缺点: 当用户之间传输的请求过多时, 网络的负载将加重(对客户端不友好)</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/1e3a4995_Untitled.png" alt="Untitled"></p>
<h2 id="8-3-IO模型"><a href="#8-3-IO模型" class="headerlink" title="8.3 IO模型"></a>8.3 IO模型</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/19ee06fb_Untitled.png" alt="Untitled"></p>
<p>socket在创建时默认时阻塞的, 可能被阻塞的系统调用包括accept, send, recv和connect</p>
<blockquote>
<p>针对非阻塞的socket, 这些系统调用返回-1, 需要根据errno进行区分. 对accept, send, recv而言, 事件未发生时errno通常为EAGAIN(再来一次)或者EWOULDBLOCK(期望阻塞); 对connect而言, errno则被设置为EINPROGRESS(处理中)</p>
</blockquote>
<p>显然, 只有在事件已经发生的情况下操作非阻塞IO才能提高程序的效率, 因此非阻塞IO通常要和其他IO通知机制一起使用.</p>
<ul>
<li>IO复用时最常使用的IO通知机制, 应用程序通过IO复用函数向内核注册一组事件, 内核通过IO复用函数把其中就绪的事件通知给应用程序. IO复用函数本身是阻塞的, 它们能提高程序效率的原因在于它们具有同时监听多个IO事件的能力.</li>
<li>SIGIO信号也可以用来处理IO事件. 可以为一个目标文件描述符指定宿主进程, 那么被指定的宿主进程将捕获到SIGIO信号. 这样, 当目标文件描述符上有事件发生时, SIGIO信号的信号处理函数将被触发, 我们也就可以在该信号处理函数中对目标文件描述符执行非阻塞IO操作了.</li>
</ul>
<p><strong>阻塞IO, IO复用和信号驱动IO都是同步IO模型</strong>, 因为这三种IO模型中, IO的读写操作都是在IO事件之后, 由应用程序完成.</p>
<p>而POSIX规范所定义的异步IO模型则不同, <strong>对异步IO而言, 用户可以直接对IO执行读写操作</strong>, 这些操作告诉内核用户读写缓冲区的位置, 以及IO操作完成后内核通知应用程序的方式. 异步IO的读写操作总是立即返回, 而不论IO是否阻塞, 因为<strong>真正的读写操作由内核接管</strong>.</p>
<h3 id="同步IO和异步IO"><a href="#同步IO和异步IO" class="headerlink" title="同步IO和异步IO"></a>同步IO和异步IO</h3><p><strong>在IO模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I&#x2F;O事件（是就绪事件还是完成事件），以及该由谁来完成I&#x2F;O读写（是应用程序还是内核)</strong></p>
<p><strong>同步IO的特点:</strong></p>
<ol>
<li><p><strong>同步 io 是用户线程发起 io 请求并以阻塞或</strong><u><strong>轮询</strong></u><strong>的方式来等待 io 事件的完成(内核态数据准备就绪的就绪事件)</strong></p>
</li>
<li><p>同步 io 是 io 的发起方，同时也是处理方</p>
</li>
<li><p>同步 io 是需要将内核态准备就绪的数据拷贝到用户态，所以需要阻塞用户态程序并等待 io 完成</p>
</li>
</ol>
<p><strong>异步IO的特点:</strong></p>
<ol>
<li><p>异步 io 在用户线程发起 io 请求后会立即返回继续执行后续的逻辑流</p>
</li>
<li><p>异步 io 是 io 的发起方，但内核态才是处理方</p>
</li>
<li><p><strong>异步 io 的处理方是内核态，所以不需要阻塞 (程序告诉内核读写缓存区的位置即可, 通知完成事件)</strong></p>
</li>
</ol>
<blockquote>
<p>阻塞 I&#x2F;O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。</p>
</blockquote>
<p> 非阻塞 I&#x2F;O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。</p>
<p> 异步 I&#x2F;O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。</p>
<h2 id="8-4-两种高效的事件处理模式"><a href="#8-4-两种高效的事件处理模式" class="headerlink" title="8.4 两种高效的事件处理模式"></a>8.4 两种高效的事件处理模式</h2><p><strong>同步IO模型</strong>通常用于实现Reactor模式, <strong>异步IO模型</strong>则用于实现Proactor模式.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/ff351392_Untitled.png" alt="Untitled"></p>
<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>Reactor是这样一种模式，它要求<strong>主线程(I&#x2F;O处理单元, 下同)只负责监听文件描述上是否有事件发生, 有的话就立即将该事件通知工作线程(逻辑单元, 下同).</strong> 除此之外, 主线程不做任何其他实质性的工作. 读写数据, 接受新的连接, 以及处理客户请求均在工作线程中完成.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/6d6159b6_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/d46f9301_Untitled.png" alt="Untitled"></p>
<blockquote>
<p>工作线程从请求队列中取出事件后, 将根据事件的类型来决定如何处理, 因此图中的Reactor模式中, 没必要区分”读工作线程”和”写工作线程”.</p>
</blockquote>
<h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p><a class="link" href="https://www.xiaolincoding.com/os/8_network_system/reactor.html#proactor">https://www.xiaolincoding.com/os/8_network_system&#x2F;reactor.html#proactor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>与Reactor模式不同, <strong>Proactor模式将所有IO操作都交给主线程和内核来处理(是异步IO模型), 工作线程仅仅负责业务逻辑.</strong> 因此Proactor模式更符合图8-4 (服务器基本框架)</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/04470247_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/50174745_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>连接socket上的读写事件是通过aio_read&#x2F;aio_write向内核注册的, 因此内核将通过信号向应用程序报告连接socket上的读写事件. 所以, 主线程中的epoll_wait调用能用来监听socket上的连接请求事件, 而不能用来检测连接上的读写事件.</p>
<ul>
<li>epoll_wait能够通知事件是否准备就绪(通过请求队列); 而aio_read&#x2F;aio_write则能直接将数据读入缓存区或从缓存区读出, 并直接通知事件是否已经完成(通过信号)</li>
</ul>
</li>
</ul>
<h3 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h3><p>使用同步IO模拟Proactor模式: <strong>主线程执行数据读写操作</strong>，读写完成之后，主线程向工作线程通知这一“完成事件”。<u>那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理(这点与Proactor模式一致)</u>。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/0f3f3bc7_Untitled.png" alt="Untitled"></p>
<h2 id="8-5-两种高效的并发模式"><a href="#8-5-两种高效的并发模式" class="headerlink" title="8.5 两种高效的并发模式"></a>8.5 两种高效的并发模式</h2><p>当程序是IO密集型, 采用并发编程能够提高CPU的利用率.</p>
<h3 id="半同步-x2F-半异步模式"><a href="#半同步-x2F-半异步模式" class="headerlink" title="半同步&#x2F;半异步模式"></a>半同步&#x2F;半异步模式</h3><blockquote>
<p>半同步&#x2F;半异步模式中的“同步”和“异步”与前面讨论的I&#x2F;O模型中的“同步”和“异步”是<strong>完全不同</strong>的概念!</p>
</blockquote>
<ul>
<li><p><strong>在IO模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I&#x2F;O事件（是就绪事件还是完成事件），以及该由谁来完成I&#x2F;O读写（是应用程序还是内核)。</strong></p>
</li>
<li><p><strong>在并发模式中，</strong>“同步”指的是程序完全按照代码序列的顺序执行; <strong>“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。</strong></p>
</li>
</ul>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/0aeca4b4_Untitled.png" alt="Untitled"></p>
<p>异步线程的执行效率高, 实时性强, 但是代码复杂, 难以调试和扩展; 同步线程虽然效率相对较低, 但是逻辑简单. 因此对服务器这种既要求较好的实时性, 又要求能同时处理多个用户请求的应用程序, 应该同时使用同步线程和异步线程来实现, 即采用半同步&#x2F;半异步模式.</p>
<p><strong>同步线程处理客户逻辑, 相当于逻辑单元; 异步线程处理IO事件, 相当于IO处理单元</strong>. 异步线程监听到客户请求后, 将其封装成请求对象并插入请求队列. 请求队列将通知某个工作在同步模式的工作线程来读取和处理该请求对象. 具体选择哪个工作线程取决于请求队列的设计.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/486cd439_Untitled.png" alt="Untitled"></p>
<p>如果结合考虑两种事件处理模式和几种IO模型, 则半同步&#x2F;半异步模式就产生多种变体, 如<strong>半同步&#x2F;半反应堆(half-sync&#x2F;half-reactive)模式</strong><em>(+Reactor模式)</em><strong>.</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/e485678b_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>该模式下, 只有主线程是异步线程, 负责监听所有socket上的事件. 所有工作线程都睡眠在请求队列上, 当有任务到来时, 他们通过竞争获得任务的接管权.</p>
</li>
<li><p>图中, 主线程插入请求队列的是就绪的连接socket, 要求工作线程自己从socket上读写数据, 所以它采取的事件处理模式是<strong>Reactor模式.</strong></p>
<ul>
<li>也可能采取Proactor事件处理模式, 将由主线程来完成数据的读写, 再将数据和任务类型封装后发给工作线程.</li>
</ul>
</li>
<li><p>缺点: 主线程和工作线程共享请求队列(需要加锁保护, 耗费资源); 每个工作线程只能同时处理单个客户请求.</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/fc15f8ac_Untitled.png" alt="Untitled"></p>
<ul>
<li>更高效的半同步&#x2F;半异步模式: 主线程只管理监听socket, 连接socket由工作线程来管理.</li>
<li>这种模式并非严格意义的半同步&#x2F;半异步模式, 每个线程(主线程和工作线程)都维持自己的事件循环, 都工作在异步模式, 各自独立地监听不同的事件.</li>
</ul>
<h3 id="领导者-x2F-追随者模式"><a href="#领导者-x2F-追随者模式" class="headerlink" title="领导者&#x2F;追随者模式"></a>领导者&#x2F;追随者模式</h3><p>领导者&#x2F;追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任意时间点，程序都仅有一个领导者线程，它负责监听&#x2F;O事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到O事件，首先要从线程池中推选出新的领导者线程，然后处理&#x2F;O事件。此时，新的领导者等待新的I&#x2F;O事件，而原来的领导者则处理I&#x2F;O事件，二者实现了并发。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/2e9f9b03_Untitled.png" alt="Untitled"></p>
<p>该模式有以下组件， 他们的关系如图8-12所示：</p>
<ul>
<li>句柄集（HandlerSet）:句柄(Handle)表示IO资源, 在Linux下就是文件描述符. 该集合管理众多句柄, 它使用wait_for_event方法来监听IO事件, 并将其中的就绪事件通知给领导者线程. 领导者则调用绑定在Handle上的事件处理器来处理事件.</li>
<li>线程集（ThreadSet）: 该集合包含和管理所有工作线程, 即领导者和追随者线程. 它负责线程之间的同步以及新领导者的推选. 集合中的线程必处于三种状态之一:</li>
</ul>
<ol>
<li><p>Leader: 处于领导者身份, 等待句柄上的IO事件</p>
</li>
<li><p>Processing: 正在处理事件. Leader检测到IO事件后, 可以选取新的Leader后转移到该状态, 也可以指定其他追随者来处理事件(Event Handoff). 当处于Processing状态的线程处理完事件之后, 如果当前没有领导者, 则它成为系的呢领导者, 否则转变为追随者.</p>
</li>
<li><p>Follower: 处于追随者身份, 通过调用线程集的join方法等待成为新的领导者, 也可能被领导者指定来处理事件.</p>
</li>
</ol>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/13c7af1b_Untitled.png" alt="Untitled"></p>
<ul>
<li>事件处理器（EventHandler）: 通常包含至少一个回调函数handle_event, 用于处理事件对应的业务逻辑. 事件处理器在使用前需要被绑定到某个句柄上, 当事件发生时, 领导者就执行与之绑定的事件处理器中的回调函数.</li>
<li>具体的事件处理器（ConcreteEventHandler）: 事件处理器的派生类, 重新实现基类的handle_event方法以处理特定的任务.</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/d5d4a173_Untitled.png" alt="Untitled"></p>
<p>领导者线程自己监听IO事件并处理客户请求, 因而领导者&#x2F;追随者模式不需要再线程之间传递任何额外的数据, 也不需要再线程之间同步对请求队列的访问. 但该模式的明显缺点时仅支持一个事件源集合, 因此无法做到图8-11那样让每个工作线程独立地管理多个客户连接.</p>
<h2 id="8-6-有限状态机"><a href="#8-6-有限状态机" class="headerlink" title="8.6 有限状态机"></a>8.6 有限状态机</h2><p>网络编程中, 由于存在各种各样的情况, 逻辑单元内部往往需要实现较复杂的规则, 因此本小节以HTTP头部解析为例介绍了逻辑单元内部的一种高效编程方法: 有限状态机(finite state machine)</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*主状态机的两种可能状态，分别表示：当前正在分析请求行，当前正在分析头部字段*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CHECK_STATE</span> &#123;CHECK_STATE_REQUESTLINE = <span class="number">0</span>, CHECK_STATE_HEADER&#125;;</span><br><span class="line"><span class="comment">/*从状态机的三种可能状态，即行的读取状态，分别表示：读取到一个完整的行、行出错和行数据尚且不</span></span><br><span class="line"><span class="comment">完整*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LINE_STATUS</span> &#123;LINE_OK = <span class="number">0</span>, LINE_BAD, LINE_OPEN&#125;;</span><br><span class="line"><span class="comment">/*服务器处理HTTP请求的结果: NO_REQUEST表示请求不完整, 需要继续读取; GET_REQUEST表示获得了一个完整的客户请求; 其他均为异常情况*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">HTTP_CODE</span> &#123;NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, </span><br><span class="line">        INTERNAL_ERROR, CLOSED_CONNECTION&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从状态机, 用于解析出一行内容 */</span></span><br><span class="line"><span class="function">LINE_STATUS <span class="title">parse_line</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">int</span>&amp; checked_index, <span class="type">int</span>&amp; read_index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分析请求行 */</span></span><br><span class="line"><span class="function">HTTP_CODE <span class="title">parse_requestline</span><span class="params">(<span class="type">char</span>* temp, CHECK_STATE&amp; checkstate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分析头部字段 */</span></span><br><span class="line"><span class="function">HTTP_CODE <span class="title">parse_headers</span><span class="params">(<span class="type">char</span>* temp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分析HTTP请求的入口函数 */</span></span><br><span class="line"><span class="function">HTTP_CODE <span class="title">parse_content</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">int</span>&amp; checked_index, CHECK_STATE&amp; checkstate, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">int</span>&amp; read_index, <span class="type">int</span>&amp; start_line)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>IO处理单元接收到客户的数据后, 调用parse_content函数来分析新读入的数据, 最开始的主状态机状态为CHECK_STATE_REQUESTLINE(HTTP头部的第一行为请求头, 后面行为头部字段).</p>
</li>
<li><p>parse_content调用parse_line函数来获取一个行.</p>
</li>
</ol>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6-ad4f9420/062c2798_Untitled.png" alt="Untitled"></p>
<p> parse_line内部更新checked_index, 并返回新的从状态机状态(行的读取状态)</p>
<ol>
<li>当从状态机由LINE_OPEN更新到LINE_OK时, parse_content根据主状态机状态分别调用parse_requestline和parse_headers函数解析行(若成功解析请求行, 则更新状态为CHECK_STATE_HEADER), 然后再次更新从状态机至LINE_OPEN.</li>
</ol>
<blockquote>
<p>若parse_headers检测到请求头结束标识符(<CR><LF>), 则return GET_REQUEST, 此时parse_content函数也return GET_REQUEST, 结束HTTP请求头解析.</LF></CR></p>
</blockquote>
<h2 id="8-7-提高服务器性能的其他建议"><a href="#8-7-提高服务器性能的其他建议" class="headerlink" title="8.7 提高服务器性能的其他建议"></a>8.7 提高服务器性能的其他建议</h2><h3 id="池"><a href="#池" class="headerlink" title="池"></a>池</h3><p>如果服务器的硬件资源充裕, 那么提高服务器性能的一个直接方式就是以<strong>空间换取时间</strong>, 即”浪费”服务器的硬件资源, 以换取其运行效率, 这就是池(pool)的概念.</p>
<p>池是一组资源的集合, 再服务器启动之初就被完全创建并初始化, 这称为静态资源分配. 当程序后续需要相关资源时, 不再进行耗时地请求系统分配资源, 而是直接从池中申请; 等使用结束后也无需执行系统调用释放资源, 而是直接把资源再放回池. 池有很多种, 常见的有内存池, 进程池, 线程池和连接池.</p>
<p>由于池的资源时预先静态分配的, 因此对资源的提前预估或后期动态分配是主要问题.</p>
<h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>高性能服务器应该避免不必要的数据复制, 尤其是当数据复制发生在用户代码和内核之间时. 如果内核可以直接处理从socket或者文件读入的数据, 则应用程序就没有必要将这些数据从内核缓存区复制到应用程序缓存区. 另外, 用户代码内部的数据复制也是应该避免的.</p>
<h3 id="上下文切换和锁"><a href="#上下文切换和锁" class="headerlink" title="上下文切换和锁"></a>上下文切换和锁</h3><p>并发程序必须考虑上下文切换(context switch)的问题, 即进程切换或者线程切换导致的系统开销. 即使是IO密集型的服务器, 也不应该使用过多的工作线程, 否则上写问切换将占用大量CPU资源. <strong>因此为每个客户连接都创建一个工作线程的服务器模型时不可取的.</strong></p>
<p>并发程序需要考虑的另一个问题时共享资源的加锁保护. 锁通常被认为是导致服务器效率低下的一个因素, 因为由他引入的代码不仅不处理任何业务逻辑, 而且需要访问内核资源. 因此, 如果服务器有更好的解决方案, 应该<strong>避免使用锁</strong>. 如果必须使用锁, 可以<strong>考虑减小锁的粒度.</strong></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 函数</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/</url>
    <content><![CDATA[<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><ul>
<li><p>形参和实参：实参是形参的初始值</p>
<ul>
<li><p>实参是函数调用时的传入值</p>
</li>
<li><p>形参声明在函数名字后的括号中</p>
<ul>
<li><p>每个形参都是一个含有声明符的声明（即使类型一样也必须写出类型）</p>
</li>
<li><p>形参名是可选的，但是我们无法使用未命名的形参</p>
</li>
</ul>
</li>
<li><p>实参应当与形参一一对应（数量和类型）</p>
</li>
</ul>
</li>
</ul>
<h2 id="参数传值"><a href="#参数传值" class="headerlink" title="参数传值"></a>参数传值</h2><ul>
<li><p>引用传递：引用形参是对应实参的别名</p>
<ul>
<li><p>使用引用传参可以避免拷贝</p>
</li>
<li><p>函数只能返回一个值，但是可以利用引用形参间接返回值</p>
</li>
<li><p>但是对于不希望被修改的引用形参，尽量定义为常量</p>
</li>
</ul>
</li>
<li><p>传值形参：修改形参不会影响实参（对象）的值</p>
<ul>
<li>注意指针形参，修改形参本身不会影响实参（指针对象），但是通过解地址符修改指针指向的对象是有效的</li>
</ul>
</li>
<li><p>const形参</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/93e28564_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/ce785fee_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>main处理命令行选项</p>
<ul>
<li>argc表示参数个数</li>
</ul>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/6a0d4021_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/cef51aaf_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/2907a660_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>含有可变形参的函数（形参数量不固定）</p>
<ul>
<li><p>如果形参数量未知，但类型统一，可以使用initializer_list</p>
<ul>
<li>传入的实参需要用花括号包起来</li>
</ul>
</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/2f381e8f_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>省略符形参：该策略继承于C语言，因此那些可变形参的类型应该为C语言中也有的基本类型</p>
<p><a class="link" href="https://www.runoob.com/cprogramming/c-variable-arguments.html">https://www.runoob.com/cprogramming/c-variable-arguments.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<h2 id="返回类型于return语句"><a href="#返回类型于return语句" class="headerlink" title="返回类型于return语句"></a>返回类型于return语句</h2><ul>
<li><p>返回类型可以是指针和引用，但是不能是函数内局部变量的指针（函数结束后会被释放）</p>
<ul>
<li>返回类型为引用，则返回结果为左值</li>
</ul>
</li>
<li><p>如何返回值</p>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/372eae1e_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>返回值为数组时，因为数组不能被拷贝，所以应当返回数组的指针或引用</p>
<ul>
<li><p>返回数组名，作为数组的地址进行返回，如对一维数组则返回int*</p>
</li>
<li><p>利用using或typedef对数组进行重命名后作为函数返回类型</p>
</li>
<li><p>使用decltype，起到类似重命名的效果，如decltype(arr) *func(int sz)或decltype(arr) &amp;func(int sz)</p>
</li>
<li><p>显式返回数组指针或引用，如int (*func(int sz))[]或int (&amp;func(int sz))[10]</p>
</li>
<li><p>使用尾置返回类型（C++11），如auto func(int sz) → int <a href="10">*</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="函数重载（overload）"><a href="#函数重载（overload）" class="headerlink" title="函数重载（overload）"></a>函数重载（overload）</h2><ul>
<li><p>虽然函数名相同，但是形参列表有明显的区别（形参名和顶层const不纳入区别的考量）</p>
<ul>
<li>但是底层const可以作为区分</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/77c302f1_Untitled.png" alt="Untitled"></p>
</li>
<li><p>函数匹配，即重载确定时，编译器会找到一个与实参最佳匹配的函数</p>
<ul>
<li>都不匹配或者多个匹配但没有最佳匹配时，都会报错</li>
</ul>
</li>
<li><p>重载与作用域：局部函数（甚至变量）不会重载外部函数，而是会导致外部（全局）函数被隐藏</p>
</li>
</ul>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><ul>
<li><p>默认实参：有默认值的形参必须定义在没有默认值的形参之后</p>
<ul>
<li>但是默认实参可以分开声明</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/da7c43ee_Untitled.png" alt="Untitled"></p>
<ul>
<li>形参默认值不一定是字面值</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/2e500854_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>inline（内联）函数，可以更高效，一般用于目的明确的小函数</p>
<ul>
<li>但编译器不一定支持内联，即忽略inline关键词</li>
</ul>
</li>
<li><p>constexpr函数，返回值不一定是常量，也可能和形参有关，但是实参必须是constexpr</p>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/8e9c4d62_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>inline函数和constexpr函数最好定义在头文件中，若不在头文件中定义，则需要（在用到该函数的地方）进行多次相同的定义</p>
</li>
<li><p>调试帮助：assert预处理宏，用于检查不能发生的情况</p>
<ul>
<li><p>assert宏依赖于一个名为NDEBUG的预处理变量，可以#define NDEBUG来关闭assert检查</p>
</li>
<li><p>编译器还定义了一些很有用的预处理变量名</p>
<ul>
<li><p><code>__func__</code>：当前调试的函数</p>
</li>
<li><p><code>__FILE__</code>：文件名</p>
</li>
<li><p><code>__LINE__</code>：当前行号</p>
</li>
<li><p><code>__TIME__</code>：编译时间</p>
</li>
<li><p><code>__DATE__</code>：编译日期</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><ul>
<li>候选函数：同名，可见</li>
<li>可行函数：实参数量符合要求，实参类型匹配或可以转换</li>
<li>最佳匹配：有且仅有一条可行函数满足如下要求，否则就会发生二义性错误</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/9b4124b1_Untitled.png" alt="Untitled"></p>
<ul>
<li>其中实参到形参的转换分为多个等级</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/dea98e99_Untitled.png" alt="Untitled"></p>
<ul>
<li>应该尽量避免使用这种形参类型相似的函数重载，浮点数尽量用double，整型尽量用int（与字面值的默认类型对应）</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/e2d0e385_Untitled.png" alt="Untitled"></p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li><p>函数指针指向某种特定类型的函数，类型由函数的返回类型和形参类型相关，与函数名无关</p>
<ul>
<li>函数名与函数指针等价，使用时无需使用取址符和解地址符</li>
</ul>
</li>
<li><p>对于重载函数的指针，必须是指针类型和函数类型的精确匹配（比最佳匹配更严格，即完美匹配）</p>
</li>
<li><p>函数指针形参</p>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/6e8b6c9f_Untitled.png" alt="Untitled"></p>
<ul>
<li>使用typedef，using和decltype可以简化函数的声明</li>
<li>同理函数返回值也可以是函数指针，但此时需要显式地指明返回类型为指针</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%87%BD%E6%95%B0-d4dc9909/1d103d04_Untitled.png" alt="Untitled"></p>
<ul>
<li>但是这种写法的可读性很差，建议重命名函数类型（using，typedef）或decltype或使用auto的后缀声明形式</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《C++ Primer》</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 高级IO函数</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0-9b6df7a3/</url>
    <content><![CDATA[<p>Linux提供了很多高级的IO函数, 与网络编程相关的主要分为三类:</p>
<ul>
<li>用于创建文件描述符的函数, 包括pipe, dup&#x2F;dup2函数</li>
<li>用于读写数据的函数, 包括readv&#x2F;writev, sendfile, mmap&#x2F;munmap, splice 和 tee函数</li>
<li>用于控制IO行为和属性的函数, 包括fcntl函数</li>
</ul>
<h2 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>pipe函数可以创建一个管道, 以实现进程间通信.</li>
<li>函数成功时返回0, 并将一对打开的文件描述符值填入数组, fd[0]和fd[1]分别构成管道的两端, 往fd[1]写入的数据可以从fd[0]中读取, 不能反过来. 默认情况下, 这一对文件描述符都是阻塞的.</li>
<li>如果我们用read系统调用来读取一个空的管道，则read将被阻塞，直到管道内有数据可读：如果我们用write系统调用来往一个满的管道中写入数据，则wite亦将被阻塞，直到管道有足够多的空闲空间可用。</li>
<li>如果管道的写端文件描述符fd[1]的引用计数减少至0，即没有任何进程需要往管道中写人数据，则针对该管道的读端文件描述符fd[0]的read操作将返回O,即读取到了文件结束标记(End Of File,EOF)；反之，如果管道的读端文件描述符f[0]的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符fd[1]的wite操作将失败，并引发SIGPIPE信号。</li>
</ul>
<h2 id="6-2-dup函数和dup2函数"><a href="#6-2-dup函数和dup2函数" class="headerlink" title="6.2 dup函数和dup2函数"></a>6.2 dup函数和dup2函数</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> file_descriptor_one, <span class="type">int</span> file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>dup和dup2用于复制文件描述符, 实现将标准输入重定向到一个文件or把标准输出重定向到一个网络连接等等.</li>
<li>dup函数创建一个新的文件描述符，该新文件描述符和原有文件描述符file_descriptor指向相同的文件、管道或者网络连接。并且dup返回的文件描述符总是取系统当前可用的最小整数值。</li>
<li>dup2和dup类似，不过它将返回第一个不小于file_descriptor_two的整数值。</li>
</ul>
<h2 id="6-3-readv-函数和writev函数"><a href="#6-3-readv-函数和writev函数" class="headerlink" title="6.3 readv 函数和writev函数"></a>6.3 readv 函数和writev函数</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read_v</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* vector, <span class="type">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* vector, <span class="type">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>readv函数将数据从文件描述符读到分散的内存块中，即分散读;</li>
<li>writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。</li>
<li>iovec描述一块内存块, count 是vector数组的长度.</li>
<li>readv和writev在成功时返回读出和写入fd的字节数.</li>
</ul>
<blockquote>
<p>以返回文档内容的http应答为例, 应答包含状态行, 许多头部字段, 一个空行以及文档的内容, 这些内容往往存储在内存的不同位置, 我们不需要将这些内容先拼接起来再一起发送, 而是可以通过writev将他们同时写出</p>
</blockquote>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0-9b6df7a3/14f00d28_Untitled.png" alt="Untitled"></p>
<h2 id="6-4-sendfile函数"><a href="#6-4-sendfile函数" class="headerlink" title="6.4 sendfile函数"></a>6.4 sendfile函数</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span>* offset, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>sendfile函数在两个文件描述符之间直接传递数据(完全在内核中操作), 从而避免了内核<br>缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。</li>
<li>offset 指定从读入文件流的哪个位置开始, 如果为空, 则默认从起始位置开始,</li>
<li>count指定传输的字节数</li>
<li>函数成功时返回传输的字节数</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> filefd = <span class="built_in">open</span>(file_name, O_RDONLD);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">stat</span> stat_buf;</span><br><span class="line"><span class="built_in">fstat</span>(filefd, &amp;stat_buf);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> connfd = <span class="built_in">accept</span>(....);</span><br><span class="line"><span class="built_in">sendfile</span>(connfd, filefd, <span class="literal">NULL</span>, stat_buf.st_size);</span><br></pre></td></tr></table></figure></div>

<h2 id="6-5-mmap-函数和-munmap函数"><a href="#6-5-mmap-函数和-munmap函数" class="headerlink" title="6.5 mmap 函数和 munmap函数"></a>6.5 mmap 函数和 munmap函数</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>mmap 函数用于申请一段内存空间, 作为进程间通信的共享内存, 也可以将文件直接映射到其中. mu则释放由mmap创建的这段内存空间.</p>
<p>prot 包含：</p>
<ul>
<li>PROT_READ: 内存段可读</li>
<li>PROT_WRITE: 内存段可写</li>
<li>PROT_EXEC: 内存段可执行</li>
<li>PROT_NONE: 内存段不能被访问</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0-9b6df7a3/b2f51783_Untitled.png" alt="Untitled"></p>
<h2 id="6-6-splice函数"><a href="#6-6-splice函数" class="headerlink" title="6.6 splice函数"></a>6.6 splice函数</h2><p>splice函数用于在两个文件描述符之间移动数据, 是零拷贝操作.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span>* off_in, <span class="type">int</span> fd_out, <span class="type">loff_t</span>* off_out, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>fd_in 和 fd_out必须至少有一个是管道文件描述符.</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0-9b6df7a3/41a2c7ce_Untitled.png" alt="Untitled"></p>
<p>将客户端发送的数据重新发回客户端</p>
<h2 id="6-7-tee函数"><a href="#6-7-tee函数" class="headerlink" title="6.7 tee函数"></a>6.7 tee函数</h2><p>tee函数在两个管道文件描述符之间复制数据, 是零拷贝操作. 它不消耗数据</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">int</span> fd_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>fd_in 和 fd_out必须都是管道文件描述符</li>
<li>返回在两个文件描述符之间复制的文件数据字节数</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0-9b6df7a3/96349fe1_Untitled.png" alt="Untitled"></p>
<p>同时输出数据到终端和文件</p>
<h2 id="6-8-fcntl函数"><a href="#6-8-fcntl函数" class="headerlink" title="6.8 fcntl函数"></a>6.8 fcntl函数</h2><p>fcntl提供对文件描述符的各种控制操作.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0-9b6df7a3/4190dbd6_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0-9b6df7a3/a169f2a1_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一章 定时器</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%AE%9A%E6%97%B6%E5%99%A8-3947b336/</url>
    <content><![CDATA[<p>网络程序需要处理的第三类事件是定时事件，比如定期检测一个客户连接的活动状态服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。为此，我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理。本章主要讨论的就是两种高效的管理定时器的容器：时间轮和时间堆。</p>
<h2 id="11-1-socket选项SO-RCVTIMEO-和SO-SNDTIMEO"><a href="#11-1-socket选项SO-RCVTIMEO-和SO-SNDTIMEO" class="headerlink" title="11.1 socket选项SO_RCVTIMEO 和SO_SNDTIMEO"></a>11.1 socket选项SO_RCVTIMEO 和SO_SNDTIMEO</h2><p>SO_RCVTIMEO 和SO_SNDTIMEO分别用来设置socket接收和发送数据的超时时间. 因此这两个选项仅对相关系统调用有效, 包括send, sendmsg, recv, recvmsg, accept, connect.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%AE%9A%E6%97%B6%E5%99%A8-3947b336/c43f983f_Untitled.png" alt="Untitled"></p>
<h2 id="11-2-SIGALRM信号"><a href="#11-2-SIGALRM信号" class="headerlink" title="11.2 SIGALRM信号"></a>11.2 SIGALRM信号</h2><p>第十章中提到, 由alarm和setitimer函数设置的实时闹钟一旦超时, 将触发SIGALRM信号, 因此可以通过该信号的信号处理函数来处理定时任务.</p>
<p>(这种计时器是为了和后面要讨论的高效定时器做对比)</p>
<h3 id="基于升序链表的定时器"><a href="#基于升序链表的定时器" class="headerlink" title="基于升序链表的定时器"></a>基于升序链表的定时器</h3><p>核心:</p>
<ul>
<li><p>维护一个超时时间承升序的定时器链表</p>
</li>
<li><p>定义一个心搏函数tick, 每隔一段时间就执行一次, 来处理一次链表上到期的任务</p>
<ul>
<li>从头结点开始依次处理每个定时器, 直到遇到一个尚未到期的定时器.</li>
</ul>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%AE%9A%E6%97%B6%E5%99%A8-3947b336/6b3d6689_Untitled.png" alt="Untitled"></p>
<h2 id="11-3-IO复用系统调用的超时参数"><a href="#11-3-IO复用系统调用的超时参数" class="headerlink" title="11.3 IO复用系统调用的超时参数"></a>11.3 IO复用系统调用的超时参数</h2><p>Linux下的3组IO复用系统调用都带有超时参数(select, poll, epoll), 因此它们也能统一处理定时事件.但是由于IO复用系统调用可能在超时时间到期之前就返回, 所以我们需要不断更新定时参数来反映剩余的时间.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%AE%9A%E6%97%B6%E5%99%A8-3947b336/bc3e7954_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%AE%9A%E6%97%B6%E5%99%A8-3947b336/7d5eda9b_Untitled.png" alt="Untitled"></p>
<h2 id="11-4-高性能定时器"><a href="#11-4-高性能定时器" class="headerlink" title="11.4 高性能定时器"></a>11.4 高性能定时器</h2><h3 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h3><p>基于有序链表的定时器存在一个问题, 即<strong>添加定时器的效率偏低</strong>. 为此, 设计如图所示的时间轮</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%AE%9A%E6%97%B6%E5%99%A8-3947b336/b1aa0da5_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>(实线)指针指向轮子上的一个槽(slot), 它恒速转动到下一个槽, 每次转动称为一个滴答(tick), 一个滴答的时间称为时间轮的槽间隔si(slot interval), 也就是心搏时间.</p>
</li>
<li><p>每个槽指向一条定时器链表, 每条链表上的定时器具有相同的特征: <strong>它们的定时时间相差N*si的整数倍</strong>. 时间轮正是利用这个关系将定时器散列到不同的链表中.</p>
</li>
<li><p>假如现在指针指向槽cs, 我们要添加一个定时时间为ti的定时器, 则该定时器将被插入槽ts(timer slot)中</p>
<ul>
<li>$ ts &#x3D; (cs + (ti&#x2F;si))%N $</li>
</ul>
</li>
<li><p>显然, 要提高定时精度, 就要求si足够小; 要提高执行效率, 则要求N足够大(保证链表尽可能短)</p>
</li>
<li><p>还有复杂的时间轮, 可能有多个轮子, 不同的轮子有不同的粒度. 精度高的转一圈, 精度低的可能才往前移动一槽.</p>
</li>
<li><p>添加or删除定时器O(1), 执行定时器优于O(n) (slot越多, 效率越高, 轮子多同理)</p>
</li>
</ul>
<h3 id="时间堆"><a href="#时间堆" class="headerlink" title="时间堆"></a>时间堆</h3><p>前面讨论的定时方案都是以固定的频率调用心搏函数tck,并在其中依次检测到期的定时器，然后执行到期定时器上的回调函数。设计定时器的另外一种思路是：将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在tⅵCk函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。</p>
<p>最小堆能够高效地找出最小值, 尤其适合这种定时方案.</p>
<ul>
<li>添加定时器时间复杂度为O(logn), 删除复杂度为O(1), 执行效率为O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>第十三章 多进程编程</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/</url>
    <content><![CDATA[<h2 id="13-1-fork系统调用"><a href="#13-1-fork系统调用" class="headerlink" title="13.1 fork系统调用"></a>13.1 fork系统调用</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>该函数每次调用都返回两次, 在父进程中返回的是子进程的PID, 在子进程中则返回0.</li>
<li>新的进程表项有许多属性与原进程相同, 如堆指针, 栈指针, 标志寄存器的值; 不同的属性如PPID被设置为原进程的PID, 信号位图被清除(原进程设置的信号处理函数不再对新进程起作用)</li>
<li>数据的复制采取写时复制(copy on write), 即只有任一进程对数据执行了写操作时复制才会发生.</li>
<li>父进程打开的文件描述符默认在子进程中也是打开的, 且文件描述符的引用计数加一.</li>
</ul>
<h2 id="13-2-exec系列系统调用"><a href="#13-2-exec系列系统调用" class="headerlink" title="13.2 exec系列系统调用"></a>13.2 exec系列系统调用</h2><p>在子进程中执行其他程序, 即替换当前进程映像, 需要使用exec系列函数之一:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ..., <span class="type">char</span>* <span class="type">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>path提供完整的文件名, file则是提供文件名后, 从环境变量PATH中去搜寻.</li>
<li>arg接收可变参数, argv接收参数数组. 它们都会传递给新程序的main函数.</li>
<li>envp参数用于设置新程序的环境变量(未设置则有全局变量environ指定)</li>
</ul>
<h2 id="13-3-处理僵尸进程"><a href="#13-3-处理僵尸进程" class="headerlink" title="13.3 处理僵尸进程"></a>13.3 处理僵尸进程</h2><p>对于许多多进程程序, 为了让父进程更好地跟踪子进程的退出状态, 在子进程结束运行时, 内核不会立即释放该进程的进程表表项. 在子进程结束运行之后, 父进程读取其退出状态之前, 称为僵尸态.</p>
<ul>
<li>另一种僵尸态是: 父进程结束或异常终止, 子进程PPID被设置为1, 即init进程. 子进程在退出之前, 处于僵尸态.</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span>* stat_loc)</span></span>;</span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* stat_loc, <span class="type">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>wait函数阻塞进程, 直至其某个子进程结束运行, 返回子进程PID, 并将子进程的退出状态信息存储在stat_loc中;</p>
<ul>
<li>可以通过定义的宏来查看状态信息</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/b58e62d5_Untitled.png" alt="Untitled"></p>
<ul>
<li>waitpid只等待由pid指定的子进程. options最常用的取值是WNOHANG, 此时waitpid调用时非阻塞的: 如果目标子进程还没结束, 返回0; 否则返回PID.</li>
</ul>
<h3 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h3><p>子进程结束时, 会给其父进程发送一个SIGCHLD信号. 因此, 可以在父进程中捕获SIGCHLD信号, 并在信号处理函数中调用waitpid函数以彻底结束一个子进程:</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/e293ab70_Untitled.png" alt="Untitled"></p>
<h2 id="13-4-管道"><a href="#13-4-管道" class="headerlink" title="13.4 管道"></a>13.4 管道</h2><p>管道也是父进程和子进程间通信的常用手段. 由于fork之后两个管道文件描述符(fd[0], fd[1])都保持打开, 一对这样的文件描述符能够实现数据传输. 然而<strong>一对这样的文件描述符只能保证父子进程间一个方向上的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/047a3709_Untitled.png" alt="Untitled"></p>
<p>要实现父子进程间的双向数据传输, 就必须使用两个管道, 或者使用socketpair系统调用.</p>
<p>除了特殊的FIFO管道, <strong>管道只能用于由关联的两个进程(如父子进程)间的通信</strong></p>
<h2 id="13-5-信号量"><a href="#13-5-信号量" class="headerlink" title="13.5 信号量"></a>13.5 信号量</h2><p>要实现多进程在共享资源上的同步, 要求程序实现对共享资源的独占式访问. 这种要求独占的写入或修改代码片段可能引发进程之间的竞态条件, 被称为关键代码段, 或临界区. 因此, 进程同步就是要求任一时刻只有一个进程能进入关键代码段.</p>
<p>信号量(Semaphore)是一种特殊的变量, 它只能取自然数值, 并且只支持两种操作: **等待(wait)和信号(signal), 分别对应更加常用的称呼—P,V操作.**对于信号量S:</p>
<ul>
<li>P(S), 如果S的值大于0，就将它减1：如果S的值为0，则挂起进程的执行。</li>
<li>V(S), 如果有其他进程因为等待S而挂起，则唤醒之；如果没有，则将S加1。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/cdef701c_Untitled.png" alt="Untitled"></p>
<p>最常用, 最简单的二进制信号量</p>
<h3 id="semget系统调用"><a href="#semget系统调用" class="headerlink" title="semget系统调用"></a>semget系统调用</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>key是一个键值, 用来标识一个全局唯一的信号量集. 要通过信号量通信的进程需要使用相同的键值来创建&#x2F;获取该信号量.</li>
<li>num_sems参数指定要创建&#x2F;获取的信号量集中信号量的数目. 创建时该值必须指定, 获取时可以设置为0</li>
<li>sem_flags参数指定一组标志. 它低端的9bit时该信号量的权限. 此外它还可以与IPC_CREAT标志按位或以创建新的信号量集; 联合IPC_CREAT和IPC_EXCL来确保创建一组新的唯一的信号量集.</li>
<li>函数成功时返回一个正整数, 作为信号量集的标识符.</li>
</ul>
<h3 id="semop系统调用"><a href="#semop系统调用" class="headerlink" title="semop系统调用"></a>semop系统调用</h3><p>semop系统调用改变信号量的值, 即执行PV操作. 其本质是对一些信号量相关的内核变量的操作</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/2690498e_Untitled.png" alt="Untitled"></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf* sem_ops, <span class="type">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span> &#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sem_num;</span><br><span class="line"> <span class="type">short</span> <span class="type">int</span> sem_op;</span><br><span class="line"> <span class="type">short</span> <span class="type">int</span> sem_flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>sem_id 为信号量集的标识符(由semget返回);</p>
</li>
<li><p>sem_ops指向sembuf结构体类型的一个数组. sem_num表示要操作的信号量编号(从0开始). sem_op和sem_flg组合来影响semop的行为:</p>
<ul>
<li><p>sem_flg可选值为IPC_NOWAIT(非阻塞, 立即返回)和SEM_UNDO(当进程退出时取消正在进行的semop操作)</p>
</li>
<li><p>sem_op&gt;0, 被操作的信号量增加sem_op</p>
</li>
<li><p>sem_op&#x3D;&#x3D;0, 等待0操作.</p>
</li>
<li><p>sem_op&lt;0, 对信号量进行减操作, 即期望获得信号量.</p>
</li>
</ul>
</li>
<li><p>semop对sem_ops中的每个成员按照数组顺序依次执行操作, 并且在该过程中是原子操作.</p>
</li>
</ul>
<h3 id="semctl系统调用"><a href="#semctl系统调用" class="headerlink" title="semctl系统调用"></a>semctl系统调用</h3><p>semctl系统调用允许调用者对信号量进行直接控制.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command,...)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/56eb147f_Untitled.png" alt="Untitled"></p>
<h3 id="特殊键值IPC-PRIVATE"><a href="#特殊键值IPC-PRIVATE" class="headerlink" title="特殊键值IPC_PRIVATE"></a>特殊键值IPC_PRIVATE</h3><p>semget的调用者可以给其key参数传递一个特殊的键值IPC_PRIVATE(其值为0)，这样无论该信号量是否已经存在，semget都将创建一个新的信号量。使用该键值创建的信号量并非像它的名字声称的那样是进程私有的。其他进程，尤其是子进程，也有方法来访问这个信号量。所以semget的man手册的BUGS部分上说，使用名字IPC_PRIVATE有些误导（历史原因)，应该称为IPC_NEW。</p>
<h2 id="13-6-共享内存"><a href="#13-6-共享内存" class="headerlink" title="13.6 共享内存"></a>13.6 共享内存</h2><p>共享内存是最高效的IPC机制, 但是必须通过其他辅助手段来同步进程对共享内存的访问.</p>
<h3 id="shmget系统调用"><a href="#shmget系统调用" class="headerlink" title="shmget系统调用"></a>shmget系统调用</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>shmflg参数与semget系统调用的sem_flags相同, 但额外支持两个标志:</p>
<ul>
<li><p>SHM_HUGETLB, 系统将使用大页面来为共享内存分配空间.</p>
</li>
<li><p>SHM_NORESERVE, 部位共享内存保留交换分区(swap空间).</p>
</li>
</ul>
</li>
</ul>
<h3 id="shmat和shmdt系统调用"><a href="#shmat和shmdt系统调用" class="headerlink" title="shmat和shmdt系统调用"></a>shmat和shmdt系统调用</h3><p>共享内存被创建&#x2F;获取之后，我们不能立即访问它，而是需要先将它关联到进程的地址空间中。使用完共享内存之后，我们也需要将它从进程地址空间中分离。这两项任务分别由如下两个系统调用实现：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span>* *shm_addr,<span class="type">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* shm_addr)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/f37a539a_Untitled.png" alt="Untitled"></p>
<h3 id="shmctl系统调用"><a href="#shmctl系统调用" class="headerlink" title="shmctl系统调用"></a>shmctl系统调用</h3><p>shmctl系统调用控制共享内存的某些属性</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds* buf)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/269d3e5d_Untitled.png" alt="Untitled"></p>
<h3 id="共享内存的POSIX方法"><a href="#共享内存的POSIX方法" class="headerlink" title="共享内存的POSIX方法"></a>共享内存的POSIX方法</h3><p>6.5节中我们介绍过mmap函数。利用它的MAP ANONYMOUS标志我们可以实现父、子进程之间的匿名内存共享。通过打开同一个文件，mmap也可以实现无关进程之间的内存共享。Linux提供了另外一种利用mmap在无关进程之间共享内存的方式。这种方式无须任何文件的支持，但它需要先使用如下函数来创建或打开一个POSIX共享内存对象：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,<span class="type">int</span> oflag, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>shm_open的使用方法与open系统调用完全相同。</p>
<ul>
<li><p>name参数指定要创建or打开的共享内存对象. 从可移植性的角度考虑, 应该使用”&#x2F;something”的格式.</p>
</li>
<li><p>oflag指定创建方式:</p>
<ul>
<li><p>O_RDONLY。以只读方式打开共享内存对象。</p>
</li>
<li><p>O_RDWR。以可读、可写方式打开共享内存对象。</p>
</li>
<li><p>O_CREAT。如果共享内存对象不存在，则创建之。此时mode参数的最低9位将指定该共享内存对象的访问权限。共享内存对象被创建的时候，其初始长度为0。</p>
</li>
<li><p>O_EXCL。和O CREAT一起使用，如果由namc指定的共享内存对象已经存在，则shm_open调用返回错误，否则就创建一个新的共享内存对象。</p>
</li>
<li><p>O_TRUNC。如果共享内存对象已经存在，则把它截断，使其长度为O。</p>
</li>
</ul>
</li>
<li><p>shm_open返回一个文件描述符, 可用于后续的mmap调用, 从而将共享内存关联到调用进程.</p>
</li>
<li><p>如果代码使用了上述POSIX共享内存函数, 则编译时需要指定链接选项 -lrt</p>
</li>
</ul>
<h3 id="使用共享内存的聊天室服务器程序"><a href="#使用共享内存的聊天室服务器程序" class="headerlink" title="使用共享内存的聊天室服务器程序"></a>使用共享内存的聊天室服务器程序</h3><h2 id="13-7-消息队列"><a href="#13-7-消息队列" class="headerlink" title="13.7 消息队列"></a>13.7 消息队列</h2><p>消息队列是在两个进程之间传递二进制块数据的简单有效方式. 每个数据块都有一个特定的类型, 接收方可以根据类型来有选择地接收数据, 而不一定像管道那样必须FIFO.</p>
<h3 id="msgget系统调用"><a href="#msgget系统调用" class="headerlink" title="msgget系统调用"></a>msgget系统调用</h3><p>创建或获取一个消息队列, 返回值为标识符.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>msgflag的使用和semget的sem_flags相同.</p>
<h3 id="msgsnd系统调用"><a href="#msgsnd系统调用" class="headerlink" title="msgsnd系统调用"></a>msgsnd系统调用</h3><p>msgsnd系统调用把一条消息添加到消息队列中.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span>* msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">msgbuf</span>&#123;</span><br><span class="line"> <span class="type">long</span> mtype; <span class="comment">// 消息类型</span></span><br><span class="line"> <span class="type">char</span> mtext[<span class="number">512</span>]; <span class="comment">// 消息数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>msgflag仅支持IPC_NOWAIT标志.</li>
<li>系统调用成功时返回0, 失败则为-1并设置errno.</li>
</ul>
<h3 id="msgrcv系统调用"><a href="#msgrcv系统调用" class="headerlink" title="msgrcv系统调用"></a>msgrcv系统调用</h3><p>msgrcv系统调用从消息队列中获取消息</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span>* msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>msgtype指定读取何种类型的消息.</p>
<ul>
<li><p>0: 第一个消息;</p>
</li>
<li><blockquote>
<p>0: 第一个类型为msgtype的消息(除非制定了标志MSG_EXCEPT)</p>
</blockquote>
</li>
<li><p>&lt;0: 读取消息队列中第一个类型值比msgtype的绝对值小的消息.</p>
</li>
</ul>
</li>
<li><p>msgflag控制msgrcv的行为, 是以下标志的按位或:</p>
<ul>
<li>IPC_NOWAIT。如果消息队列中没有消息，则msgrev调用立即返回并设置errno为</li>
</ul>
</li>
</ul>
<p>ENOMSG</p>
<ul>
<li><p>MSG_EXCEPT。如果msgtype大于O,则接收消息队列中第一个非msgtype类型的<br>消息。</p>
</li>
<li><p>MSG NOERROR。如果消息数据部分的长度超过了msg sz,就将它截断</p>
</li>
</ul>
<h3 id="msgctl系统调用"><a href="#msgctl系统调用" class="headerlink" title="msgctl系统调用"></a>msgctl系统调用</h3><p>msgctl系统调用控制消息队列的某些属性</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> command, <span class="keyword">struct</span> msqid_ds* buf)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/c12eefa2_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/3a824f32_Untitled.png" alt="Untitled"></p>
<h2 id="13-8-IPC命令"><a href="#13-8-IPC命令" class="headerlink" title="13.8 IPC命令"></a>13.8 IPC命令</h2><p>上述三种System V IPC进程间通信方式(信号量, 共享内存, 消息队列)都使用了一个全局唯一的键值来描述一个共享资源. 当程序调用semget, shmget, msgget时, 就创建了这些共享资源的一个实例. linux提供了ipcs命令, 以查看当前系统上拥有哪些共享资源实例.</p>
<h2 id="13-9-在进程间传递文件描述符"><a href="#13-9-在进程间传递文件描述符" class="headerlink" title="13.9 在进程间传递文件描述符"></a>13.9 在进程间传递文件描述符</h2><p>由于fork调用之后，父进程中打开的文件描述符在子进程中仍然保持打开，所以文件描述符可以很方便地从父进程传递到子进程。需要注意的是，<strong>传递一个文件描述符并不是传递一个文件描述符的值，而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项。</strong></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/7a05b02e_Untitled.png" alt="Untitled"></p>
<p>子进程通过管道将文件描述符发送到父进程, (同理可以发给不相关进程)</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B-07777541/93092014_Untitled.png" alt="Untitled"></p>
<p>父进程从管道接收目标文件描述符</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>第十三章 拷贝控制</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6-66056a82/</url>
    <content><![CDATA[<h2 id="几个原则"><a href="#几个原则" class="headerlink" title="几个原则"></a>几个原则</h2><ul>
<li>通常, 我们先考虑一个类是否需要自定义析构函数, <strong>需要自定义析构函数的类通常也需要自定义拷贝和赋值操作(往往涉及指针)</strong></li>
<li>需要拷贝操作的类也需要赋值操作, 反之亦然</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6-66056a82/3a25d3c2_Untitled.png" alt="Untitled"></p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul>
<li><p>显式定义默认拷贝or析构, 可以使用&#x3D;default</p>
</li>
<li><p>显式地阻止拷贝, 可以使用&#x3D;delete   (C++11)</p>
<ul>
<li><p>旧标准是通过将拷贝构造函数和拷贝赋值函数声明为private来阻止拷贝的(声明但是不定义)</p>
</li>
<li><p>如果一个类有数据成员不能默认构造, 拷贝,赋值或销毁, 则对应的成员函数是被为删除的</p>
</li>
<li><p>析构函数不能是删除的成员 (语法上没错, 但是会有一系列的问题)</p>
</li>
</ul>
</li>
<li><p>可以在成员函数或运算符的参数列表后(可能前面有一个const)加上&amp;或&amp;&amp;作为引用限定符, 分别表面只能被左值或右值引用</p>
</li>
</ul>
<h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul>
<li><p>如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数</p>
<ul>
<li>必须是引用类型（非引用类型的形参需要拷贝实参），且一般定义为const</li>
</ul>
</li>
<li><p>不管是否定义了其他拷贝构造函数，编译器总是会合成一个合成拷贝构造函数</p>
<ul>
<li>合成拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6-66056a82/b09ceaf0_Untitled.png" alt="Untitled"></p>
<p>合成拷贝构造函数中成员的拷贝方式</p>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6-66056a82/cb35cf1b_Untitled.png" alt="Untitled"></p>
<p>拷贝初始化的发生情况</p>
<h3 id="拷贝赋值函数"><a href="#拷贝赋值函数" class="headerlink" title="拷贝赋值函数"></a>拷贝赋值函数</h3><ul>
<li><p>赋值运算本质就是一个operator&#x3D;的函数</p>
</li>
<li><p>通常返回一个指向其左侧运算对象的引用（与默认的operator&#x3D;保持一致）</p>
</li>
<li><p>拷贝赋值通常组合了拷贝构造函数(从右值拷贝数据)和析构函数(左值释放资源)</p>
</li>
<li><p><strong>应该在销毁左侧对象资源前, 先拷贝右值对象</strong>(否则自赋值操作时会出现拷贝已释放资源的情况)</p>
<ul>
<li>建议使用swap简化赋值计算, 这种方式既安全, 又方便, 但是可能增加运算成本(拷贝不需要拷贝的值)</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6-66056a82/0509cfbc_Untitled.png" alt="Untitled"></p>
<h2 id="销毁（析构函数）"><a href="#销毁（析构函数）" class="headerlink" title="销毁（析构函数）"></a>销毁（析构函数）</h2><ul>
<li><p>每个类只有一个析构函数~ClassName()</p>
<ul>
<li>不接受参数，也没有返回值</li>
</ul>
</li>
<li><p>析构函数先执行函数体, 再按初始化顺序的逆序销毁成员</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6-66056a82/3fe9b3c5_Untitled.png" alt="Untitled"></p>
<p>析构函数被调用的情况</p>
<h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><h3 id="右值引用C-11"><a href="#右值引用C-11" class="headerlink" title="右值引用C++11"></a>右值引用C++11</h3><ul>
<li>使用&amp;&amp;, 只能绑定一个将要被销毁的对象</li>
<li>不能将一个右值引用绑定到另一个右值引用的变量上</li>
<li>但是可以用std::move获取绑定左值的右值引用</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6-66056a82/42607824_Untitled.png" alt="Untitled"></p>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3><ul>
<li>声明方式与拷贝构造函数类似, 但是第一个参数(该类类型的引用)必须是右值引用, 而其他参数必须有默认值</li>
<li>(使用标准库容器时)必须声明移动构造函数是noexcept的, 否则标准库在重新分配内存时会使用拷贝构造函数而不是移动构造函数.</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6-66056a82/aa93056f_Untitled.png" alt="Untitled"></p>
<ul>
<li>只有当一个类没有自己版本的拷贝控制成员时, 且类的每个非static成员都可以移动时, 编译器才会为该类合成移动构造函数或移动赋值运算符.</li>
<li>移动右值, 拷贝左值, 但是如果没有移动构造函数或移动赋值运算符, 右值也会被拷贝</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>class</tag>
        <tag>《C++ Primer》</tag>
      </tags>
  </entry>
  <entry>
    <title>第十二章 动态内存</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/</url>
    <content><![CDATA[<h2 id="程序运行时的内存划分"><a href="#程序运行时的内存划分" class="headerlink" title="程序运行时的内存划分"></a>程序运行时的内存划分</h2><ul>
<li>静态内存：用于存放static数据，包括局部static变量，类static成员，定义在任何函数之外的变量（全局变量）</li>
<li>栈内存：存放函数内非static的对象</li>
<li>堆（or 自由空间）：存放动态分配的对象。使用动态内存的原因有三</li>
</ul>
<ol>
<li><p>程序不知道自己需要多少对象</p>
</li>
<li><p>程序不知道所需对象的具体类型</p>
</li>
<li><p>程序需要在多个对象间共享数据</p>
</li>
</ol>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><ul>
<li>新标准：新增了智能指针，使用与常规指针无异，但是它负责自动释放所指向的对象</li>
<li>智能指针也是模板</li>
<li>没有初始化的智能指针默认值初始化为0值（空）</li>
<li>使用get方法获得的内置指针,不能被delete此指针</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/9055d5bc_Untitled.png" alt="Untitled"></p>
<ul>
<li>智能指针还能够重写删除器, 在指针所指对象将要被销毁时调用, 用于取代对象的析构函数</li>
</ul>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/65f770c5_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>允许指向多个指针指向同一个对象</p>
</li>
<li><p>最安全的分配和使用动态内存的方法就是使用make_shared方法</p>
<ul>
<li><p>可以使用auto来简化声明</p>
</li>
<li><p>使用时注意要声明指针类型, 括号中的内容应该对应目标类型的构造函数，类似emplace函数</p>
</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/f6c5711b_Untitled.png" alt="Untitled"></p>
<ul>
<li>可以认为每个shared_ptr都有一个关联的计数器, 称为<strong>引用计数</strong>, 一旦技术变为0, 它就会自动释放所管理的对象.(调用目标对象的析构函数)</li>
<li>reset方法将重置当前指针的值为空或传入的内置指针.</li>
</ul>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/c409616e_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>unique_ptr独占所指的对象, 或称一个unique_ptr拥有它所指向的对象.</p>
</li>
<li><p>unique_ptr的初始化方式和shared_ptr类似, 但是unique_ptr不支持拷贝</p>
<ul>
<li>有一个例外, 即通过函数返回值的形式, 拷贝或赋值一个即将被销毁的unique_ptr</li>
</ul>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/009953dc_Untitled.png" alt="Untitled"></p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/30afcce0_Untitled.png" alt="Untitled"></p>
<ul>
<li>weak_ptr是一种不控制目标对象生存期的智能指针, 即指向shared_ptr时, 不会改变它的引用计数</li>
<li>创建时需要使用shared_ptr</li>
<li>由于weak_ptr所指的对象可能已经被销毁, 因此不能直接访问对象, 而需要用lock(或expired)方法验证</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/243cbe29_Untitled.png" alt="Untitled"></p>
<h2 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h2><p>使用new和delete运算符直接管理动态内存</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ul>
<li><p>使用new分配的对象是无名的, 需要使用指针记录返回的地址</p>
</li>
<li><p>可以使用默认初始化, 也可以使用构造函数来构建对象, 甚至可以传入对象(进行拷贝初始化)</p>
</li>
<li><p>当内存耗尽时,new会报一个bad_alloc的异常</p>
<ul>
<li>可以向new传入一个参数(nothrow), 来让异常发生时返回空指针</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/c57da715_Untitled.png" alt="Untitled"></p>
<ul>
<li>可以用shared_ptr<strong>显式</strong>地接受new分配的内存, 但是不要把智能指针和内置指针混合使用!</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/219963bd_Untitled.png" alt="Untitled"></p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><ul>
<li><p>内置指针管理的动态内存在被显式释放之前会一直存放（因此很容易出错）</p>
<ul>
<li><p>忘记释放</p>
</li>
<li><p>使用已经销毁了的对象</p>
</li>
<li><p>释放两次</p>
</li>
</ul>
</li>
<li><p>传递给delete的指针必须是指向动态分配的内存, 或者空指针</p>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/348cb85e_Untitled.png" alt="Untitled"></p>
<ul>
<li>一个动态分配的const对象, 虽然不能修改, 但是可以被销毁</li>
</ul>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><h3 id="new-type-num"><a href="#new-type-num" class="headerlink" title="new type[num]"></a>new type[num]</h3><ul>
<li><p>使用Type* p&#x3D;new Type[num]; 的方式声明的动态数组,并不是一个数组类型(无法使用begin, end以及范围for)</p>
<ul>
<li><p>但是依旧可以用括号或花括号进行数组的初始化</p>
</li>
<li><p>可以创建空数组, 即num&#x3D;0, 但是无法解引用(类似尾后指针)</p>
</li>
</ul>
</li>
<li><p>销毁动态数组时, 格式为 delete [] p; 空方括号是必须的, 否则其行为是未定义的.</p>
</li>
<li><p>可以用unique_ptr指向一个动态数组</p>
<ul>
<li>无法对这个unique_ptr使用点运算或箭头成员运算符, 但是可以用下标运算符来访问数组中的元素.</li>
</ul>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/597dbd0d_Untitled.png" alt="Untitled"></p>
<h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-f6911c2c/e32742a1_Untitled.png" alt="Untitled"></p>
<ul>
<li>位于memory头文件, 能够把内存分配和对象构造分开来, 步骤分别为:</li>
</ul>
<ol>
<li><p>allocate, 分配内存</p>
</li>
<li><p>construct, 构建对象</p>
</li>
<li><p>destroy, 销毁对象</p>
</li>
<li><p>deallocate, 释放内存</p>
</li>
</ol>
<ul>
<li>allocator同样是泛型, 需要指明类型.</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>pointer</tag>
        <tag>《C++ Primer》</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>第十五章 进程池和线程池</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0-e3dae320/</url>
    <content><![CDATA[<p>前面章节中我们是通过动态创建子进程或子线程来实现并发服务器的. 这样有如下缺点:</p>
<ul>
<li>动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户响应。</li>
<li>动态创建的子进程（或子线程）通常只用来为一个客户服务（除非我们做特殊的处理)，这将导致系统上产生大量的细微进程（或线程）。进程（或线程）间的切换将消耗大量CPU时间。</li>
<li>动态创建的子进程是当前进程的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性能。</li>
</ul>
<h2 id="15-1-进程池与线程池概述"><a href="#15-1-进程池与线程池概述" class="headerlink" title="15.1 进程池与线程池概述"></a>15.1 进程池与线程池概述</h2><p>进程池中所有的子进程都运行着相同的代码, 并拥有相同的属性, 如优先级, PGID等. 由于进程池在服务器启动之初就创建好了, 所以每个子进程都相对干净, 即它们没有打开不必要的文件描述符或大块的堆内存.</p>
<p>当有新的任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在的子进程的代价显然要小得多。至于主进程选择哪个子进程来为新任务服务，则有两种方式：</p>
<ul>
<li>主进程使用某种算法来主动选择子进程。最简单、最常用的算法是随机算法和Roud Robin(轮流选取)算法，但更优秀、更智能的算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器的整体压力。</li>
<li>主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之，而其他子进程将继续睡眠在工作队列上。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0-e3dae320/946ed40f_Untitled.png" alt="Untitled"></p>
<h2 id="15-2-处理多客户"><a href="#15-2-处理多客户" class="headerlink" title="15.2 处理多客户"></a>15.2 处理多客户</h2><p>在使用进程池处理多客户任务时, 首先要确认的问题是: 监听socket和连接socket是否都由主进程来统一管理.</p>
<p>一个客户的多次请求可以复用一个TCP连接, 因此在设计进程池时还需要考虑: 一个客户连接上的所有任务是否始终由一个子进程来处理. 如果客户任务是无状态的, 可以考虑使用不同的子进程来为该客户的不同请求服务, 如图. 但如果任务是存在上下文的, 则最好一直用一个子进程来为之服务.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0-e3dae320/b95f8324_Untitled.png" alt="Untitled"></p>
<h2 id="15-3-半同步-x2F-半异步进程池实现"><a href="#15-3-半同步-x2F-半异步进程池实现" class="headerlink" title="15.3 半同步&#x2F;半异步进程池实现"></a>15.3 半同步&#x2F;半异步进程池实现</h2><h2 id="15-4-用进程池实现的简单CGI服务器"><a href="#15-4-用进程池实现的简单CGI服务器" class="headerlink" title="15.4 用进程池实现的简单CGI服务器"></a>15.4 用进程池实现的简单CGI服务器</h2><h2 id="15-5-半同步-x2F-半反应堆线程池实现"><a href="#15-5-半同步-x2F-半反应堆线程池实现" class="headerlink" title="15.5 半同步&#x2F;半反应堆线程池实现"></a>15.5 半同步&#x2F;半反应堆线程池实现</h2><h2 id="15-6-用线程池实现的简单Web服务器"><a href="#15-6-用线程池实现的简单Web服务器" class="headerlink" title="15.6 用线程池实现的简单Web服务器"></a>15.6 用线程池实现的简单Web服务器</h2>]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>第十五章 面向对象程序设计</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-09cd4bf4/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li><p>可以在类名后面加上final关键词, 表示该类不能作为基类(不能被继承)</p>
</li>
<li><p>可以将基类的指针或引用指向派生类对象, 即基类指针和引用的静态类型和动态类型不一定相同(只有指针和引用可能发生这种情况, 通过对象进行的函数调用, 静态类型和动态类型是一样的!)</p>
<ul>
<li><p>静态类型: 变量或表达式在声明或运算时的类型, 编译时已知</p>
</li>
<li><p>动态类型: 变量或表达式在内存中对应的类型, 运行时才知道</p>
</li>
</ul>
</li>
<li><p>友元关系不能继承</p>
</li>
</ul>
<h3 id="派生访问说明符"><a href="#派生访问说明符" class="headerlink" title="派生访问说明符"></a>派生访问说明符</h3><ul>
<li><p>public, 不修改基类的成员访问权限</p>
</li>
<li><p>protected, 把基类public的成员变为protected</p>
</li>
<li><p>private, 把基类所有成员变为private</p>
</li>
<li><p>派生访问符还会影响能否从派生类转化为基类</p>
<ul>
<li>可以通过派生类对象的基类部分(公有成员)在目标代码中是否可见来判断</li>
</ul>
</li>
<li><p>可以使用using改变基类中部分(可见)成员的访问权限</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-09cd4bf4/cf5be2e6_Untitled.png" alt="Untitled"></p>
<ul>
<li>struct 默认public继承; class默认private继承</li>
</ul>
<h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><ul>
<li>通常需要定义一个虚析构函数</li>
<li>被用作基类的类必须已经定义, 而不仅仅是声明</li>
</ul>
<h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><ul>
<li>需要使用派生列表声明自己是从哪个(哪些)基类继承而来, 首先是一个冒号, 然后是一组逗号分隔的基类, 每个基类前可以有一个访问说明符</li>
<li>可以将派生类抽象分为两部分, 一部分来自基类成员, 一部分是自己特有的成员</li>
<li>派生类在初始化列表中初始化基类部分成员(利用基类的构造函数)</li>
<li>派生类需要提供新定义来覆盖(override)基类继承而来的旧定义</li>
<li>派生类构造函数只能初始化它的直接继承类</li>
</ul>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><ul>
<li><p>关键词-virtual, 可以进行动态绑定</p>
</li>
<li><p>只能出现在类内部的声明之前</p>
</li>
<li><p>任何非构造函数的非静态函数都可以是虚函数</p>
</li>
<li><p>一般情况, 若派生类的函数覆盖了基类的虚函数, 它们的形参列表, 返回类型必须完全一致</p>
</li>
<li><p>虚函数的形参也可以有默认实参值, 但是<strong>函数调用时使用的默认实参与静态类型有关, 而不是动态类型</strong></p>
<ul>
<li>基类和派生类的默认实参值最好保持一致</li>
</ul>
</li>
<li><p>可以使用作用域运算符来略过动态绑定的过程, 强行使用某个特定版本</p>
</li>
<li><p>用&#x3D;0代替函数体, 可以声明<strong>纯虚函数</strong></p>
</li>
</ul>
<h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><ul>
<li>含有纯虚函数的类是抽象基类, 对应java中接口(interface)的概念</li>
<li>不能直接创建一个抽象基类的对象</li>
</ul>
<h3 id="protected访问控制"><a href="#protected访问控制" class="headerlink" title="protected访问控制"></a>protected访问控制</h3><ul>
<li><p>protected成员, 对类的用户是不可见的</p>
</li>
<li><p>对派生类的成员和友元是可见的</p>
<ul>
<li>派生类的成员和友元只能通过派生类对象来访问protected成员, 但对基类对象的protected成员不具有访问权限. (即使D继承了B, 但是D类访问不了B对象中的protected成员)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>class</tag>
        <tag>《C++ Primer》</tag>
      </tags>
  </entry>
  <entry>
    <title>第十四章 多线程编程</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-f2c2889d/</url>
    <content><![CDATA[<p>现代Linux的默认线程库为NPTL(Native POSIX Thred Library).</p>
<h2 id="14-1-Linux线程概述"><a href="#14-1-Linux线程概述" class="headerlink" title="14.1 Linux线程概述"></a>14.1 Linux线程概述</h2><ul>
<li><p>线程是程序中完成一个独立任务的完整执行序列, 即一个可调度的实体. 根据运行环境和调度者的身份, 线程可以分为内核线程和用户线程.</p>
</li>
<li><p>当进程的一个内核线程获得CPU的使用权时, 它就加载并运行一个用户线程. 可见内核线程相当于用户线程运行的容器.</p>
</li>
<li><p>一个进程可以拥有M个内核线程和N个用户线程, 其中M≤N; 并且一个系统的所有进程中, M和N的比值都是固定的.</p>
</li>
<li><p>按照M:N 的取值, 线程分为三种模式:</p>
<ul>
<li><p>完全在用户空间实现: 无需内核支持, 内核甚至不知道这些线程的存在. 线程库负责管理所有执行线程, 比如线程的优先级, 时间片等. 优点是在创建和调度线程都无须内核的干预, 速度快. 缺点是只有一个进程, 对应一个内核线程(容器), 对于多处理器系统, 也无法在不同CPU上运行不同的线程. 另外, 线程的优先级只对该进程内的线程有效, 并不是全局的优先级, 在调度上有局限性.</p>
</li>
<li><p>完全由内核调度: 将创建, 调度任务都交给了内核, M:N&#x3D;1:1. 优缺点与完全在用户空间实现恰恰相反.</p>
</li>
<li><p>双层调度: 结合了前两种方式, 因此综合了前两种方式的优点, 不但不会消耗过多的内核资源, 而且线程切换速度也较快, 同时可以充分发挥多处理器的优势.</p>
</li>
</ul>
</li>
</ul>
<h2 id="14-2-创建线程和结束线程"><a href="#14-2-创建线程和结束线程" class="headerlink" title="14.2 创建线程和结束线程"></a>14.2 创建线程和结束线程</h2><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span>* thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, </span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="type">void</span>* (*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>thread是新线程的标识符, 其实际上就是一个整型.</li>
<li>attr用于设置新线程的属性, NULL表示默认.</li>
<li>start_routine和arg分别指定新线程将运行的函数以及参数.</li>
</ul>
<h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h3><p>线程函数在结束时最好调用pthread_exit, 以确保安全干净地退出</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><p>一个进程中地所有线程都可以调用pthread_join函数来回收其他线程, 即等待其他线程结束.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>** retval)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>thread是目标线程的标识符, retval则是目标线程返回的退出信息.</li>
<li>该函数会一直阻塞, 直到目标线程结束. 失败则返回错误码</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-f2c2889d/1672d83f_Untitled.png" alt="Untitled"></p>
<h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h3><p>可以通过pthread_cancel异常终止一个线程;</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>接收到取消请求的目标线程也可以决定是否允许被取消以及如何取消</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span>* oldstate)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span>* oldtype)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>state 有两个可选项:</p>
<ul>
<li><p>PTHREAD_CANCEL_ENABLE,允许线程被取消。它是线程被创建时的默认取消状态。</p>
</li>
<li><p>PTHREAD_CANCEL_DISABLE,禁止线程被取消。这种情况下，如果一个线程收到取消请求，则它会将请求挂起，直到该线程允许被取消。</p>
</li>
</ul>
</li>
<li><p>type 有两个可选项:</p>
<ul>
<li><p>PTHREAD_CANCEL_ASYNCHRONOUS,线程随时都可以被取消。它将使得接收到取消请求的目标线程立即采取行动。</p>
</li>
<li><p>PTHREAD_CANCEL_DEFERRED,允许目标线程推迟行动，直到它调用了下面几个所谓的取消点函数中的一个：pthread_join、pthread_testcancel、pthread_cond_wait、pthread_cond timedwait、sem_wait和sigwait。.根据POSIX标准，其他可能阻塞的系统调用，比如read、wait,也可以成为取消点。不过为了安全起见，我们最好在可能会被取消的代码中调用pthread testcancel函数以设置取消点。</p>
</li>
</ul>
</li>
</ul>
<h2 id="14-3-线程属性"><a href="#14-3-线程属性" class="headerlink" title="14.3 线程属性"></a>14.3 线程属性</h2><ul>
<li>detachstate, 线程的脱离状态, 有PTHREAD_CREATE_JOINABLE和PTHREAD_CREATE_DETACH两种值, 默认为前者, 表示线程可回收. 后者表示该线程失去了与其他线程的同步, 在退出时会自行释放占用的资源.</li>
<li>stackaddr和stacksize, 线程堆栈的起始地址和大小.</li>
<li>guardsize, 保护区域的大小. 额外添加到堆栈尾部, 保护堆栈不被错误地覆盖的区域.</li>
<li>schedparam, 线程调度参数, 表示线程的运行优先级.</li>
<li>schedpolicy, 线程调度策略, 包含SCHED_FIFO, SCHED_RR和SCHED_OTHER三个选项. 其中SCHED_OTHER为默认值, SCHED_FIFO表示先进先出调度, SCHED_RR表示轮转算法调度, 后两种只能用于超级用户运行的进程.</li>
<li>inheritsched, 是否继承调用线程的调度属性.</li>
<li>scope, 线程间竞争CPU的范围, 即线程优先级的有限范围. 包含PTHREAD_SCOPE_SYSTEM和PTHREAD_SCOPE_PROCESS两个选项.</li>
</ul>
<h2 id="14-4-POSIX信号量"><a href="#14-4-POSIX信号量" class="headerlink" title="14.4 POSIX信号量"></a>14.4 POSIX信号量</h2><p>多线程也需要考虑同步问题, pthread_join也是一种简单的线程同步方式, 但是无法高效地实现复杂地同步需求.</p>
<p>在Linux上, 信号量有两组, 除了System V IPC信号量, 还有POSIX信号量.</p>
<ul>
<li>System V IPC信号量是一个或多个信号量的结构体, 较复杂, 常用于进程间同步; POSIX信号量是个非负整数, 较简单, 常用于线程间同步</li>
<li>System V 信号量的引用头文件是 “&lt;sys&#x2F;sem.h&gt;”，而POSIX 信号量的引用头文件是 “&lt;semaphore.h&gt;”</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>sem_trywait是sem_wait的非阻塞版本, 当信号量值为0时, 返回-1, 并设置errno为EAGAIN.</li>
</ul>
<h2 id="14-5-互斥锁"><a href="#14-5-互斥锁" class="headerlink" title="14.5 互斥锁"></a>14.5 互斥锁</h2><p>互斥锁(也称互斥量)有点类似二进制信号量</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span>* mutexattr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pyhread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pyhread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>互斥锁有两个常用属性: pshared和type</p>
<p>pshared有两个可选值:</p>
<ul>
<li>PTHREAD PROCESS SHARED。互斥锁可以被跨进程共享。</li>
<li>PTHREAD PROCESS PRIVATE。互斥锁只能被和锁的初始化线程隶属于同一个进程的线程共享。</li>
</ul>
<p>Linux支持4种type:</p>
<ul>
<li>PTHREAD_MUTEX_NORMAL,普通锁。这是互斥锁默认的类型。当一个线程对一个普通锁加锁以后，其余请求该锁的线程将形成一个等待队列，并在该锁解锁后按优先级获得它。这种锁类型保证了资源分配的公平性。但这种锁也很容易引发问题：一个线程如果对一个已经加锁的普通锁再次加锁，将引发死锁；对一个已经被其他线程加锁的普通锁解锁，或者对一个已经解锁的普通锁再次解锁，将导致不可预期的后果。</li>
<li>PTHREAD_MUTEX_ERRORCHECK,检错锁。一个线程如果对一个已经加锁的检错锁再次加锁，则加锁操作返回EDEADLK。对一个已经被其他线程加锁的检错锁解锁，或者对一个已经解锁的检错锁再次解锁，则解锁操作返回EPERM。</li>
<li>PTHREAD_MUTEX_RECURSIVE,嵌套锁。这种锁允许一个线程在释放锁之前多次对它加锁而不发生死锁。不过其他线程如果要获得这个锁，则当前锁的拥有者<strong>必须执行相应次数的解锁操作</strong>。对一个已经被其他线程加锁的嵌套锁解锁，或者对一个已经解锁的嵌套锁再次解锁，则解锁操作返回EPERM.。</li>
<li>PTHREAD_MUTEX_DEFAULT,默认锁。一个线程如果对一个已经加锁的默认锁再次加锁，或者对一个已经被其他线程加锁的默认锁解锁，或者对一个已经解锁的默认锁再次解锁，将导致不可预期的后果。这种锁在实现的时候可能被映射为上面三种锁之一</li>
</ul>
<h2 id="14-6-条件变量"><a href="#14-6-条件变量" class="headerlink" title="14.6 条件变量"></a>14.6 条件变量</h2><p><a class="link" href="https://book.itheima.net/course/223/1277519158031949826/1277528625427521538">https://book.itheima.net/course/223/1277519158031949826/1277528625427521538 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>互斥锁用于同步线程对共享数据的访问, 那么条件变量则用于在线程之间同步共享数据的值. 条件变量提供了一种<strong>线程间的通知机制</strong>: <strong>当某个共享数据达到某个值的时候, 唤醒等待这个共享数据的线程</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span>* cond_attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span>* cond, <span class="type">pthread_mutex_t</span>* mutex)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>mutex参数是用于保护条件变量的互斥锁, 以确保pthread_cond_wait操作的原子性. 在调用pthread_cond_wait前必须确保互斥锁已经加锁, 否则将导致不可预期的结果. pthread_cond_wait在执行时, 首先把调用线程放入条件变量的等待队列中, 然后再把mutex解锁.</li>
</ul>
<h2 id="14-7-线程同步机制包装类"><a href="#14-7-线程同步机制包装类" class="headerlink" title="14.7 线程同步机制包装类"></a>14.7 线程同步机制包装类</h2><p>将信号量同步, 互斥锁, 条件变量三种同步机制分别封装为sem, locker, cond类</p>
<h2 id="14-8-多线程环境"><a href="#14-8-多线程环境" class="headerlink" title="14.8 多线程环境"></a>14.8 多线程环境</h2><p>如果一个函数能被多个线程同时调用并且不发生竞态条件, 则称之为线程安全的, 或者称之为可重入函数. 在多线程程序种调用库函数, 一定要使用可重入版本(大部分可重入, 不可重入的提供了可重入版本, 只需在原函数名后加上”_r”</p>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><ul>
<li>一个多线程程序的某个线程调用了fork函数, 新进程只含有单个线程(时调用fork的那个线程的完整复制). 另外, 子进程自动继承父进程中互斥锁的状态, 但这导致子进程不清楚从父进程继承来的互斥锁的具体状态(到底是被其他线程加锁的还是被父线程锁住的), 盲目操作可能导致死锁.</li>
<li>pthread提供了一个专门的函数篇thread)atfork, 以确保fork调用后父进程和子进程都拥有一个清楚的锁状态.</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_atfork</span><span class="params">(<span class="type">void</span> (*prepare)(<span class="type">void</span>), <span class="type">void</span> (*parent)(<span class="type">void</span>), <span class="type">void</span> (*child)(<span class="type">void</span>))</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>该函数将建立3个fork句柄来帮助我们清理互斥锁的状态。</p>
<ul>
<li><p>prepare句柄将在fork调用创建出子进程之前被执行。它可以用来锁住所有父进程中的互斥锁。</p>
</li>
<li><p>parent句柄则是fork调用创建出子进程之后，而fok返回之前，在父进程中被执行。它的作用是释放所有在prepare句柄中被锁住的互斥锁。</p>
</li>
<li><p>child句柄是fork返回之前，在子进程中被执行。和parent句柄一样，child句柄也是用于释放所有在prepare句柄中被锁住的互斥锁。</p>
</li>
</ul>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-f2c2889d/38361dc2_Untitled.png" alt="Untitled"></p>
<h3 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h3><p>每个线程都可以独立地设置信号掩码, 在多线程环境下, 应该使用pthread版本地sigprocmask函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* newmask, <span class="type">sigset_t</span>* oldmask)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>由于<strong>进程中的所有线程共享该进程的信号</strong>，所以线程库将根据线程掩码决定把信号发送给哪个具体的线程。因此，如果我们在每个子线程中都单独设置信号掩码，就很容易导致逻辑错误。此外，<strong>所有线程共享信号处理函数</strong>。也就是说，当我们在一个线程中设置了某个信号的信号处理函数后，它将覆盖其他线程为同一个信号设置的信号处理函数。这两点都说明，我们应该定义一个专门的线程来处理所有的信号。这可以通过如下两个步骤来实现：</p>
<ol>
<li><p>在主线程创建出其他子线程之前就调用pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码。这样做之后，实际上所有线程都不会响应被屏蔽的信号了。</p>
</li>
<li><p>在某个线程中调用如下函数来等待信号并处理之：</p>
</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigwait</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> set, <span class="type">int</span>** *sig )</span></span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>第十四章 重载运算和类型转换</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-08ade27c/</url>
    <content><![CDATA[<p>使用重载的运算符本质上是进行了一次函数调用</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-08ade27c/53ab8d78_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-08ade27c/e8543b9d_Untitled.png" alt="Untitled"></p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>尽量不重载&amp;&amp;, ||, 逗号, 取址符</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-08ade27c/580d6d97_Untitled.png" alt="Untitled"></p>
<h3 id="重载-lt-lt"><a href="#重载-lt-lt" class="headerlink" title="重载 &lt;&lt;"></a>重载 &lt;&lt;</h3><ul>
<li>必须是非成员运算符</li>
<li>通常第二个参数为const Type &amp;item, 引用避免拷贝, const保证元素不会更改</li>
<li>通常返回类型统一为ostream &amp;</li>
</ul>
<h3 id="重载-gt-gt"><a href="#重载-gt-gt" class="headerlink" title="重载 &gt;&gt;"></a>重载 &gt;&gt;</h3><ul>
<li>必须是非成员运算符</li>
<li>需要处理输入可能失败的情况</li>
</ul>
<h3 id="重载-x3D"><a href="#重载-x3D" class="headerlink" title="重载&#x3D;"></a>重载&#x3D;</h3><ul>
<li>通常为成员运算符</li>
<li>除了拷贝赋值和移动赋值, 还提供了接受花括号元素(initializer_list)的赋值</li>
</ul>
<h3 id="重载下标运算符"><a href="#重载下标运算符" class="headerlink" title="重载下标运算符"></a>重载下标运算符</h3><ul>
<li>必须是成员运算符(因为下标运算符返回的是引用)</li>
</ul>
<h3 id="重载递增递减运算符"><a href="#重载递增递减运算符" class="headerlink" title="重载递增递减运算符"></a>重载递增递减运算符</h3><ul>
<li>为了区分前置和后置运算符, 在声明后置运算符时会加上一个默认为0的int类型形参</li>
<li>后置版本返回值, 而不是引用</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-08ade27c/914223a9_Untitled.png" alt="Untitled"></p>
<h3 id="重载解址符和箭头引用符"><a href="#重载解址符和箭头引用符" class="headerlink" title="重载解址符和箭头引用符"></a>重载解址符和箭头引用符</h3><ul>
<li>必须是成员运算符</li>
<li><code>-&gt;</code>访问成员的性质不能改变, 因此返回值必然是一个可以使用*的类型</li>
</ul>
<h3 id="重载函数调用运算符"><a href="#重载函数调用运算符" class="headerlink" title="重载函数调用运算符"></a>重载函数调用运算符</h3><ul>
<li>如果重载了(), 那么可以像使用函数一样使用这个类的对象</li>
<li>lambda表达式就是一个函数对象</li>
</ul>
<h2 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h2><p>operator type() const</p>
<ul>
<li><p>必须定义为类的成员函数, 没有返回类型, 没有形参, 通常后面有一个const</p>
</li>
<li><p>返回值可以是任何函数返回类型(所以不能是数组或函数, 但可以是指针)</p>
</li>
<li><p>类型转换运算的前后可能有隐式类型转换</p>
<ul>
<li><p>因此, 定义类型转换可能导致意想不到的错误</p>
</li>
<li><p>可以显式定义类型转换符号, 此时也必须对应使用显式的类型转换static_cast<type>(var), 除非类型转换发生在条件语句中</type></p>
</li>
<li><p>要注意避免二义性的发生</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>class</tag>
        <tag>《C++ Primer》</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章 信号</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BF%A1%E5%8F%B7-b2fb3ea2/</url>
    <content><![CDATA[<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BF%A1%E5%8F%B7-b2fb3ea2/c0b1af6f_Untitled.png" alt="Untitled"></p>
<h2 id="10-1-Linux信号概述"><a href="#10-1-Linux信号概述" class="headerlink" title="10.1 Linux信号概述"></a>10.1 Linux信号概述</h2><p>Linux下, 一个进程给其他进程发送信号的API是kill函数</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BF%A1%E5%8F%B7-b2fb3ea2/cbd3237b_Untitled.png" alt="Untitled"></p>
<h3 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h3><p>目标进程在收到信号时, 需要定义一个接收函数来处理.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="type">__sighandler_t</span>)</span> <span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// 定义一个函数名</span></span><br></pre></td></tr></table></figure></div>

<p>该函数只有一个整型参数, 表示信号类型.</p>
<p>bits&#x2F;signum.h头文件中还定义了i新年好的两种其他处理方式. SIG_IGN表示忽略目标信号, SIG_DFL表示使用信号的默认处理方式.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/signum.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_DFL ((__sighandler_t) 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_IGN ((__sighandler_t) 1)</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Linux信号"><a href="#Linux信号" class="headerlink" title="Linux信号"></a>Linux信号</h3><p>默认处理方式:</p>
<ul>
<li>结束进程-Term</li>
<li>忽略信号-Ign</li>
<li>结束进程并生成核心转储文件-Core</li>
<li>暂停进程-Stop</li>
<li>继续进程-Cont</li>
</ul>
<p>Linux的可用信号都定义在bits&#x2F;signum.h中.</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BF%A1%E5%8F%B7-b2fb3ea2/83286d72_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BF%A1%E5%8F%B7-b2fb3ea2/25a6555f_Untitled.png" alt="Untitled"></p>
<p>与网络编程紧密相关的又SIGHUP, SIGPIPE, SIGURG.</p>
<h3 id="中断系统调用"><a href="#中断系统调用" class="headerlink" title="中断系统调用"></a>中断系统调用</h3><p>程序在执行处于阻塞状态的系统调用时收到信号, 并且设置了信号处理函数, 则默认情况下系统调用会被中断, 且errno为EINTR. 可以使用sigaction函数为信号设置SA_RESTART标志以自动重启被中断的系统调用.</p>
<h2 id="10-2-信号函数"><a href="#10-2-信号函数" class="headerlink" title="10.2 信号函数"></a>10.2 信号函数</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">_sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> sig, <span class="type">_sighandler_t</span> _handler)</span></span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>sig指定捕获的信号类型；_handler参数是_sighandler_t类型的函数指针, 指定信号sig的处理函数</li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act, <span class="keyword">struct</span> sigaction* oact)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>sigaction系统调用是更健壮(?)的接口.</p>
<ul>
<li>act指定新的信号处理方式; oact输出信号先前的处理方式.</li>
<li>sigaction结构体中, sa_handler成员指定信号处理函数; sa_mask设置进程的信号掩码; sa_flags设置程序收到信号时的行为</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BF%A1%E5%8F%B7-b2fb3ea2/b0538fa9_Untitled.png" alt="Untitled"></p>
<h2 id="10-3-信号集"><a href="#10-3-信号集" class="headerlink" title="10.3 信号集"></a>10.3 信号集</h2><p>Linux用数据结构sigset_t来表示一组信号, 其实际上时一个长整型数组, 数组的每个元素的每个位表示一个信号.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/sigset.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SIGSET_NWORDS(1024/(8*sizeof(unsigned long int)))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __val[_SIGSET_NWORDS];</span><br><span class="line">&#125; <span class="type">__sigset_t</span>;</span><br></pre></td></tr></table></figure></div>

<p>Linux提供了一组简化位运算的函数:</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BF%A1%E5%8F%B7-b2fb3ea2/8b40b583_Untitled.png" alt="Untitled"></p>
<h3 id="进程信号掩码"><a href="#进程信号掩码" class="headerlink" title="进程信号掩码"></a>进程信号掩码</h3><p>信号掩码可以指定哪些信号不能发送给本进程.</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> _how, _const <span class="type">sigset_t</span>* _set, <span class="type">sigset_t</span>* _oset)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BF%A1%E5%8F%B7-b2fb3ea2/92fe62ec_Untitled.png" alt="Untitled"></p>
<h3 id="被挂起的信号"><a href="#被挂起的信号" class="headerlink" title="被挂起的信号"></a>被挂起的信号</h3><p>信号掩码会导致被屏蔽的信号不能被进程接收, OS会将这些信号设置为进程的一个被挂起的信号. 如果我们取消对被挂起信号的屏蔽, 则它能立即被进程收到, 如下函数能够获得进程当前被挂起的信号集</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigpending</span><span class="params">(<span class="type">sigset_t</span>* set)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="10-4-统一事件源"><a href="#10-4-统一事件源" class="headerlink" title="10.4 统一事件源"></a>10.4 统一事件源</h2><p>信号是一种异步事件：信号处理函数和程序的主循环是两条不同的执行路线。很显然，信号处理函数需要尽可能快地执行完毕，以确保该信号不被屏蔽（前面提到过，为了避免<br>一些竞态条件，信号在处理期间，系统不会再次触发它)太久。一种典型的解决方案是：<br>把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单地通<br>知主循环程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行<br>目标信号对应的逻辑代码。信号处理函数通常使用管道来将信号“传递”给主循环：信号<br>处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。那么主循环怎<br>么知道管道上何时有数据可读呢？这很简单，我们只需要使用&#x2F;O复用系统调用来监听管<br>道的读端文件描述符上的可读事件。如此一来，信号事件就能和其他I&#x2F;O事件一样被处理，<br>即统一事件源。</p>
<h2 id="10-5-网络编程相关信号"><a href="#10-5-网络编程相关信号" class="headerlink" title="10.5 网络编程相关信号"></a>10.5 网络编程相关信号</h2><h3 id="SIGHUP"><a href="#SIGHUP" class="headerlink" title="SIGHUP"></a>SIGHUP</h3><p>当挂起进程的控制终端时，SIGHUP信号将被触发。对于没有控制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务器重读配置文件。</p>
<h3 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h3><p>默认情况下，往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号。我们需要在代码中捕获并处理该信号，或者至少忽略它，因为程序接收到SIGPIPE信号的默认行为是结束进程，而我们绝对不希望因为错误的写操作而导致程序退出。引起SIGPIPE信号的写操作将设置errno为EPIPE。</p>
<h3 id="SIGURG"><a href="#SIGURG" class="headerlink" title="SIGURG"></a>SIGURG</h3><p>SIGURG信号是内核通知应用程序带外数据到达的两种方式之一(另一种是处理socket系统调用的异常事件)</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《Linux高性能服务器编程》</tag>
        <tag>Linux</tag>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章 泛型算法</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-e9d50fc9/</url>
    <content><![CDATA[<h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><ul>
<li><p>只读算法：前两个实参往往是两个迭代器</p>
</li>
<li><p>写操作算法</p>
<ul>
<li><p>这类算法不检查写操作</p>
</li>
<li><p>back_iterator是一个插入迭代器，通过该迭代器进行赋值时，会调用push_back函数</p>
</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-e9d50fc9/e6de7362_Untitled.png" alt="Untitled"></p>
</li>
<li><p>重排元素的算法</p>
</li>
</ul>
<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><ul>
<li>向算法传递函数（谓词，即可调用的表达式，其返回结果是一个能用作条件的值）</li>
</ul>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><ul>
<li>可调用对象，类似函数和函数指针</li>
<li>可以忽略参数列表和返回类型，但是必须有捕获列表和函数体</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-e9d50fc9/a5a331a6_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>形参不能有默认初始值</p>
</li>
<li><p>捕获列表表示函数需要捕获的局部变量，通常为空</p>
<ul>
<li><p>捕获分为值捕获和引用捕获，可以理解为传入一个常量形参</p>
</li>
<li><p>还有隐式捕获的方式（分别用&#x3D;和&amp;来表示两种捕获）</p>
</li>
</ul>
</li>
<li><p>指定返回类型时，采用尾置返回类型</p>
</li>
<li><p>lambda表达式的等价效果是定义一个函数，但是当捕获列表不为空时，函数需要添加额外的形参，这在固定形参个数的情况下不可行，因此需要functional库下的bind函数</p>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-e9d50fc9/5b12602e_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>其中arg_list就类似于捕获列表，不同点在于arg_list中要以‘_n’的形式声明占位符，那几个占位符对应的实参会传递给callable</p>
<ul>
<li><p>占位符声明在std::placeholders中</p>
</li>
<li><p>占位符从_1开始，分别对应callable中的第一个形参，第二个。。。</p>
</li>
<li><p>占位符在arg_list中不一定按顺序排列，更重要的是与callable中形参的对应关系</p>
</li>
<li><p>arg_list无法拷贝引用，得使用ref(var),或cref(var)</p>
</li>
</ul>
</li>
</ul>
<h2 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h2><ul>
<li>不管是istream还是ostream在声明iterator时都需要指明迭代器类型，之后只能传入对应类型的元素</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-e9d50fc9/9e0d6aa1_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-e9d50fc9/c71d402a_Untitled.png" alt="Untitled"></p>
<h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><ul>
<li>反向迭代器可以调用base成员函数获取正向迭代器</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-e9d50fc9/ea90b15c_Untitled.png" alt="Untitled"></p>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-e9d50fc9/e8f97633_Untitled.png" alt="Untitled"></p>
<h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-e9d50fc9/4939a0b4_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《C++ Primer》</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 表达式</title>
    <url>/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/</url>
    <content><![CDATA[<h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><ul>
<li>运算优先级</li>
<li>运算对象转换</li>
<li>重载运算符</li>
</ul>
<h2 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h2><ul>
<li>左值本质上是对象在内存中的位置</li>
<li>右值则是使用对象的内容，即内存中的数据</li>
<li>取地址符作用于左值，结果为右值</li>
<li>解地址符，下标运算，迭代器解引用，作用于右值，结果为左值</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/24ca4644_Untitled.png" alt="Untitled"></p>
<h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><ul>
<li>除法：C++11中规定商一律向0取整（即直接切除小数部分）</li>
<li>取余，结果符号始终于被除数相同</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/61f7332f_Untitled.png" alt="Untitled"></p>
<h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><ul>
<li>与和或的计算方式，这个策略在判断下标和解地址时可以有效防止非法操作（越界）</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/4439c58d_Untitled.png" alt="Untitled"></p>
<ul>
<li>比较运算时，右对象会先被转换为和左对象同一个类型</li>
</ul>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul>
<li><p>赋值运算的结果是一个对象（左值）</p>
<ul>
<li>赋值运算满足右结合律</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/a07411bb_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>因此可以用在条件判断中，但切记要区分赋值和相等比较运算符</p>
<ul>
<li>下面的例子中，由于赋值运算的优先级很低，因此要加上括号</li>
</ul>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/7dba439c_Untitled.png" alt="Untitled"></p>
</li>
</ul>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><ul>
<li><p>存在前置版本和后置版本</p>
<ul>
<li><p>前置版本会将运算对象+1（-1），再将改变后的对象作为求值结果，返回结果为左值</p>
</li>
<li><p>后置版本同样会将运算对象+1（-1），但是求值结果为对象改变前的副本！即返回结果为右值</p>
</li>
<li><p>应该优先使用前置版本，避免将原始值存储下来</p>
</li>
</ul>
</li>
<li><p>递增和递减的运算优先级大于解地址符，所以<em>pbeg++等价于</em>(pbeg++)</p>
</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/7b6e6394_Untitled.png" alt="Untitled"></p>
<ul>
<li>但是要避免赋值语句（相同对象）和递增符号的混合使用，他们的运算顺序不确定</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/95476b55_Untitled.png" alt="Untitled"></p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><ul>
<li><p>ptr→mem 等价于 *(ptr).mem</p>
<ul>
<li>解引用运算符的优先级小于点运算符</li>
</ul>
</li>
</ul>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><ul>
<li>可以嵌套且是右结合的，但是尽量不要嵌套太多，否则代码的可读性会很差</li>
</ul>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/68b461b8_Untitled.png" alt="Untitled"></p>
<ul>
<li>位运算通常会把小整型（如short，char）转换为大整型（如int）</li>
<li>移位运算的优先级比算术运算低，但比关系，赋值，条件运算高，建议使用（）</li>
</ul>
<h2 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h2><ul>
<li>有两种</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/d57e5e4f_Untitled.png" alt="Untitled"></p>
<ul>
<li>对数组进行sizeof的运算，结果为所有元素的大小之和</li>
<li>对vector和string的sizeof运算，结果为固定的大小，而不包含其中包含的元素空间</li>
</ul>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><ul>
<li>逗号居然是一个运算符？！</li>
<li>会把左侧的运算结果丢弃，右侧的表达式才是真正的结果</li>
</ul>
<h2 id="（隐式）类型转换"><a href="#（隐式）类型转换" class="headerlink" title="（隐式）类型转换"></a>（隐式）类型转换</h2><ul>
<li>何时发生</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/660bec2b_Untitled.png" alt="Untitled"></p>
<ul>
<li>算术转换</li>
</ul>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/7b82fb35_Untitled.png" alt="Untitled"></p>
<p>  <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/da854bc5_Untitled.png" alt="Untitled"></p>
<h2 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h2><ul>
<li>命名的强制类型转换：</li>
</ul>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/7511a6e9_Untitled.png" alt="Untitled"></p>
<p> <img lazyload src="/images/loading.svg" data-src="/2023/08/20/notion-%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F-88c73ea9/bcdfe2f2_Untitled.png" alt="Untitled"></p>
<ul>
<li><p>cast-name包含static_cast, const_cast, dynamic_cast, reinterpret_cast</p>
<ul>
<li><p>static_cast：只要不包含底层const，则可以使用，在大类型转小类型时有用</p>
</li>
<li><p>const_cast用于删除常量的底层const，但依旧不能修改值的操作（为定义）</p>
</li>
<li><p>reinterpret_cast是对运算对象进行了位层面的重新解释，十分危险</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>《C++ Primer》</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/</url>
    <content><![CDATA[<p><a class="link" href="https://refactoringguru.cn/design-patterns">https://refactoringguru.cn/design-patterns <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h2><ul>
<li>S：单一职责原则：对象应该仅具有一种单一功能</li>
<li>O：开闭原则：软件应该是对于扩展开放的，但是对于修改封闭的</li>
<li>L：李氏替换：程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的</li>
<li>I：接口隔离：多个特定客户端接口要好于一个宽泛用途的接口</li>
<li>D：依赖反转：依赖于抽象而不是一个实例</li>
</ul>
<h2 id="创造型模式"><a href="#创造型模式" class="headerlink" title="创造型模式"></a>创造型模式</h2><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>当难以预知对象之间的依赖关系时，可以采用工厂方法将创建产品的代码和实际使用产品的方法分离</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/faeffc43_Untitled.png" alt="Untitled"></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>在工厂模式的基础上，进一步将工厂也进行封装，客户端可以使用同样的抽象接口来使用不同的具体工厂中生产的不同风格的一系列产品</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/7fa3c599_Untitled.png" alt="Untitled"></p>
<h3 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h3><p>该设计模式针对复杂的类构造函数，将构造过程分解成多个步骤，不同的具体建造者实现不同的生产</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/8fa36559_Untitled.png" alt="Untitled"></p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>使你能够复制已有对象， 而又无需使代码依赖它们所属的类。支持克隆的对象即为<em>原型</em></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/1023be8c_Untitled.png" alt="Untitled"></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a><strong>单例模式</strong></h3><p>是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p>
<p>可以严格地控制全局变量</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/fd1061da_Untitled.png" alt="Untitled"></p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ol>
<li><p>适配器实现与其中一个现有对象兼容的接口。</p>
</li>
<li><p>现有对象可以使用该接口安全地调用适配器方法。</p>
</li>
<li><p>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</p>
</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/a646cd03_Untitled.png" alt="Untitled"></p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/ba0b78dc_Untitled.png" alt="Untitled"></p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a><strong>桥接模式</strong></h3><p>是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象（接口）和实现（平台，底层调用）两个独立的层次结构， 从而能在开发时分别使用。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/e81a3f4b_Untitled.png" alt="Untitled"></p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a><strong>组合模式</strong></h3><p>是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/84704eb9_Untitled.png" alt="Untitled"></p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a><strong>装饰模式</strong></h3><p>是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/6931df7e_Untitled.png" alt="Untitled"></p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a><strong>外观模式</strong></h3><p>是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/81f7344a_Untitled.png" alt="Untitled"></p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a><strong>享元模式</strong></h3><p>是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p>
<ul>
<li>一个仅存储内在状态的对象称为享元</li>
<li>对象的常量数据通常被称为<code>内在状态</code>， 其位于对象中， 其他对象只能读取但不能修改其数值。 而对象的其他状态常常能被其他对象 “从外部” 改变， 因此被称为<code>外在状态</code>。</li>
</ul>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/dafd8a69_Untitled.png" alt="Untitled"></p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a><strong>代理模式</strong></h3><p>是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/4026773a_Untitled.png" alt="Untitled"></p>
<h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a><strong>责任链模式</strong></h3><p>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/1ba2318f_Untitled.png" alt="Untitled"></p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a><strong>命令模式</strong></h3><p>是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/d238e461_Untitled.png" alt="Untitled"></p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a><strong>迭代器模式</strong></h3><p>是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/ce8f72a2_Untitled.png" alt="Untitled"></p>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a><strong>中介者模式</strong></h3><p>是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/22c04e78_Untitled.png" alt="Untitled"></p>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a><strong>备忘录模式</strong></h3><p>是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p>
<p>该模式的经典实现方式依赖于许多流行编程语言 （例如 C++、 C# 和 Java） 所支持的嵌套类。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/efd481a1_Untitled.png" alt="Untitled"></p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><strong>观察者模式</strong></h3><p>是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/388eb496_Untitled.png" alt="Untitled"></p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a><strong>状态模式</strong></h3><p>是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/3a0d2fe8_Untitled.png" alt="Untitled"></p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><strong>策略模式</strong></h3><p>是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/7c211f03_Untitled.png" alt="Untitled"></p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a><strong>模板方法模式</strong></h3><p>是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/744e5408_Untitled.png" alt="Untitled"></p>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a><strong>访问者模式</strong></h3><p>是一种行为设计模式， 将新行为放入一个名为<code>访问者</code>的独立类中， 而不是试图将其整合到已有类中。</p>
<p><img lazyload src="/images/loading.svg" data-src="/2023/08/31/notion-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-4c3eb3ce/9a389be9_Untitled.png" alt="Untitled"></p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode中clangd添加include path</title>
    <url>/2023/09/07/vscode%E4%B8%ADclangd%E6%B7%BB%E5%8A%A0include%20path/</url>
    <content><![CDATA[<p>在做c++项目时, 常常需要额外添加include path, 如项目目录, include文件夹. 在编译时, 要么加到CMakeLists.txt中, 要么加<code>-I/inlcude/path</code>, 但是在编辑器中, 如何添加呢? 本文主要解决vscode环境下添加include path.</p>
<h2 id="vscode-官方c-插件"><a href="#vscode-官方c-插件" class="headerlink" title="vscode 官方c++插件"></a>vscode 官方c++插件</h2><p>官方的C++插件用的很多, 所以这个解决方案一搜就能搜到. 当然是要在根目录下添加一个<code>c_cpp_properties.json</code>, 然后在includePath属性中添加目标目录.</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/include&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-clang-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="clangd-插件"><a href="#clangd-插件" class="headerlink" title="clangd 插件"></a>clangd 插件</h2><p>clangd对那些用vim的c++开发者来说应该不陌生, 但是vscode中用的相对较少. 但就我个人体验来说, clangd相当不错, 尤其是在响应速度上超出官方插件许多. 只是由于相对小众, 相关的配置比较难找, 我个人也是废了一些力气, 才试出有效的方案. clangd添加include path也是修改settings.json</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;clangd.fallbackFlags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-I$&#123;workspaceFolder&#125;/include&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-I$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>vscode</tag>
        <tag>clang</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>zerotier Mac应用崩溃</title>
    <url>/2024/02/12/zerotier-mac-gui-error/</url>
    <content><![CDATA[<h2 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h2><p>之前更新了mac上的zerotier, 结果应用一闪而退. 反复reinstall无果. 在app短暂的存在时间中, 会显示”Waiting for ZeroTier system service”, 经过搜索找到了一篇<a class="link" href="https://www.bilibili.com/read/cv19606229/?spm_id_from=333.1007.0.0">专栏 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, 终于解决.</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>崩溃的原因是用户文件夹下有无效的本地API授权令牌副本</p>
<h3 id="macOS："><a href="#macOS：" class="headerlink" title="macOS："></a>macOS：</h3><p>关闭ZeroTier托盘应用程序</p>
<p>打开终端并执行以下命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">rm ~/Library/Application\ Support/ZeroTier/One/authtoken.secret</span><br><span class="line"></span><br><span class="line">rm ~/Library/Application\ Support/ZeroTier/authtoken.secret</span><br></pre></td></tr></table></figure></div>

<p>重新打开ZeroTier UI应用程序。应提示您输入管理员密码，以便将authtoken重新复制到用户设置文件夹中。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows:"></a>Windows:</h3><p>打开资源管理器并在位置栏中键入：%LOCALAPPDATA%\ZeroTier\</p>
<p>删除authtoken.secret。</p>
<p>如果存在One子文件夹，也删除其中的删除authtoken.secret</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>zerotier</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>博客的分类系统</title>
    <url>/2023/08/20/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%86%E7%B1%BB%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>个人博客普遍有一个很让人头疼的问题, 就是如何设计分类和标签系统, 来让个人博客更整洁清晰.</p>
<p>每篇文章都有一个树状的分类, 以及不限数量的离散标签. 这种分类系统常见的问题是:</p>
<ul>
<li>分类不够“泛”，却边界模糊</li>
<li>tag太多，反而没起到分类的作用</li>
</ul>
<h2 id="寻找分类的方案"><a href="#寻找分类的方案" class="headerlink" title="寻找分类的方案"></a>寻找分类的方案</h2><p>既然分类没分好，首先去看看别人是怎么做的。</p>
<p>像 e-hentai 这样的资源站，分类是「漫画」「同人志」「CG」等；再将 tag 分类，如「中文」「日文」tag属于语言分类，「偶像大师」「东方」tag 属于作品分类。</p>
<p>而像 pivix、yandere 这样图站，干脆只用了 tag 进行分类。</p>
<p>《IT人员如何管理知识》这篇文章中把知识分为：</p>
<ul>
<li>业务领域（决策层、管理层、执行层）</li>
<li>行业（IT、金融、媒体、支付、制造、零售）</li>
<li>技术细分（理论、方法论、解决方案、应用技术、工具）</li>
</ul>
<p>有的人涉及领域很广，所以直接搬图书馆的分类，参考《中国图书馆分类法》：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A 马克思列宁主义、毛泽东思想、邓小平理论</span><br><span class="line">B 哲学、宗教</span><br><span class="line">C 社会科学总论</span><br><span class="line">…</span><br><span class="line">T 工业技术</span><br><span class="line">U 交通运输</span><br><span class="line">V 航空、航天</span><br><span class="line">X 环境科学、安全科学</span><br></pre></td></tr></table></figure></div>

<p>《如何规划blog的标签（tag）和分类》中为博客分类，作者自己的评价是“这样粗线条的划分的好处是分类会比较稳定，毕竟更新分类比起添加tag要麻烦很多”：</p>
<ol>
<li>域.业务领域</li>
<li>术.解决方案</li>
<li>技.技术研究</li>
<li>阵.技术应用</li>
<li>法.手段方法</li>
<li>理.理论学习</li>
<li>器.工具使用<br>A. 杂.杂七杂八</li>
</ol>
<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><p>我摒弃了树形的分类结构, 大刀阔斧地将文章分为了几个分界明确的大类, 将细化分类文章的任务交给了tags. 最终设计的方案如下:</p>
<ul>
<li>Learning: CS &amp; SE &amp; ML 基础或学习笔记</li>
<li>Project: 项目日志或者总结</li>
<li>Application: 一些工具或项目的推荐, 部署等</li>
<li>Sharing: 转载一些优质的文章</li>
<li>Discussion: 一些杂七杂八的漫谈</li>
<li>Others: 日常折腾的一些杂七杂八的内容</li>
</ul>
]]></content>
      <categories>
        <category>Disscussion</category>
      </categories>
  </entry>
  <entry>
    <title>从wordpress到hexo的迁移</title>
    <url>/2023/03/12/%E4%BB%8Ewordpress%E5%88%B0hexo%E7%9A%84%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>最近嫌弃腾讯云的带宽太小,精挑细选,选到了一个大带宽VPS服务商<a class="link" href="https://my.yecaoyun.com/">野草云 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.购买了一年的香港服务器,于是准备抛弃腾讯云了.<br>换服务器比较麻烦的点,就是需要把之前部署好的服务全部迁移走. 而我的腾讯云上之前就部署了我的wordpress个人博客(虽然写的内容寥寥无几,但是终究是备了案的🤦‍♂️)于是就想着把网站迁移走. 然而, 折腾了半天, 还是没有弄好, 思来想去, 觉得wordpress这种结构, 不是很适合我这种极度轻量级个人用户, 于是又开始考虑换一个博客框架. 简单一搜, 就发现有很多”免费在github上搭建个人博客”的文章, 点进去一看, 全部都是hexo.<br>稍微了解一下这个框架, 就发现它的几个优点非常符合我的需求:</p>
<ul>
<li>全部由静态网页组成，方便迁移</li>
<li>可以部署为github page</li>
<li>对markdown原生支持！<br>于是, 就有了这篇文章.</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>hexo官方文档：<a class="link" href="https://hexo.io/docs/">Documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>优秀主题-redefine: <a class="link" href="https://redefine-docs.ohevan.com/docs/intro">项目介绍 | hexo-theme-redefine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>配置过程：<a class="link" href="https://blog.csdn.net/yaorongke/article/details/119089190">https://blog.csdn.net/yaorongke/article/details/119089190 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>我现在正使用的就是上面推荐的主题-redefine. 当时在官网的themes列表里点开很多, 有example page的都不多, 而这个主题不但设计得漂亮甚至还有文档! (作者好像是一个加拿大的国人学生, 真是用心了, 点赞!)</p>
<p>我的配置:</p>
<ul>
<li>hexo配置在CentOS 7服务器上, 暂时使用VSCode Remote进行远程编辑;</li>
<li>发布到Github Page</li>
<li>同时通过nginx进行部署</li>
<li>将posts备份到家里的NAS</li>
<li>利用Let’s Encrypt获取免费SSL证书实现https</li>
</ul>
<p>后续目标:</p>
<ul>
<li>从Notion迁移到Obsidian</li>
<li>通过脚本插件实现Obsidian的文章(markdown文件)自动添加到hexo</li>
<li>后续将文章同步投放到国内支持markdown的博客平台, 如知乎, CSDN, 简书, 博客园等.</li>
</ul>
]]></content>
      <categories>
        <category>Application</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用c++实现redis</title>
    <url>/2023/09/08/%E4%BD%BF%E7%94%A8c++%E5%AE%9E%E7%8E%B0redis/</url>
    <content><![CDATA[<p>前段时间看完了<code>C++ primer 5th</code>和<code>Linux高性能服务器编程</code>两本书之后, 很迷茫不知道该做些什么东西. 然后就又新开始看一本书<code>Redis设计与实现</code>.<br>这本书事无巨细地介绍了redis3.0的底层数据结构, 数据库功能的实现以及一些进阶的多机数据库功能. 恰好redis是用c语言实现的, 于是我就在想, 要不用c++复现一个简单版本的redis练练手? 说干就干!!</p>
<p><a class="link" href="https://github.com/mirthfulLee/redisimple">github仓库 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><img lazyload src="/images/loading.svg" data-src="/2023/09/08/%E4%BD%BF%E7%94%A8c++%E5%AE%9E%E7%8E%B0redis/redisimple.png" alt="系统框架"></p>
<h2 id="项目特点"><a href="#项目特点" class="headerlink" title="项目特点"></a>项目特点</h2><ul>
<li>override the redis data structure and object with class</li>
<li>simplify some data transform to optimize the response time</li>
<li>support multi-client connections with multi-thread</li>
<li>efficient garbage collector implemented with modern smart pointers</li>
<li>organize the macro and const value with namespace</li>
</ul>
<h2 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h2><p>由于之前用C++都还只是停留在刷题和纸上谈兵, 因此项目主要的目标是使用C++完成第一个比较正式, 规模较大的项目, 除了空泛的’练习写c++代码能力’的目标, 更具体的目标包括:</p>
<ul>
<li>掌握大型项目的工作环境搭建以及学会使用cmake. 将代码编译和运行起来是一切的基础, 这点仅通过单文件编译是没法体验的.</li>
<li>掌握大型项目的文件管理以及代码规范. 项目遵循<code>google codestyle for C++</code></li>
<li>练习写c++代码能力. 这其中包括掌握c++的语法, 新特性等. 通过实践来加深对动态内存管理, 数据类型转换等难点的认识.</li>
<li>面向对象和设计模式. 通过灵活使用面向对象继承, 多态和封装, 提高代码的可读性.</li>
<li>学会C++项目的测试. 借此机会掌握不同测试方法, 并进行实操.</li>
<li>学会C++大型项目的调试. 之前的调试仅限于刷题时进行简单的调试, 而从来没有尝试过对大型项目进行错误定位和调试.</li>
<li>尝试对项目进行压力测试. 通过压力测试检测项目的运行性能.</li>
<li>学会C++项目的性能优化. 在压力测试的基础上, 分析系统性能瓶颈, 进行有目标的性能调优.</li>
</ul>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jupyter进行数据分析</title>
    <url>/2022/06/24/%E4%BD%BF%E7%94%A8jupyter%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>数据挖掘过程往往是一步一步推进的，前一步的结果很大程度上会影响下一步的方法；同时，在设计具体方法时，数据分析师需要根据当前结果不断地进行调整。这种情况下，jupyter的代码与markdown交叉的形式，以及代码按照模块执行的方法，十分契合数据分析的过程。<br>因此，这篇文章就来讲一讲在使用jupyter notebook时可能要注意的点。</p>
<h2 id="安装与环境配置"><a href="#安装与环境配置" class="headerlink" title="安装与环境配置"></a>安装与环境配置</h2><p>网上现成的教程很多，利用pip安装也很方便，只需要注意启动的jupyter内核应该和使用的python环境一致；如果使用的docker，记得为镜像中的8888端口设置对应接口。</p>
<h2 id="使用时踩的坑"><a href="#使用时踩的坑" class="headerlink" title="使用时踩的坑"></a>使用时踩的坑</h2><p>虽然刚刚开始使用，但是也经历一些小坑，在此做一些记录。</p>
<h3 id="引入自定义包"><a href="#引入自定义包" class="headerlink" title="引入自定义包"></a>引入自定义包</h3><p>python中，我们常常会习惯把不同功能的函数放到不同的.py模块下，而jupyter notebook不建议这种方式。一个notebook虽然也可以使用<strong>同一目录下</strong>其他notebook定义的函数，但是很容易出现一些奇奇怪怪的问题。<br>jupyter更加建议这样的一种模式：</p>
<ul>
<li>每个notebook都是一个完整的内容，除了开头引入工具包（库），不调用其他自定义模块</li>
<li>尽量不定义函数，尤其是不把没有返回值的过程定义为函数</li>
<li>利用markdown的分级标题（多个‘#’）把代码分为不同的模块</li>
</ul>
<h3 id="markdown换行"><a href="#markdown换行" class="headerlink" title="markdown换行"></a>markdown换行</h3><p>jupyter notebook的文字部分为markdown格式，但是在换行上有些问题，刚开始时，会发现明明敲了回车，但是还是会渲染为同一行。正确的操作是： 在行尾添加两个空格，再回车，这样就换行了。</p>
]]></content>
      <categories>
        <category>Application</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>AI</tag>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title>分位数损失</title>
    <url>/2022/06/18/%E5%88%86%E4%BD%8D%E6%95%B0%E6%8D%9F%E5%A4%B1/</url>
    <content><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a class="link" href="https://www.jianshu.com/p/073bc0b0bbfa" title="使用分位数回归预测目标的取值范围">使用分位数回归预测目标的取值范围 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link" href="https://www.payititi.com/aicommunity/show-27.html" title="分位数损失（Quantile Loss）">分位数损失（Quantile Loss） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>在大多数真实世界的预测问题中，我们常常希望得到我们预测结果的不确定度。通过预测出一个取值区间而不是一个个具体的取值点对于具体业务流程中的决策至关重要。于是提出了分位数的概念。分位数（英语：Quantile），亦称分位点，是指用分割点（cut point）将一个随机变量的概率分布范围分为几个具有相同概率的连续区间。<br>quantile_r(X) &#x3D; b 等价于 P(X &lt; b) &#x3D; r</p>
<h2 id="分位数回归"><a href="#分位数回归" class="headerlink" title="分位数回归"></a>分位数回归</h2><p>不同于普通的回归分析，分位数回归能够更好地表达数据的实际分布，对实际决策有重要意义。对下图来说，左右两个分布的期望值（预测值）相近，但是实际的分布有显著差距，因此在实际决策中需要考虑，这个时候就需要用到分位值。<br><img lazyload src="/images/loading.svg" data-src="https://www.payititi.com/file/upload/202105/14/154456111.jpeg" alt="分位数回归的意义" title="分位数回归的意义"><br>上下两条虚线基于0.05和0.95的分位数损失得到的取值区间。从图中可以清晰地看到建模后预测值得取值范围。分位数回归的目标在于估计给定预测值的条件分位数。实际上分位数回归就是平均绝对误差的一种拓展（当分位数为第50个百分位时其值就是平均绝对误差）<br><img lazyload src="/images/loading.svg" data-src="https://www.payititi.com/file/upload/202105/14/154503701.png" alt="分位值" title="分位值"></p>
<h2 id="分位数损失"><a href="#分位数损失" class="headerlink" title="分位数损失"></a>分位数损失</h2><p>为了能够实现对分位数的预测，设计了如下的损失函数：<br><img lazyload src="/images/loading.svg" data-src="https://blog.muzi.fun/wp-content/uploads/2022/06/12577832-5c01d1524f471b8f.webp" alt="损失函数"><br>其中γ是损失函数的参数，从实际意义上可以理解为是我们需要的分位数，这个损失函数从结构上看，就是以一定的概率γ惩罚预测值大于实际值，同时鼓励预测值小于实际值，这样的效果就是学得了目标y的γ分位数期望值。</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>AI</tag>
        <tag>loss</tag>
      </tags>
  </entry>
  <entry>
    <title>利用docker和nginx配置wordpress服务器</title>
    <url>/2022/06/18/%E5%88%A9%E7%94%A8docker%E5%92%8Cnginx%E9%85%8D%E7%BD%AEwordpress%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="故事的开始"><a href="#故事的开始" class="headerlink" title="故事的开始"></a>故事的开始</h2><p>之前服务器因为redis配置失误，遭到挖矿木马的攻击，整个瘫痪掉了。不得已狠下心来，重装系统，从头开始配置服务器上的环境。<br>机缘巧合，了解倒了docker这个牛哄哄的部署神器。于是想着使用docker来进行配置wordpress。</p>
<p>那么我们的目标就定了：使用docker配置mysql和wordpress容器，nginx因为需要频繁使用，就直接使用yum下载；配置博客的https。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>一开始配置，走了许多弯路，docker容器删删改改浪费了好多时间，最后还是通过多个优质博客成功了：</p>
<ol>
<li><a class="link" href="https://blog.jimmytinsley.com/2020/06/10/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-docker%E9%83%A8%E7%BD%B2wordpressnginx%E5%B9%B6%E5%90%AF%E7%94%A8ssl/">https://blog.jimmytinsley.com/2020/06/10/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95-docker%E9%83%A8%E7%BD%B2wordpressnginx%E5%B9%B6%E5%90%AF%E7%94%A8ssl/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link" href="https://www.yuribacciarini.com/set-up-docker-wordpress-behind-docker-nginx-with-ssl/">https://www.yuribacciarini.com/set-up-docker-wordpress-behind-docker-nginx-with-ssl/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link" href="https://www.idc1680.com/1320.html">https://www.idc1680.com/1320.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>不知道为什么，明明几乎照着实现，但还是会有一些问题，好在最后还是成功了。</li>
</ol>
<h2 id="配置容器"><a href="#配置容器" class="headerlink" title="配置容器"></a>配置容器</h2><h3 id="编写docker-compose-yml"><a href="#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写docker-compose.yml</h3><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">wordpress-db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.6</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">13306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">wp</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wppwd</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">my-wordpress:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wordpress-db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/php.conf.uploads.ini:/usr/local/etc/php/conf.d/uploads.ini</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./wp-app:/var/www/html</span> <span class="comment"># Full wordpress project</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">13080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">wordpress-db:3306</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wp</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wppwd</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db_data:</span> &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>服务名称可以修改；</li>
<li>ports部分的左边端口号为本地监听的端口，可以根据自己的喜好or需要进行修改；</li>
<li>environment中的变量，根据自己的需要进行修改即可，但是改完之后要保持两个容器中变量的一致性；</li>
</ul>
<h3 id="编写php-conf-uploads-ini"><a href="#编写php-conf-uploads-ini" class="headerlink" title="编写php.conf.uploads.ini"></a>编写php.conf.uploads.ini</h3><div class="highlight-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">file_uploads</span> <span class="string">=</span> <span class="string">On</span></span><br><span class="line"><span class="string">max_execution_time</span> <span class="string">=</span> <span class="number">600</span></span><br><span class="line"><span class="string">memory_limit</span> <span class="string">=</span> <span class="string">512M</span></span><br><span class="line"><span class="string">post_max_size</span> <span class="string">=</span> <span class="string">32M</span></span><br><span class="line"><span class="string">upload_max_filesize</span> <span class="string">=</span> <span class="string">32M</span></span><br></pre></td></tr></table></figure></div>

<h2 id="配置WORKSPACE"><a href="#配置WORKSPACE" class="headerlink" title="配置WORKSPACE"></a>配置WORKSPACE</h2><p>根据自己的习惯，设置一个wordpress的workspace；我个人的话就是把&#x2F;usr&#x2F;wp-blog作为WORKSPACE。</p>
<ol>
<li>在该目录下新建两个目录wp和nginx, 用来存放相关的配置文件；</li>
<li>在wp目录下新建一个wp-app文件夹用来存放映射的WordPress程序文件，把之前的docker-compose.yml放在wp目录下,php.conf.uploads.ini放在wp-app目录下；</li>
</ol>
<p>打工告成<code>cd WORKSPACE/wp; docker-compose up -d</code>启动镜像<br>在浏览器上输入you_ip_address:13080, 如果能够显示wordpress初始化界面，就成功了一大半。但是先不急着初始化。</p>
<h2 id="配置nginx和ssl证书"><a href="#配置nginx和ssl证书" class="headerlink" title="配置nginx和ssl证书"></a>配置nginx和ssl证书</h2><p>通过各种渠道申请到ssl证书后，就可以通过nginx进行配置啦。<br>假设nginx的配置都是最初始的，那么首先在nginx目录下创建一个cert文件夹用来存放证书文件.<br>然后设置nginx.conf,关键部分如下</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">       #SSL 访问端口号为 <span class="number">443</span></span><br><span class="line">       listen <span class="number">443</span> ssl; </span><br><span class="line">       #填写绑定证书的域名</span><br><span class="line">       server_name blog.muzi.fun; </span><br><span class="line">       #证书文件名称</span><br><span class="line">       ssl_certificate cert/blog.muzi.fun_bundle.crt; </span><br><span class="line">       #私钥文件名称</span><br><span class="line">       ssl_certificate_key cert/blog.muzi.fun.key; </span><br><span class="line">       ssl_session_timeout <span class="number">5</span>m;</span><br><span class="line">       #请按照以下协议配置</span><br><span class="line">       ssl_protocols TLSv1<span class="number">.2</span> TLSv1<span class="number">.3</span>; </span><br><span class="line">       #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">       ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256<span class="punctuation">:</span>HIGH<span class="punctuation">:</span>!aNULL<span class="punctuation">:</span>!MD5<span class="punctuation">:</span>!RC4<span class="punctuation">:</span>!DHE; </span><br><span class="line">       ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">       location / <span class="punctuation">&#123;</span></span><br><span class="line">           proxy_pass         http<span class="punctuation">:</span><span class="comment">//127.0.0.1:13080;</span></span><br><span class="line">           # proxy_ssl_server_name on;</span><br><span class="line">           proxy_redirect     off;</span><br><span class="line">           proxy_set_header   Host $host;</span><br><span class="line">           proxy_set_header   X-Real-IP $remote_addr;</span><br><span class="line">           proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">           proxy_set_header   X-Forwarded-Host $server_name;</span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line">   server <span class="punctuation">&#123;</span></span><br><span class="line">       listen <span class="number">80</span>;</span><br><span class="line">       server_name blog.muzi.fun;    </span><br><span class="line">       location / <span class="punctuation">&#123;</span></span><br><span class="line">           return <span class="number">301</span> https<span class="punctuation">:</span><span class="comment">//blog.muzi.fun$request_uri;</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>注意，具体的ssl配置规则以发放ssl证书厂商为准，可以灵活修改。<br>在启动nginx镜像前, 请先确保80和443端口没有被占用, 再确保WordPress在http协议下的ip:port的访问是否正常, 再再确保你的WordPress是全新的或做好了资料备份的. 一切OK的话, 前往WordPress的设置-&gt;常规中把站点地址和WordPress地址都改成<a class="link" href="https://your_domain.com/">https://your_domain.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>. 这一步有风险, 请不要在WordPress有资料且未备份的情况下执行操作!<br>然后启动nginx。<br>这时尝试<a class="link" href="https://your_domain.com/">https://your_domain.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, 如果能够显示主页，就接近成功啦！为什么是接近呢？因为wordpress的镜像在配置ssl证书之后可能存在一些问题，所以我们需要修改一下内容。</p>
<h3 id="修改wp-config-php"><a href="#修改wp-config-php" class="headerlink" title="修改wp-config.php"></a>修改wp-config.php</h3><p>打开WORKSPACE&#x2F;wp&#x2F;wp-app，在最上面（<code>&lt;?php</code>下边）添加三行即可，注意要加到上面，我之前尝试过加到文件最后面，就无效了，大概这几个变量在该文件中的几个函数里就被重复使用了。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_SERVER[&#x27;HTTPS&#x27;] = &#x27;on&#x27;;</span><br><span class="line">define(&#x27;FORCE_SSL_LOGIN&#x27;, true);</span><br><span class="line">define(&#x27;FORCE_SSL_ADMIN&#x27;, true);</span><br></pre></td></tr></table></figure></div>

<p>至此，我的wordpress就部署好了，等待大家的好消息！</p>
]]></content>
      <categories>
        <category>Application</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>docker</tag>
        <tag>nginx</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-快照数组</title>
    <url>/2023/08/28/%E5%88%B7%E9%A2%98-%E5%BF%AB%E7%85%A7%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现支持下列接口的「快照数组」- SnapshotArray：</p>
<p>SnapshotArray(int length) - 初始化一个与指定长度相等的 类数组 的数据结构。初始时，每个元素都等于 0。<br>void set(index, val) - 会将指定索引 index 处的元素设置为 val。<br>int snap() - 获取该数组的快照，并返回快照的编号 snap_id（快照号是调用 snap() 的总次数减去 1）。<br>int get(index, snap_id) - 根据指定的 snap_id 选择快照，并返回该快照指定索引 index 的值。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：["SnapshotArray","set","snap","set","get"]</span><br><span class="line">     [[3],[0,5],[],[0,6],[0,0]]</span><br><span class="line">输出：[null,null,0,null,5]</span><br><span class="line">解释：</span><br><span class="line">SnapshotArray snapshotArr = new SnapshotArray(3); // 初始化一个长度为 3 的快照数组</span><br><span class="line">snapshotArr.set(0,5);  // 令 array[0] = 5</span><br><span class="line">snapshotArr.snap();  // 获取快照，返回 snap_id = 0</span><br><span class="line">snapshotArr.set(0,6);</span><br><span class="line">snapshotArr.get(0,0);  // 获取 snap_id = 0 的快照中 array[0] 的值，返回 5</span><br></pre></td></tr></table></figure></div>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p>最开始没有理解快照数组的意思, 所以做错了几次. 快照是指对某个阶段的数据进行备份, 并不影响数据的修改是连续的.</p>
</blockquote>
<ul>
<li>暴力解法, 将每次快照都进行完整备份: <code>vector&lt;int, vector&lt;int&gt;&gt;</code>, 会爆内存.</li>
<li>把粒度变细, 对每个index内发生的变化进行记录: <code>vector&lt;map&lt;int, int&gt;&gt;</code></li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SnapshotArray</span> {</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// vector for each index</span></span><br><span class="line">  <span class="comment">// map &lt;snapTime, val&gt;</span></span><br><span class="line">  vector&lt;map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; snapshots;</span><br><span class="line">  <span class="type">int</span> snapTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SnapshotArray</span>(<span class="type">int</span> length) {</span><br><span class="line">    snapshots = vector&lt;map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(length, <span class="built_in">map</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;());</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>{ snapshots[index][snapTime] = val; }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">snap</span><span class="params">()</span> </span>{ <span class="keyword">return</span> snapTime++; }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> snap_id)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> it = snapshots[index].<span class="built_in">upper_bound</span>(snap_id);</span><br><span class="line">    <span class="keyword">return</span> it == snapshots[index].<span class="built_in">begin</span>() ? <span class="number">0</span> : (--it)-&gt;second;</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<h3 id="可优化的部分"><a href="#可优化的部分" class="headerlink" title="可优化的部分"></a>可优化的部分</h3><ul>
<li><code>snapshots = vector&lt;map&lt;int, int&gt;&gt;(length, map&lt;int, int&gt;());</code> 这条初始化很消耗时间和内存, 会生成很多没必要的index slot, 考虑到测试用例的规模可以转换成unordered_map(hashmap)</li>
<li><code>snapTime</code>是递增的, 因此可以用<code>vector&lt;pair&lt;int, int&gt;&gt;</code>加上二分查找来代替map. (这个预计收益不大)</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>STL</tag>
        <tag>map</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题-地图分析</title>
    <url>/2023/08/28/%E5%88%B7%E9%A2%98-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你现在手里有一份大小为 n x n 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地。</p>
<p>请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。</p>
<p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>中等难度图数据结构的题目, 本来解题也还算顺利, 但是看到了官方题解, 写了一些比较有意思的思路, 所以记录一下.</p>
<ul>
<li>最简单的暴力解法: <code>多次bfs</code>, 遍历每个海洋节点, 通过bfs找到最近的陆地单元格, 然后找到这个最短距离的最大值</li>
<li>我的思路: <code>扩张陆地</code>, 从全部陆地单元格出发, 用类似BFS的方式, 先找到距离陆地单元格为1的海洋单元格, 再从距离为1的海洋单元格出发找到距离为2的单元格…以此类推直到找到所有的海洋单元格. 具体实现也很简单, 就和普通的BFS差不多, 维护一个FIFO队列, 每次都从队首单元格出发向上下左右遍历, 将新遍历的单元格加入到队列中.</li>
<li>官方题解包含了多种解法, 其中让人眼前一亮的是它将问题转换为<code>类Dijkstra问题</code>, 这从另一个视角介绍了和我类似的思路: 我们要求陆地和所有海洋单元格的最短距离(最短路), 但Dijkstra解决的是单源最短路, 因此, 它虚构了一个<code>超级源点</code>, 这个超级源点到所有陆地单元格距离为0, 那么我们的问题就变成了求超级源点到其他单元格的最短路径(的最大值).</li>
</ul>
<blockquote>
<p>不过这题相邻节点的距离都是1, 所以用BFS即可. 当图较为复杂时, 可以参考超级源点的这种思路, 将多源最短路变为单源最短路.</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) {}</span><br><span class="line">    <span class="built_in">Node</span>() {}</span><br><span class="line">  };</span><br><span class="line">  queue&lt;Node&gt; nodeQ;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">newOcean</span><span class="params">(Node area, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dis, <span class="type">int</span> curDis)</span> </span>{</span><br><span class="line">    <span class="type">int</span> n = dis.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (area.x &gt;= <span class="number">0</span> &amp;&amp; area.x &lt; n &amp;&amp; area.y &gt;= <span class="number">0</span> &amp;&amp; area.y &lt; n &amp;&amp;</span><br><span class="line">        dis[area.x][area.y] == <span class="number">-1</span>) {</span><br><span class="line">      dis[area.x][area.y] = curDis + <span class="number">1</span>;</span><br><span class="line">      nodeQ.<span class="built_in">push</span>(area);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    } <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">    nodeQ = <span class="built_in">queue</span>&lt;Node&gt;();</span><br><span class="line">    <span class="type">int</span> maxD = <span class="number">0</span>, n = grid.<span class="built_in">size</span>(), cnt = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dis</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) {</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) {</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) {</span><br><span class="line">          nodeQ.<span class="built_in">push</span>(<span class="built_in">Node</span>(i, j));</span><br><span class="line">          dis[i][j] = <span class="number">0</span>;</span><br><span class="line">          ++cnt;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">0</span> || cnt == n * n) {</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    Node cur, area;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; n * n) {</span><br><span class="line">      cur = nodeQ.<span class="built_in">front</span>();</span><br><span class="line">      nodeQ.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">newOcean</span>(<span class="built_in">Node</span>(cur.x - <span class="number">1</span>, cur.y), dis, dis[cur.x][cur.y])) {</span><br><span class="line">        cnt++;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">newOcean</span>(<span class="built_in">Node</span>(cur.x + <span class="number">1</span>, cur.y), dis, dis[cur.x][cur.y])) {</span><br><span class="line">        cnt++;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">newOcean</span>(<span class="built_in">Node</span>(cur.x, cur.y - <span class="number">1</span>), dis, dis[cur.x][cur.y])) {</span><br><span class="line">        cnt++;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">newOcean</span>(<span class="built_in">Node</span>(cur.x, cur.y + <span class="number">1</span>), dis, dis[cur.x][cur.y])) {</span><br><span class="line">        cnt++;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    cur = nodeQ.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">return</span> dis[cur.x][cur.y];</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<h3 id="可优化的部分"><a href="#可优化的部分" class="headerlink" title="可优化的部分"></a>可优化的部分</h3><ul>
<li><p>多个方向, 可以用一个方向数组表示</p>
  <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> dx[<span class="number">4</span>] = {<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>}, dy[<span class="number">4</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>};</span><br><span class="line">...</span><br><span class="line">Node area = <span class="built_in">Node</span>(cur.x+dx[i], cur.y+dy[i]);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>工具类如果没有特殊的功能, 用结构体好一些, 没必要写成类</p>
<p>  ``` c++<br>  typedef struct Node {<br>      int x, y;<br>  }Node;</p>
</li>
</ul>
<p>优化后的代码差不多, 就不放出来了</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈的使用</title>
    <url>/2023/08/29/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">84. 柱状图中最大的矩形</span><br><span class="line">给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</span><br><span class="line"></span><br><span class="line">求在该柱状图中，能够勾勒出来的矩形的最大面积。</span><br><span class="line">示例:</span><br><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure></div>

<p><img lazyload src="/images/loading.svg" data-src="/2023/08/29/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9A%84%E4%BD%BF%E7%94%A8/example1.jpg" alt="示例"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><ul>
<li><code>从位置i出发, 向左向右延展, 构造高度为heights[i]的矩形</code></li>
<li>由于每次都要向左向右找到矩形边界(高度小于位置i的柱子), 时间复杂度O(N^2)</li>
<li>虽然会有几个点超时, 但这个思路是后续优化的出发点.</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>因为最终的目的是寻找对应柱子height[i]右边首个严格小于height[i]的柱子height[r], 以及左边找到首个严格小于height[i]的柱子height[l].<br>维护一个单调递增栈(栈底-&gt;栈顶),那么每当遇到新加入的元素&lt;栈顶便可以确定栈顶柱子右边界<br>而栈顶柱子左边界就是栈顶柱子下面的柱子(&lt;栈顶柱子)<br>左右边界确定以后就可以进行面积计算与维护最大面积</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">    heights.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>, n = heights.<span class="built_in">size</span>(), h, left;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; heights[st.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">          h = heights[st.<span class="built_in">top</span>()];</span><br><span class="line">          st.<span class="built_in">pop</span>();</span><br><span class="line">          left = st.<span class="built_in">empty</span>() ? <span class="number">0</span> : st.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">          result = <span class="built_in">max</span>(result, h * (i - left));</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h2 id="类似的题目"><a href="#类似的题目" class="headerlink" title="类似的题目"></a>类似的题目</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">85. 最大矩形: 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</span><br></pre></td></tr></table></figure></div>

<p>将列中连续的1转换为柱形, 然后根据情况采取暴力或者单调栈进行计算.</p>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>STL</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题仓库</title>
    <url>/2022/06/24/%E5%88%B7%E9%A2%98github%E5%BA%93/</url>
    <content><![CDATA[<p>本来没必要写这篇文章的, 只是这个分类暂时还是空的, 所以先写一篇占着.</p>
<h2 id="个人算法仓库"><a href="#个人算法仓库" class="headerlink" title="个人算法仓库"></a>个人算法仓库</h2><p><a class="link" href="https://github.com/mirthfulLee/AlgorithmExecise">https://github.com/mirthfulLee/AlgorithmExecise <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这个仓库是我刷题(PAT, LeetCode, CSP, 洛谷, 蓝桥杯)时用的仓库.</p>
]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>PAT</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>如何处理溢出问题</title>
    <url>/2022/09/12/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="PAT题目"><a href="#PAT题目" class="headerlink" title="PAT题目"></a>PAT题目</h2><p>题目来源：<a class="link" href="https://pintia.cn/problem-sets/994805342720868352/problems/994805406352654336">https://pintia.cn/problem-sets/994805342720868352/problems/994805406352654336 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="柳神的题解"><a href="#柳神的题解" class="headerlink" title="柳神的题解"></a>柳神的题解</h2><p>分析：<br>因为A、B的大小为[-2^63, 2^63]，用long long 存储A和B的值，以及他们相加的值sum：<br>如果A &gt; 0, B &lt; 0 或者 A &lt; 0, B &gt; 0，sum是不可能溢出的<br>如果A &gt; 0, B &gt; 0，sum可能会溢出，sum范围理应为(0, 2^64 – 2]，溢出得到的结果应该是[-2^63, -2]是个负数，所以sum &lt; 0时候说明溢出了<br>如果A &lt; 0, B &lt; 0，sum可能会溢出，同理，sum溢出后结果是大于0的，所以sum &gt; 0 说明溢出了</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = a + b;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> &amp;&amp; sum &lt; <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: true\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> &amp;&amp; sum &gt;= <span class="number">0</span>){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: false\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; c) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: true\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: false\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h2><p>将a,b,c通过除法和求余计算，分成Significant部分和Least Significant部分。看a+b-c是否大于0来判断a+b是否大于c。</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1065 A+B and C (64bit)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> denom = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a, b, c, sumS, sumL;</span><br><span class="line">    <span class="type">bool</span> result;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="comment">// a+b-c</span></span><br><span class="line">        sumL = a % denom + b % denom - c % denom;</span><br><span class="line">        sumS = a / denom + b / denom - c / denom + sumL / denom ;</span><br><span class="line">        sumL %= denom;</span><br><span class="line">        result = (sumS &gt; <span class="number">0</span>) || (sumS == <span class="number">0</span> &amp;&amp; sumL &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d: %s\n"</span>, i, result ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>PAT</tag>
        <tag>溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划-奇怪的打印机</title>
    <url>/2022/09/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A5%87%E6%80%AA%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><img lazyload src="/images/loading.svg" data-src="/2022/09/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A5%87%E6%80%AA%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA/image-1663160009734.png" class>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>dp[i][j] 表示打印字符串第i位到第j位所需的最少打印次数。而且可以保证的是，打印这个子串时，最优先打印的一定是s[i]这个字符（可能不是唯一方案，但一定是最优方案之一）这点比较难理解。设每次打印的起始位置为start[i]，可以证明的是必然存在最优方案（打印次数为k)，对任意i,j满足1&lt;=i&lt;j&lt;=k，同时满足start[i]&lt;start[j]。可以自己举几个例子就明白了。<br>当理解上面这点之后，思路就比较清晰了。dp[i][k-1]和dp[k][j]都是最优方案，此时如果s[i]==s[k]，就说明打印[i,k-1]子串和[k,j]子串时的第一步是相同的，因此打印[i,j]子串的方案可能为先打印s[i]字符，再分别按照dp[i][k-1]和dp[k][j]的方案打印上面几层字符。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> l = s.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(l, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(l));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l;i++)</span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= l;len++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= l - len;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            dp[i][j] = dp[i + <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= j;k++){</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[k])</span><br><span class="line">    <span class="comment">// 关键的状态转移方程</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k - <span class="number">1</span>] + dp[k][j] - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">0</span>][l - <span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>PAT</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>时间序列预测的多粒度残差学习</title>
    <url>/2022/06/19/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E7%9A%84%E5%A4%9A%E7%B2%92%E5%BA%A6%E6%AE%8B%E5%B7%AE%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p>传统的时序预测，不管是单步还是多步任务，采用的输入和输出往往都是相同粒度的数据。但是直觉上来说，粗粒度的数据能够提供的语义信息，细粒度中也应该包含；而粗粒度数据中突出的信息，也应该能够用来过滤到细粒度任务下的无关语义。因此对某个预测任务，使用不同粒度的数据应该能够有提升效果。<br>Hou, Min, Chang Xu, Zhi Li, Yang Liu, Weiqing Liu, Enhong Chen, and Jiang Bian. 2022. “**Multi-Granularity Residual Learning with Confidence Estimation for Time Series Prediction.**” WWW 2022 - Proceedings of the ACM Web Conference 2022, 112–21. <a class="link" href="https://doi.org/10.1145/3485447.3512056">https://doi.org/10.1145/3485447.3512056 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="基本描述"><a href="#基本描述" class="headerlink" title="基本描述"></a>基本描述</h2><ul>
<li>基本问题：时序数据预测</li>
<li>拓展任务：多粒度数据在预测任务中的信息融合</li>
<li>难点：不同粒度之间的信息存在冗余；不同的预测目标（粒度）对输入数据粒度的侧重也有差异。</li>
<li>创新点or思路：</li>
</ul>
<ol>
<li>从粗粒度数据中获取信息作为细粒度数据的先验知识；细粒度数据对粗粒度数据做残差，从而过滤到冗余信息。</li>
<li>设计一个辨别器来判断该粒度数据是否对目标任务有价值</li>
</ol>
<h2 id="论文细节"><a href="#论文细节" class="headerlink" title="论文细节"></a>论文细节</h2><h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><ul>
<li>输出：输出很简单，即某个粒度的预测任务</li>
<li>输入：输入为多个粒度profile数据。<br>$$<br>\hat{y} = \mathcal{F}<em>{\Theta}\left(X^{1}, \cdots, X^{M}\right)\<br>X^{m}=\left[x</em>{1}^{m}, \cdots, x_{T}^{m}\right] \in \mathbb{R}^{D \times K^{m} \times T}\<br>\lambda / K^{m} \rarr granularity\ of\ X^m<br>$$<br>其中λ是最粗粒度的时间间隔</li>
</ul>
]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>AI</tag>
        <tag>预测</tag>
        <tag>时间序列</tag>
      </tags>
  </entry>
  <entry>
    <title>网络运营服务商的DNS污染导致无法连接github</title>
    <url>/2022/07/01/%E7%BD%91%E7%BB%9C%E8%BF%90%E8%90%A5%E6%9C%8D%E5%8A%A1%E5%95%86%E7%9A%84DNS%E6%B1%A1%E6%9F%93%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5github/</url>
    <content><![CDATA[<h2 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h2><p>最近要去github上下载东西，结果发现github网页能打开，但是就是没办法git clone代码到本地，起初以为是自己的ssl没配置好，折腾了半天，没用；又以为是代理的问题，折腾半天，还是没用。</p>
<img lazyload src="/images/loading.svg" data-src="/2022/07/01/%E7%BD%91%E7%BB%9C%E8%BF%90%E8%90%A5%E6%9C%8D%E5%8A%A1%E5%95%86%E7%9A%84DNS%E6%B1%A1%E6%9F%93%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5github/image-1656656090562.png" class>
<p>几经周折，才发现是网络运营商的问题！！！！</p>
<img lazyload src="/images/loading.svg" data-src="/2022/07/01/%E7%BD%91%E7%BB%9C%E8%BF%90%E8%90%A5%E6%9C%8D%E5%8A%A1%E5%95%86%E7%9A%84DNS%E6%B1%A1%E6%9F%93%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5github/image-1656656155631.png" class>
<img lazyload src="/images/loading.svg" data-src="/2022/07/01/%E7%BD%91%E7%BB%9C%E8%BF%90%E8%90%A5%E6%9C%8D%E5%8A%A1%E5%95%86%E7%9A%84DNS%E6%B1%A1%E6%9F%93%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5github/image-1656655909546.png" class>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>看网上说有一些设置hosts的方法，但是我简单试了一下<br>打开网站<a class="link" href="https://ipaddress.com/website/github.com%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%9F%9F%E5%90%8Dgithub.com%E5%AF%B9%E5%BA%94ip%EF%BC%8C%E5%9C%A8hosts%E4%B8%AD%E5%8A%A0%E4%B8%8A%E4%B8%80%E8%A1%8C%E3%80%82">https://ipaddress.com/website/github.com，查看域名github.com对应ip，在hosts中加上一行。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<img lazyload src="/images/loading.svg" data-src="/2022/07/01/%E7%BD%91%E7%BB%9C%E8%BF%90%E8%90%A5%E6%9C%8D%E5%8A%A1%E5%95%86%E7%9A%84DNS%E6%B1%A1%E6%9F%93%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5github/image-1656671309470.png" class>
<p>再在命令行中输入 <code>ipconfig /flushdns</code>，这样也能够成功clone和push等。</p>
<p>这时我便有一个问题，为什么浏览器能够打开github的网页（开了代理），却不能下载代码？原来是因为本地的git工具需要主动配置代理，否则请求不会被代理。这大概和git本身发送请求的实现细节有关（猜测是直接使用的传输层协议而不是http之类的应用层请求，因此不会被代理工具如clash捕获）<br>之后进行相关设置即可：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy socks5://127.0.0.1:7890</span><br><span class="line">git config --global https.https://github.com.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure></div>

<p>这里的7890根据自己的代理工具进行修改。</p>
<img lazyload src="/images/loading.svg" data-src="/2022/07/01/%E7%BD%91%E7%BB%9C%E8%BF%90%E8%90%A5%E6%9C%8D%E5%8A%A1%E5%95%86%E7%9A%84DNS%E6%B1%A1%E6%9F%93%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5github/image-1656657218478.png" class>

<p>注：下面这个方法后来失效了，原因有待确认。</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>clash</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机的传统与革新</title>
    <url>/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%BC%A0%E7%BB%9F%E4%B8%8E%E9%9D%A9%E6%96%B0/</url>
    <content><![CDATA[<p>最近总是在思考一个很奇怪的问题: “人工智能到底是不是计算机学科的范畴”. 简单来看, AI是运行在计算机上的程序, 也就是一种软件, 这点毋庸置疑, 但是AI的构造方式与其他软件天差地别. 传统的软件开发需要开发人员将目标任务拆解为流程式, 过程式的执行步骤; 而AI的训练, 是将任务的输入和输出投喂给模型, 希望模型能够拟合. 形象来说, 传统计算机是”让人像机器一样思考”; 未来计算机(AI)是”让机器学会像人一样思考”.</p>
<p>基于这样的想法, 可以拓展至对计算机当下和未来的思考. </p>
<h2 id="业务型软件"><a href="#业务型软件" class="headerlink" title="业务型软件"></a>业务型软件</h2><p>计算机的软件发展服务于需求, 而需求主要集中体现在各大互联网企业中. 业务型软件的主流趋势是–微服务, 而微服务的形式很难不让人联想到工业革命后的一个产物–”流水线”. 过去的单一软件, 就像是一个独自完成产品生产的老师傅, 独自就能够完成任务. 但是当产品生产的难度提高, 流程变长, 如果还想要独自完成生产, 不但需要师傅掌握完整产品生产的复杂过程, 还需要频繁地更换手头的工具甚至场地, 这会导致执行效率的低下. 如今的程序就像流水线上的工人, 每个程序只负责巨大工程中极小的部分, 单个工人不需要了解生产的完整流程, 不需要掌握全部的技术, 更不需要在生产过程中更换工具和场地.<br>结合工业生产的发展进程来看, 与流水线相似的微服务似乎就是业务型软件的最终形态. 要想更进一步, 必要的措施是”整合供应链”. 其实很简单, 就是将微服务进一步分解为”计算型”, “内存型”, “存储型”, “网络IO型”等等, 将不同的服务分配给拥有不同侧重点的服务器或者服务供应商.</p>
<h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p>不同于过去针对具体任务设计模型和投喂数据进行训练, 如今LLM希望实现泛用性AI. 这确实很酷, 但是”术业有专攻”, 要想实现复杂的任务, 还是需要擅长不同领域的”专家”, 而”泛用性”的目标同样可以通过类似”流水线”的方式实现.</p>
]]></content>
      <categories>
        <category>Disscussion</category>
      </categories>
      <tags>
        <tag>就业</tag>
      </tags>
  </entry>
  <entry>
    <title>c++和java的选择</title>
    <url>/2023/08/21/%E8%AF%AD%E8%A8%80%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p>每个想要当程序员的人总是离不开几个经典问题:</p>
<ul>
<li>做开发还是算法?</li>
<li>做前端还是后端?</li>
<li>前端学什么框架?后端选什么语言?</li>
</ul>
<p>作为一个软件工程的学生, 不管是前端后端, java亦或c++我都接触过. 这里想主要针对c++和java之间的选择简单谈谈.</p>
<h2 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h2><p>总所周知, 编程语言是具有不同用途的, 如面向数据统计, 面向科学计算, 面向商业应用, 面向底层服务等等. 不同的应用场景有不同的要求和侧重点, 因此不同场景所常用的编程语言也有所不同. 然而一旦聚焦到了”后端”这里, 大家就忽略了这点. 其实即使是后端, 也分了很多种, 如音视频后端, AI模型后端, 高并发应用后端, 游戏后端等等. 因此, c++和java因为语言和生态的特性, 主要的实际应用场景是有一定区别的, 在正式思考之前, 必须要摒弃掉编程语言的鄙视链观点, 无论是流行至上, 还是底层为王都是片面, 不正确的.</p>
<h2 id="为什么公司选择java"><a href="#为什么公司选择java" class="headerlink" title="为什么公司选择java?"></a>为什么公司选择java?</h2><p>java凭借垃圾回收, 跨平台性以及完整的生态, 能够通过简洁的代码高效的实现业务逻辑. 这在前些年互联网行业快速扩张, 互相竞争的时代是相当重要的 – 提高开发效率, 减少软件bug, 提前上线占据市场, 多花的服务器费用在铺天盖地的广告推广费用面前不值一提. 至于高并发的场景, 通过云服务厂商的”弹性计算”增加硬件资源, 比软件层面慢慢优化要直观可靠且便宜的多. 后面如果想要优化, 通常借助java生态中成熟的工具也能简单地得到显著提升. 要想走到深度优化这一步, 通常只有极少数大厂的核心业务, 虽然优化的上限不如更加”底层”的c++, 但是也完全够用了. 更何况, 大部分大厂, 面对”服务器成本高”的问题, 解决方案不是减少服务器的使用, 而是自己下场来做服务器(所以才有了那么多的云服务商).</p>
<p>在众多成熟的语言中, java很好地均衡了性能和开发成本, 学习门槛较为友好, 生态成熟, 被市场广泛验证, 因此被众多公司采纳. 归根到底, 微小的性能差异用户并不一定有感知, 但是高昂的开发成本确是实实在在的money啊.</p>
<h2 id="C-用在何处"><a href="#C-用在何处" class="headerlink" title="C++用在何处?"></a>C++用在何处?</h2><p>都说C++岗位少, 这是事实, 即使是在C++底蕴较为深厚的腾讯, 很多业务也换成了java甚至go. 但有一些领域还是需要C++的, 如音视频, 游戏服务器, 高性能服务器, 数据库等等. 这些领域, 不像java开发侧重点在于业务实现, C++更注重实现细节, 因此开发过程中离不开计算机基础, 如计算机网络和操作系统, 有时甚至需要涉及硬件细节.</p>
<h2 id="竞争力的区别"><a href="#竞争力的区别" class="headerlink" title="竞争力的区别"></a>竞争力的区别</h2><p>java, 语言本身的门槛并不高, 但是与业务绑定, 因此非常看重平台. 不同的公司, 使用和接触的解决方案天差地别, 所能积累到的经验和履历也就有着巨大的差距.</p>
<p>C++更多的是在学习和应用计算机的底层技术, 能够随着项目不断增加对底层的熟悉程度和性能优化的功力, 颇有机械和设计行业越老越香的感觉. 当然这里的要求是使用C++实现高性能复杂任务, 而不是基于某些库, 实现不同的应用业务, 那就有些本末倒置了.</p>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择?"></a>如何选择?</h2><p>在选择时, 有几个考虑维度, 排名不分先后:</p>
<ol>
<li>学习时间长短和计算机基础掌握情况. C++的学习门槛较高, 需要提前投入大量的时间, 如果求职在即, 或者读研期间校内任务较重, 可以优先考虑JAVA. 虽然C++和JAVA在求职时都会通过八股文考察计算机基础, 但是在实际开发中C++对计算机网络, 操作系统, 计算机体系结构等内容要求更高, 是真正需要熟悉掌握的, 否则可以说是寸步难行.</li>
<li>科班和学历. 不像java面向业务, 在大中小厂中都有大量工作岗位, C++除开一些特殊方向, 如驱动开发和嵌入式, 大部分优质岗位集中在大厂的研发部门以及各种研究所, 对学历和本科专业有要求.</li>
<li>个人兴趣和职业规划. 无论是java还是C++, 如今都卷的飞起, 因此还是回归初心, 关注一下自己的个人兴趣和职业规划吧…. 如果以后想做管理, 做产品, 甚至有创业想法的, java更合适; 如果是对计算机基础感兴趣, 数学和算法扎实, 或者想走游戏开发, 可以考虑学习C++做一辈子技术.</li>
</ol>
<p>想要了解行情, 可以上微信小程序“天窗说”, “OfferShow”, 看一看到底市场上的大厂研发工程师的薪资是多少.</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>编程语言并不是非黑即白的, 任何一个代码工作人员, 都不可能只掌握一门语言, 语言不过是工具罢了. 针对不同的场景, 选择不同的语言, 是一个软件工程师的基本常识. 而打下良好的计算机基础, 是一个软件工程师的基本素养. 外行才嚷嚷, 内行全都要.</p>
]]></content>
      <categories>
        <category>Disscussion</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>就业</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌学术检索论文</title>
    <url>/2023/05/28/%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%E6%A3%80%E7%B4%A2%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近用谷歌学术检索论文的时候需要指定论文的来源（期刊 &#x2F; 会议），网上搜索了相关教程。然而排名靠前的文章提供的方法都不好使：），后面在 b 站上发现了一个<a class="link" href="https://www.bilibili.com/video/BV1yE411q775">视频教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，实测有效，在此记录一下。</p>
<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>首先，假设检索的关键词是 Dimensionality reduction，（这里没有加双引号，Dimensionality 和 reduction 相当于两个词）来源包括 IEEE Transactions on Visualization and Computer Graphics、IEEE VIS 和 EuroVis。</p>
<p>那么在输入框中输入的应该是 Dimensionality reduction (source:“IEEE Transactions on Visualization and Computer Graphics” OR source:“EuroVis” OR source:“IEEE VIS”)</p>
<p>前面的关键词就不解释了，注意看后面的括号中包括的内容。其中 source:“XXX” 表示来源为 XXX，OR 表示或，取并集，即多个来源，注意是大写。</p>
<p>检索结果截图如下，可以看到一共有 429 个结果。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如果要搜索多个关键词，比如 Dimensionality reduction 和 evaluation，来源依然是最开始设定的那 3 个，那么我们输入的应该是 (“Dimensionality reduction” AND “evaluation”) (source:“IEEE Transactions on Visualization and Computer Graphics” OR source:“EuroVis” OR source:“IEEE VIS”)</p>
<p>其中 <code>AND</code> 表示关键词同时在一篇论文中出现，如果改成 <code>OR</code> 的话，出现其中一个就符合条件。</p>
<p>检索结果截图如下，可以看到用 <code>AND</code> 时一共有 206 个结果，用 <code>OR</code> 时一共有 2970 个结果。</p>
<p>至于指定时间范围和论文作者就不在此说明了，点击左上角菜单键选择<strong>高级搜索</strong>即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link" href="https://www.bilibili.com/video/BV1yE411q775">如何限定期刊？（多篇核心期刊限定） Google Scholar 谷歌学术文献检索技巧 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> <a class="link" href="https://taifua.com/google-scholar-specify-multiple-sources.html">https://taifua.com/google-scholar-specify-multiple-sources.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Sharing</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>论文检索</tag>
      </tags>
  </entry>
  <entry>
    <title>acme获取泛域名证书</title>
    <url>/2024/02/28/notion-acme%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6-413fe32e/</url>
    <content><![CDATA[<h2 id="下载acme脚本"><a href="#下载acme脚本" class="headerlink" title="下载acme脚本"></a>下载acme脚本</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">curl  https://get.acme.sh | sh</span><br></pre></td></tr></table></figure></div>

<h2 id="设置证书CA-ZeroSSL"><a href="#设置证书CA-ZeroSSL" class="headerlink" title="设置证书CA - ZeroSSL"></a>设置证书CA - ZeroSSL</h2><p>acme 3.0开始默认使用ZeroSSL作为证书服务商, 这步可以跳过</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">acme.sh --set-default-ca --server zerossl</span><br></pre></td></tr></table></figure></div>

<h3 id="设置API-Key"><a href="#设置API-Key" class="headerlink" title="设置API Key"></a>设置API Key</h3><p><a class="link" href="https://app.zerossl.com/developer">https://app.zerossl.com/developer <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">acme.sh --register-account -m myemail@example.com --server zerossl --eab-kid &lt;eab-kid&gt; --eab-hmac-key &lt;eab-hmac-key&gt;</span><br></pre></td></tr></table></figure></div>

<h2 id="配置DNS-API和获取证书"><a href="#配置DNS-API和获取证书" class="headerlink" title="配置DNS_API和获取证书"></a>配置DNS_API和获取证书</h2><p><a class="link" href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">https://github.com/acmesh-official/acme.sh/wiki/dnsapi <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>找到自己使用的域名供应商, 进行配置</p>
<h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><p>把证书安装到nginx目录下.</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">acme.sh --install-cert -d yourdomain.com -d &quot;*.yourdomain.com&quot; \</span><br><span class="line">--cert-file /etc/nginx/cert/cert.crt \</span><br><span class="line">--key-file /etc/nginx/cert/privkey.pem \</span><br><span class="line">--fullchain-file /etc/nginx/cert/fullchain.pem \</span><br><span class="line">--reloadcmd     &quot;service nginx force-reload&quot;</span><br></pre></td></tr></table></figure></div>

<h2 id="nginx设置https"><a href="#nginx设置https" class="headerlink" title="nginx设置https"></a>nginx设置https</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nginx.conf</span><br><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="line">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span><br><span class="line"></span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 4096;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        server_name  www.mirthfullee.top blog.mirthfullee.top mirthfullee.top;</span><br><span class="line">        # hexo blog content</span><br><span class="line">        root         &lt;content-root&gt;;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line">        </span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">        location = /404.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    # ssl cert</span><br><span class="line">    include /etc/nginx/ssl.conf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">    if ($host = mirthfullee.top) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line">    if ($host = *.mirthfullee.top) &#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    listen       80;</span><br><span class="line">    listen       [::]:80;</span><br><span class="line">    # 设置自动http转https</span><br><span class="line">    server_name  *.mirthfullee.top mirthfullee.top;</span><br><span class="line">    return 404;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    # proxy nas services</span><br><span class="line">    include /etc/nginx/proxy.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意nginx的ssl_certficate设置的是fullchain证书, 否则会报错.</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ssl.conf</span><br><span class="line"># listen [::]:443 ssl ipv6only=on;</span><br><span class="line"># listen [::]:443; # manually changed</span><br><span class="line"># ssl on;</span><br><span class="line">listen 443 ssl;</span><br><span class="line">ssl_certificate /etc/nginx/cert/fullchain.pem; </span><br><span class="line">ssl_certificate_key /etc/nginx/cert/privkey.pem; </span><br><span class="line"></span><br><span class="line">ssl_session_cache shared:le_nginx_SSL:10m;</span><br><span class="line">ssl_session_timeout 1440m;</span><br><span class="line">ssl_session_tickets off;</span><br><span class="line"></span><br><span class="line">ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">ssl_prefer_server_ciphers off;</span><br><span class="line"></span><br><span class="line">ssl_ciphers &quot;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Application</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>通过hexo部署个人博客</title>
    <url>/2024/02/28/notion-%E9%80%9A%E8%BF%87hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-02954966/</url>
    <content><![CDATA[<p>从wordpress迁移至hexo，优点有：</p>
<ul>
<li>全部由静态网页组成，方便迁移</li>
<li>可以部署为github page</li>
<li>对markdown原生支持！</li>
</ul>
<p>参考文档：</p>
<ul>
<li><a class="link" href="https://hexo.io/docs/">hexo官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link" href="https://redefine-docs.ohevan.com/docs/intro">优秀主题-redefine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link" href="https://blog.csdn.net/yaorongke/article/details/119089190">配置过程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">nvs # 选择nodejs 版本</span><br><span class="line">hexo clean （清空本地导出的博客）</span><br><span class="line">hexo g (重新生成)</span><br><span class="line">hexo d 发布到github上</span><br><span class="line">hexo g -d # 生成并发布命令</span><br><span class="line">hexo server # 本地运行</span><br></pre></td></tr></table></figure></div>


<h2 id="部署到服务器"><a href="#部署到服务器" class="headerlink" title="部署到服务器"></a>部署到服务器</h2><ul>
<li>nginx</li>
<li>acme获取免费ssl证书实现https</li>
</ul>
<h2 id="定期刷新"><a href="#定期刷新" class="headerlink" title="定期刷新"></a>定期刷新</h2><p>自动化脚本+crobtab</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 设置工作目录</span><br><span class="line">cd &quot;$(dirname &quot;$0&quot;)&quot;</span><br><span class="line"># 选择npm版本</span><br><span class="line">PATH=~/.nvs/node/17.7.2/x64/bin:$PATH</span><br><span class="line"># 与github repository同步</span><br><span class="line">git pull origin master</span><br><span class="line"># (重新生成)</span><br><span class="line">hexo g</span><br><span class="line"># 发布到github上</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="code"><pre><span class="line">$ crontab -e</span><br><span class="line"></span><br><span class="line"># 每天三点自动更新</span><br><span class="line">0 3 * * * bash &lt;hexo-blog-dir&gt;/update.sh &gt;&gt; &lt;hexo-blog-dir&gt;/update.log</span><br></pre></td></tr></table></figure></div>


]]></content>
      <categories>
        <category>Application</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
